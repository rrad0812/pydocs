
# Modeli i baze podataka

## Sadržaj

- [Modeli](#modeli)
- [Postavljanje upita](#postavljanje-upita)
- Agregacija
- Pretraga
- Menadžeri
- Izvršavanje sirovih SQL upita
- Transakcije baze podataka
- Više baza podataka
- Tabelarni prostori
- Optimizacija pristupa bazi podataka
- Instrumentacija baze podataka
- Raspored utakmica
- Primeri korišćenja API-ja za odnose sa modelima

## Modeli

Model je jedini, definitivni izvor informacija o vašim podacima. On sadrži osnovna polja i ponašanja podataka koje čuvate. Generalno, svaki model se mapira na jednu tabelu baze podataka.

Osnove:

- Svaki model je Pajton klasa koja gradi podklase `django.db.models.Model`.
- Svaki atribut modela predstavlja polje baze podataka.

Uz sve ovo, Django vam daje automatski generisan API za pristup bazi podataka, pogledajte [Pravljenje upita]().

### Brzi primer

Ovaj primer definiše klasu modela "Person", koja ima atribute "first_name" i "last_name":

```py
from django.db import models

class Person(models.Model):                      
    first_name = models.CharField(max_length=30) 
    last_name = models.CharField(max_length=30)
```

Svako polje je navedeno kao atribut klase, a svaki atribut se mapira na kolonu baze podataka.

Gore navedeni "Person" model bi kreirao tabelu baze podataka ovako:

```sql
CREATE TABLE myapp_person (
    "id" bigint NOT NULL PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    "first_name" varchar(30) NOT NULL,
    "last_name" varchar(30) NOT NULL
);
```

Neke tehničke napomene:

- Naziv tabele, "myapp_person", se automatski izvodi iz nekih meta podataka modela, ali se može zameniti. Više detalja potražite u odeljku [Nazivi tabela]().

- Polje "id" se dodaje automatski, ali ovo ponašanje se može zameniti. Pogledajte [Automatska polja primarnog ključa]().

- SQL u ovom primeru je formatiran korišćenjem PostgreSQL CREATE TABLE sintakse, ali vredi napomenuti da Django koristi SQL prilagođen serverskoj strani baze podataka navedenoj u vašoj datoteci sa podešavanjima.

### Korišćenje modela

Kada definišete svoje modele, potrebno je da kažete Djangu da ćete koristiti te modele. Uradite to tako što ćete izmeniti `settings.py` datoteku sa podešavanjima i promeniti INSTALLED_APPS postavku da biste dodali ime modula koji sadrži vaš `models.py`.

Na primer, ako se modeli za vašu aplikaciju nalaze u modulu `myapp.models` ( struktura paketa koju kreira skripta za aplikaciju `manage.py startapp myapp` ), trebalo bi da glasi, između ostalog:

```py
INSTALLED_APPS = [
    #...
    "myapp",
    #...
]
```

Kada dodajete nove aplikacije u INSTALLED_APPS, obavezno pokrenite `manage.py migrate`, opciono prvo izvršite `manage.py makemigrations` migracije za njih.

### Polja

Najvažniji deo modela – i jedini obavezni deo modela – je lista polja baze podataka koje definiše. Polja su određena atributima klase. Pazite da ne izaberete imena polja koja su u sukobu sa API-jem modela, kao što su `clean`, `save` ili `delete`.

Primer:

```py
from django.db import models

class Musician(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    instrument = models.CharField(max_length=100)

class Album(models.Model):
    artist = models.ForeignKey(Musician, on_delete=models.CASCADE)
    name = models.CharField(max_length=100)
    release_date = models.DateField()
    num_stars = models.IntegerField()
```

#### Tipovi polja

Svako polje u vašem modelu treba da bude instanca odgovarajuće `Field` klase. Django koristi tipove klasa polja da bi odredio nekoliko stvari:

- Tip kolone, koji govori bazi podataka koju vrstu podataka da čuva (npr. INTEGER, VARCHAR, TEXT).

- Podrazumevani HTML vidžet koji se koristi prilikom prikazivanja polja obrasca (npr. `<input type="text"><select>`).

- Minimalni zahtevi za validaciju, koji se koriste u Djangovoj administraciji i u automatski generisanim formama.

Django se isporučuje sa desetinama ugrađenih tipova polja, kompletnu listu možete pronaći u [Referenci za polja modela]().

Možete lako napisati sopstvena polja ako Django-ova ugrađena polja nisu dovoljna; pogledajte [Kako kreirati prilagođena polja modela]().

#### Opcije polja

Svako polje prihvata određeni skup argumenata specifičnih za polje (dokumentovano u [Referenci polja modela]() ). Na primer, `CharField` (i njegove podklase) zahtevaju `max_length` argument koji određuje veličinu VARCHAR polja baze podataka koje se koristi za čuvanje podataka.

Takođe postoji skup uobičajenih argumenata dostupnih za sve tipove polja. Svi su opcioni. Detaljno su objašnjeni u [Referenci polja modela]() , ali evo kratkog pregleda najčešće korišćenih:

- **null**

    Ako je "True", Django će čuvati prazne vrednosti kao NULL u bazi podataka. Podrazumevano je "False".

- **blank**

    Ako je "True", polje može biti prazno. Podrazumevano je "False".  

    Imajte na umu da se ovo razlikuje od `null`. `Null` je isključivo vezano za bazu podataka, dok je `blank` vezano za validaciju. Ako polje ima `blank=True`, validacija obrasca će dozvoliti unos prazne vrednosti. Ako polje ima `blank=False`, polje će biti obavezno.

- **choices**

    Niz torki, mapiranja, tip nabrajanja ili pozivljiva klasifikacija (koja ne očekuje argumente i vraća bilo koji od prethodnih formata), koja se koristi kao izbor za ovo polje. Ako je ovo dato, podrazumevani vidžet forme će biti polje za izbor umesto standardnog tekstualnog polja i ograničiće izbore na date opcije.  

    Lista izbora može izgledati ovako:

    ```py
    YEAR_IN_SCHOOL_CHOICES = [
        ("FR", "Freshman"),
        ("SO", "Sophomore"),
        ("JR", "Junior"),
        ("SR", "Senior"),
        ("GR", "Graduate"),
    ]
    ```

    > [!Note]
    >
    > Nova migracija se kreira svaki put kada se redosled `choices` promeni.

    Prvi element u svakoj torci je vrednost koja će biti sačuvana u bazi podataka. Drugi element prikazuje vidžet polja forme.

    Za datu instancu modela, vrednostima polja sa `choices` može se pristupiti korišćenjem `get_(field_name)_display()` metode. Na primer:

    ```py
    from django.db import models

    class Person(models.Model):
        SHIRT_SIZES = {
            "S": "Small",
            "M": "Medium",
            "L": "Large",
        }
        name = models.CharField(max_length=60)
        shirt_size = models.CharField(max_length=1, choices=SHIRT_SIZES)

    >>> p = Person(name="Fred Flintstone", shirt_size="L")
    >>> p.save()
    >>> p.shirt_size
    'L'
    >>> p.get_shirt_size_display()
    'Large'
    ```

    Takođe možete koristiti klase nabrajanja da biste definisali `choices` na sažet način:

    ```py
    from django.db import models

    class Runner(models.Model):
        MedalType = models.TextChoices("MedalType", "GOLD SILVER BRONZE")
        name = models.CharField(max_length=60)
        medal = models.CharField(blank=True, choices=MedalType, max_length=10)
    ```

    Dalji primeri su dostupni u [Referenci polja modela]().

- **default**

    Podrazumevana vrednost za polje. Ovo može biti vrednost ili objekat koji se može pozvati. Ako je objekat koji se može pozvati, biće pozvan svaki put kada se kreira novi objekat.

- **db_default**

    Podrazumevana vrednost polja koju izračunava baza podataka. Ovo može biti literalna vrednost ili funkcija baze podataka.

    Ako su podešeni oba i `db_default` i `default`, imaće prednost pri kreiranju instanci u Pajton kodu. db_default će i dalje biti podešeno na nivou baze podataka i koristiće se pri umetanju redova van ORM-a ili pri dodavanju novog polja u migraciji.

- **help_text**

    Dodatni tekst pomoći koji će se prikazivati uz vidžet formulara. Koristan je za dokumentaciju čak i ako se vaše polje ne koristi na formularu.

- **primary_key**

    Ako je "True", ovo polje je primarni ključ za model.

    Ako ne navedete "primary_key=True" ni za jedno polje u vašem modelu, Django će automatski dodati polje koje će čuvati primarni ključ, tako da ne morate da podešavate "primary_key=True" za ni jedno od vaših polja osim ako ne želite da poništite podrazumevano ponašanje primarnog ključa. Za više informacija, pogledajte [Automatska polja primarnog ključa]().

    Polje primarnog ključa je samo za čitanje. Ako promenite vrednost primarnog ključa na postojećem objektu, a zatim ga sačuvate, novi objekat će biti kreiran pored starog. Na primer:

    ```py
    from django.db import models

    class Fruit(models.Model):
        name = models.CharField(max_length=100, primary_key=True)

    >>> fruit = Fruit.objects.create(name="Apple")
    >>> fruit.name = "Pear"
    >>> fruit.save()
    >>> Fruit.objects.values_list("name", flat=True)
    <QuerySet ['Apple', 'Pear']>
    ```

- **unique**

    Ako je "True", ovo polje mora biti jedinstveno u celoj tabeli.

Ponovo, ovo su samo kratki opisi najčešćih opcija polja. Potpune informacije možete pronaći u referenci za opcije polja uobičajenog modela.

#### Automatska polja primarnog ključa

Podrazumevano, Django svakom modelu daje automatski inkrementirajući primarni ključ tipa navedenog za svaku aplikaciju u podešavanju `AppConfig.default_auto_field` ili globalno u DEFAULT_AUTO_FIELD. Na primer:

```py
id = models.BigAutoField(primary_key=True)
```

Ako želite da navedete prilagođeni primarni ključ, navedite ga kao "primary_key=True" u jednom od vaših polja. Ako Django vidi da ste eksplicitno podesili "Field.primary_key", neće dodati automatsku "id" kolonu.

Svaki model zahteva tačno jedno polje sa "primary_key=True" (ili eksplicitno deklarisano ili automatski dodato).

#### Detaljna imena polja

Svaki tip polja, osim `ForeignKey`, `ManyToManyField` i `OneToOneField`, prihvata opcioni prvi pozicioni argument – detaljno ime. Ako detaljno ime nije dato, Django će ga automatski kreirati koristeći ime atributa polja, pretvarajući donje crte u razmake.

U ovom primeru, detaljno ime je: "person's first name"

```py
first_name = models.CharField("person's first name", max_length=30)
```

U ovom primeru, detaljno ime je :"first name"

```py
first_name = models.CharField(max_length=30)
```

`ForeignKey`, `ManyToManyField` i `OneToOneField` zahtevaju da prvi argument bude klasa modela, pa koristite `verbose_name` ključnu reč kao argument:

```py
poll = models.ForeignKey(
    Poll,
    on_delete=models.CASCADE,
    verbose_name="the related poll",
)
sites = models.ManyToManyField(Site, verbose_name="list of sites")
place = models.OneToOneField(
    Place,
    on_delete=models.CASCADE,
    verbose_name="related place",
)
```

Konvencija je da se prvo slovo reference ne piše velikim slovom u verbose_name. Django će automatski pisati veliko prvo slovo gde je potrebno.

### Relacije

Jasno je da moć relacionih baza podataka leži u povezivanju tabela jedne sa drugom. Django nudi načine za definisanje tri najčešća tipa odnosa između tabela baza podataka: `više prema jedan`, `više prema više` i `jedan prema jedan`.

#### Relacije više prema jedan

Da biste definisali odnos `više prema jedan`, koristite `django.db.models.ForeignKey`. Koristite ga baš kao i bilo koji drugi `Field` tip: uključivanjem kao atributa klase vašeg modela.

ForeignKey zahteva pozicioni argument: klasu sa kojom je model povezan.

Na primer, ako Car model ima Manufacturer– to jest, Manufacturer proizvodi više automobila, ali svaki Car ima samo jedan Manufacturer– koristite sledeće definicije:

```py
from django.db import models

class Manufacturer(models.Model):
    #...
    pass

class Car(models.Model):
    manufacturer = models.ForeignKey(Manufacturer, on_delete=models.CASCADE)
    #...
```

Takođe možete kreirati rekurzivne odnose (objekat sa odnosom više prema jedan prema samom sebi) i odnose sa modelima koji još nisu definisani; pogledajte referencu polja modela za detalje.

Preporučuje se, ali nije obavezno, da naziv ForeignKey polja ( manufacturer u gornjem primeru ) bude naziv modela, malim slovima. Možete nazvati polje kako god želite. Na primer:

```py
class Car(models.Model):
    company_that_makes_it = models.ForeignKey(
        Manufacturer,
        on_delete=models.CASCADE,
    )
    #...
```

Vidi takođe:

ForeignKey polja prihvataju brojne dodatne argumente koji su objašnjeni u referenci polja modela. Ove opcije pomažu u definisanju kako bi odnos trebalo da funkcioniše; sve su opcione.

Za detalje o pristupanju objektima povezanim unazad, pogledajte sledeći primer odnosa unazad.

Za primer koda, pogledajte primer modela odnosa više prema jednom.

#### Relacije više prema više

Da biste definisali relaciju više prema više, koristite ManyToManyField. Koristite ga baš kao i bilo koji drugi Field tip: uključivanjem kao atributa klase vašeg modela.

ManyToManyField zahteva pozicioni argument: klasu sa kojom je model povezan.

Na primer, ako a Pizza ima više Topping objekata – to jest, jedan Topping može biti na više pica i svaka Pizza ima više dodataka – evo kako biste to predstavili:

```py
from django.db import models

class Topping(models.Model):
    #...
    pass

class Pizza(models.Model):
    #...
    toppings = models.ManyToManyField(Topping)
```

Kao i kod ForeignKey, takođe možete kreirati rekurzivne odnose (objekat sa odnosom više prema više prema samom sebi) i odnose sa modelima koji još nisu definisani.

Preporučuje se, ali nije obavezno, da ime ManyToManyField ( toppings u gornjem primeru ) bude u množini koja opisuje skup povezanih objekata modela.

Nije bitno koji model ima ManyToManyField, ali treba da ga stavite samo u jedan od modela – ne u oba.

Generalno, ManyToManyField instance treba da idu u objekat koji će se uređivati na formi. U gornjem primeru, toppings je u Pizza (umesto da Topping ima pizzas ManyToManyField) jer je prirodnije razmišljati o pici sa dodacima nego o dodatku na više pica. Način na koji je podešeno gore, Pizza forma bi omogućila korisnicima da izaberu dodatke.

Vidi takođe:
Pogledajte primer modela odnosa više prema više za kompletan primer.

ManyToManyField polja takođe prihvataju niz dodatnih argumenata koji su objašnjeni u referenci polja modela. Ove opcije pomažu u definisanju kako bi odnos trebalo da funkcioniše; sve su opcione.

#### Dodatna polja u relacijama više prema više

Kada se bavite samo odnosima tipa više prema više, kao što je mešanje i uparivanje pica i preliva, standardno ManyToManyField je sve što vam je potrebno. Međutim, ponekad vam može biti potrebno da povežete podatke sa odnosom između dva modela.

Na primer, razmotrimo slučaj aplikacije koja prati muzičke grupe kojima muzičari pripadaju. Postoji odnos više prema više između osobe i grupa čiji je član, tako da biste mogli koristiti ManyToManyField da predstavite ovaj odnos. Međutim, postoji mnogo detalja o članstvu koje biste možda želeli da prikupite, kao što je datum kada se osoba pridružila grupi.

U ovim situacijama, Django vam omogućava da odredite model koji će se koristiti za upravljanje odnosom više prema više. Zatim možete dodati dodatna polja na srednji model. Srednji model je povezan sa ManyToManyField korišćenjem throughargumenta da bi se ukazalo na model koji će delovati kao posrednik. Za naš primer muzičara, kod bi izgledao otprilike ovako:

```py
from django.db import models

class Person(models.Model):
    name = models.CharField(max_length=128)

    def __str__(self):
        return self.name

class Group(models.Model):
    name = models.CharField(max_length=128)
    members = models.ManyToManyField(Person, through="Membership")

    def __str__(self):
        return self.name

class Membership(models.Model):
    person = models.ForeignKey(Person, on_delete=models.CASCADE)
    group = models.ForeignKey(Group, on_delete=models.CASCADE)
    date_joined = models.DateField()
    invite_reason = models.CharField(max_length=64)

    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=["person", "group"], name="unique_person_group"
            )
        ]
```

Kada podešavate posrednički model, eksplicitno navodite strane ključeve za modele koji su uključeni u odnos više prema više. Ova eksplicitna deklaracija definiše kako su dva modela povezana.

Ako ne želite višestruke asocijacije između istih instanci, dodajte UniqueConstraint uključujući i , from i to polja. Django-ove automatski generisane tabele više prema više uključuju takvo ograničenje.

Postoji nekoliko ograničenja za srednji model:

- Vaš međumodel mora da sadrži jedan - i samo jedan - strani ključ za izvorni model (to bi bilo Group u našem primeru), ili morate eksplicitno navesti strane ključeve koje Django treba da koristi za vezu koristeći ManyToManyField.through_fields. Ako imate više od jednog stranog ključa i through_fields nije navedeno, doći će do greške validacije. Slično ograničenje važi i za strani ključ za ciljni model (to bi bilo Personu našem primeru).

- Za model koji ima relaciju više prema više sa samim sobom preko posredničkog modela, dozvoljena su dva strana ključa za isti model, ali će se tretirati kao dve (različite) strane relacije više prema više. Ako through_fieldsnije navedeno, prvi strani ključ će se smatrati izvornom stranom modela ManyToManyField, dok će drugi predstavljati ciljnu stranu. Međutim, ako postoji više od dva strana ključa, morate through_fields eksplicitno naznačiti koje strane ključeve treba koristiti, u suprotnom će se javiti greška u validaciji.

Sada kada ste podesili ManyToManyField da koristi vaš posrednički model ( Membership, u ovom slučaju ), spremni ste da počnete sa kreiranjem relacija više prema više. To radite kreiranjem instanci posredničkog modela:

```py
>>> ringo = Person.objects.create(name="Ringo Starr")
>>> paul = Person.objects.create(name="Paul McCartney")
>>> beatles = Group.objects.create(name="The Beatles")
>>> m1 = Membership(
...     person=ringo,
...     group=beatles,
...     date_joined=date(1962, 8, 16),
...     invite_reason="Needed a new drummer.",
... )
>>> m1.save()
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>]>
>>> ringo.group_set.all()
<QuerySet [<Group: The Beatles>]>
>>> m2 = Membership.objects.create(
...     person=paul,
...     group=beatles,
...     date_joined=date(1960, 8, 1),
...     invite_reason="Wanted to form a band.",
... )
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>, <Person: Paul McCartney>]>
```

Takođe možete koristiti add(), create() ili set() da biste kreirali odnose, sve dok navedete through_defaults za sva obavezna polja:

```py
>>> beatles.members.add(john, through_defaults={"date_joined": date(1960, 8, 1)})
>>> beatles.members.create(
...     name="George Harrison", through_defaults={"date_joined": date(1960, 8, 1)}
... )
>>> beatles.members.set(
...     [john, paul, ringo, george], through_defaults={"date_joined": date(1960, 8, 1)}
... )
```

Možda ćete više voleti da direktno kreirate instance srednjeg modela.

Ako prilagođena tabela kroz koju je definisan srednjim modelom ne nameće jedinstvenost na paru, dozvoljavajući višestruke vrednosti, poziv će ukloniti sve instance srednjeg modela: (model1, model2)remove()

```py
>>> Membership.objects.create(
...     person=ringo,
...     group=beatles,
...     date_joined=date(1968, 9, 4),
...     invite_reason="You've been gone for a month and we miss you.",
... )
>>> beatles.members.all()
<QuerySet [<Person: Ringo Starr>, <Person: Paul McCartney>, <Person: Ringo Starr>]>
>>> # This deletes both of the intermediate model instances for Ringo Starr
>>> beatles.members.remove(ringo)
>>> beatles.members.all()
<QuerySet [<Person: Paul McCartney>]>
```

Metoda clear()se može koristiti za uklanjanje svih odnosa više prema više za instancu:

```py
>>> # Beatles have broken up
>>> beatles.members.clear()
>>> # Note that this deletes the intermediate model instances
>>> Membership.objects.all()
<QuerySet []>
```

Kada uspostavite odnose više prema više, možete izdavati upite. Baš kao i kod normalnih odnosa više prema više, možete izdavati upite koristeći atribute modela povezanog sa više prema više:

```py
# Find all the groups with a member whose name starts with 'Paul'
>>> Group.objects.filter(members__name__startswith="Paul")
<QuerySet [<Group: The Beatles>]>
```

Pošto koristite srednji model, možete takođe da upitate o njegovim atributima:

```py
# Find all the members of the Beatles that joined after 1 Jan 1961
>>> Person.objects.filter(
...     group__name="The Beatles", membership__date_joined__gt=date(1961, 1, 1)
... )
<QuerySet [<Person: Ringo Starr]>
```

Ako vam je potreban pristup informacijama o članstvu, to možete učiniti direktnim upitom Membershipmodelu:

```py
>>> ringos_membership = Membership.objects.get(group=beatles, person=ringo)
>>> ringos_membership.date_joined
datetime.date(1962, 8, 16)
>>> ringos_membership.invite_reason
'Needed a new drummer.'
```

Drugi način za pristup istim informacijama je upitom o obrnutoj relaciji više prema više iz Personobjekta:

```py
>>> ringos_membership = ringo.membership_set.get(group=beatles)
>>> ringos_membership.date_joined
datetime.date(1962, 8, 16)
>>> ringos_membership.invite_reason
'Needed a new drummer.'
```

#### Relacija jedan prema jedan

Da biste definisali odnos jedan-na-jedan, koristite OneToOneField. Koristite ga baš kao i bilo koji drugi Field tip: uključivanjem kao atributa klase vašeg modela.

Ovo je najkorisnije za primarni ključ objekta kada taj objekat na neki način proširuje drugi objekat.

OneToOneField zahteva pozicioni argument: klasu sa kojom je model povezan.

Na primer, ako biste pravili bazu podataka mesta, napravili biste prilično standardne stvari kao što su adresa, broj telefona itd. Zatim, ako biste želeli da napravite bazu podataka restorana preko mesta, umesto da ponavljate i replicirate ta polja u modelu Restaurant, mogli biste da napravite `Restauranthave` (jer je restoran mesto; u stvari, da biste ovo rešili, obično biste koristili nasleđivanje OneToOneFieldPlace, što uključuje implicitnu relaciju jedan-na-jedan).

Kao i kod ForeignKey, može se definisati rekurzivna relacija i mogu se napraviti reference na još uvek nedefinisane modele.

Vidi takođe:
Pogledajte primer modela odnosa jedan-na-jedan za kompletan primer.

OneToOneField polja takođe prihvataju opcioni parent_link argument.

OneToOneField klase su ranije automatski postajale primarni ključ na modelu. To više nije tačno (iako možete ručno da prosledite primary_key argument ako želite). Stoga je sada moguće imati više polja tipa OneToOneField na jednom modelu.

### Uvoz modela iz druge aplikacije

Sasvim je u redu povezati model sa modelom iz druge aplikacije. Da biste to uradili, uvezite povezani model na vrh datoteke gde je vaš model definisan. Zatim, pozovite se na drugu klasu modela gde god je potrebno. Na primer:

```py
from django.db import models
from geography.models import ZipCode

class Restaurant(models.Model):
    #...
    zip_code = models.ForeignKey(
        ZipCode,
        on_delete=models.SET_NULL,
        blank=True,
        null=True,
    )
```

Alternativno, možete koristiti lenju referencu na povezani model, navedenu kao string u formatu "app_label.ModelName". Ovo ne zahteva uvoz povezanog modela. Na primer:

```py
from django.db import models

class Restaurant(models.Model):
    #...
    zip_code = models.ForeignKey(
        "geography.ZipCode",
        on_delete=models.SET_NULL,
        blank=True,
        null=True,
    )
```

Vidite lenje veze za više detalja.

### Ograničenja imena polja

Django postavlja neka ograničenja na imena polja modela:

- Ime polja ne može biti rezervisana reč u Pajtonu, jer bi to rezultiralo sintaksičkom greškom u Pajtonu. Na primer:

    ```py
    class Example(models.Model):
        pass = models.IntegerField() # 'pass' is a reserved word!
    ```

- Naziv polja ne može da sadrži više od jedne donje crte u redu, zbog načina na koji funkcioniše Django-ova sintaksa pretrage upita. Na primer:

    ```py
    class Example(models.Model):
        foo__bar = models.IntegerField()  # 'foo__bar' has two underscores!
    ```

- Ime polja ne može da se završava donjom crtom, iz sličnih razloga.

- Ime polja ne može biti check, jer bi to poništilo metodu okvira za proveru Model.check().

Ova ograničenja se, međutim, mogu zaobići, jer naziv vašeg polja ne mora nužno da se podudara sa nazivom kolone vaše baze podataka. Pogledajte db_column opciju.

Rezervisane SQL reči, kao što su join, where ili select, su dozvoljene kao imena polja modela, jer Django izbegava sva imena tabela baze podataka i imena kolona u svakom osnovnom SQL upitu. Koristi sintaksu navodnika vašeg određenog mehanizma baze podataka.

### Tipovi prilagođenih polja

Ako jedno od postojećih polja modela ne može da se koristi za vaše potrebe ili ako želite da iskoristite neke manje uobičajene tipove kolona baze podataka, možete da kreirate sopstvenu klasu polja. Potpun pregled kreiranja sopstvenih polja dat je u članku Kako kreirati prilagođena polja modela.

Meta opcije

Dodelite metapodatke svom modelu koristeći unutrašnji element class Meta, kao što je prikazano:

```py
from django.db import models

class Ox(models.Model):
    horn_length = models.IntegerField()

    class Meta:
        ordering = ["horn_length"]
        verbose_name_plural = "oxen"
```

Metapodaci modela su sve što nije polje, kao što su opcije redosleda ( ordering ), naziv tabele baze podataka ( db_table ) ili ljudski čitljiva imena u jednini i množini ( verbose_name i verbose_name_plural ). Nijedan nije obavezan, a dodavanje modelu je potpuno opciono.class Meta

Kompletna lista svih mogućih Metaopcija može se naći u referenci opcija modela.

### Atributi modela

- objects

Najvažniji atribut modela je Manager. To je interfejs preko kojeg se operacije upita baze podataka pružaju Django modelima i koristi se za preuzimanje instanci iz baze podataka. Ako nije Manager definisano prilagođeno ime, podrazumevano ime je objects. Menadžerima se može pristupiti samo preko klasa modela, a ne preko instanci modela.

### Metode modela

Definišite prilagođene metode na modelu da biste dodali prilagođenu funkcionalnost na nivou reda svojim objektima. Dok Manager su metode namenjene da rade stvari na nivou cele tabele, metode modela treba da deluju na određenu instancu modela.

Ovo je vredna tehnika za čuvanje poslovne logike na jednom mestu – modelu.

Na primer, ovaj model ima nekoliko prilagođenih metoda:

```py
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    birth_date = models.DateField()

    def baby_boomer_status(self):
        "Returns the person's baby-boomer status."
        import datetime

        if self.birth_date < datetime.date(1945, 8, 1):
            return "Pre-boomer"
        elif self.birth_date < datetime.date(1965, 1, 1):
            return "Baby boomer"
        else:
            return "Post-boomer"

    @property
    def full_name(self):
        "Returns the person's full name."
        return f"{self.first_name} {self.last_name}"
```

Poslednja metoda u ovom primeru je svojstvo.

Referenca instance modela ima kompletnu listu metoda koje se automatski dodeljuju svakom modelu. Možete da prepišete većinu njih – pogledajte prepisivanje unapred definisanih metoda modela , ispod – ali postoji nekoliko koje ćete skoro uvek želeti da definišete:

**__str__()**
Pajtonova magična metoda koja vraća string reprezentaciju bilo kog objekta. Ovo je ono što će Pajton i Django koristiti kad god je potrebno da se instanca modela prikaže kao običan string. Najznačajnije je da se ovo dešava kada prikazujete objekat u interaktivnoj konzoli ili u administratorskom delu.

Uvek ćete želeti da definišete ovu metodu; podrazumevana vrednost uopšte nije od velike pomoći.

**get_absolute_url()**
Ovo govori Djangu kako da izračuna URL adresu objekta. Django ovo koristi u svom administratorskom interfejsu i svaki put kada treba da pronađe URL adresu objekta.

Svaki objekat koji ima URL adresu koja ga jedinstveno identifikuje trebalo bi da definiše ovu metodu.

Prepisivanje unapred definisanih metoda modela 
Postoji još jedan skup metoda modela koje obuhvataju niz ponašanja baze podataka koje ćete želeti da prilagodite. Konkretno, često ćete želeti da promenite način rada save(), delete().

Slobodni ste da prepišete ove metode (i bilo koju drugu metodu modela) da biste promenili ponašanje.

Klasičan slučaj upotrebe za zamenjivanje ugrađenih metoda je ako želite da se nešto desi svaki put kada sačuvate objekat. Na primer (pogledajte save()dokumentaciju o parametrima koje prihvata):

```py
from django.db import models

class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def save(self, **kwargs):
        do_something()
        super().save(**kwargs)  # Call the "real" save() method.
        do_something_else()
```

Takođe možete sprečiti čuvanje:

```py
from django.db import models

class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def save(self, **kwargs):
        if self.name == "Yoko Ono's blog":
            return  # Yoko shall never have her own blog!
        else:
            super().save(**kwargs)  # Call the "real" save() method.
```

Važno je zapamtiti da pozovete metod superklase – to je to super().save(**kwargs)– kako biste osigurali da se objekat ipak sačuva u bazi podataka. Ako zaboravite da pozovete metod superklase, podrazumevano ponašanje se neće desiti i baza podataka neće biti dirnuta.

Takođe je važno da prosledite argumente koji se mogu proslediti metodi modela – to je ono što taj **kwargsbit radi. Django će, s vremena na vreme, proširiti mogućnosti ugrađenih metoda modela, dodajući nove ključne argumente. Ako koristite **kwargsu definicijama metoda, garantovano vam je da će vaš kod automatski podržavati te argumente kada se dodaju.

Ako želite da ažurirate vrednost polja u save()metodi, možete dodati ovo polje i update_fieldsargumentu ključne reči. Ovo će osigurati da se polje sačuva kada update_fieldsje navedeno. Na primer:

```py
from django.db import models
from django.utils.text import slugify

class Blog(models.Model):
    name = models.CharField(max_length=100)
    slug = models.TextField()

    def save(self, **kwargs):
        self.slug = slugify(self.name)
        if (
            update_fields := kwargs.get("update_fields")
        ) is not None and "name" in update_fields:
            kwargs["update_fields"] = {"slug"}.union(update_fields)
        super().save(**kwargs)
```

Više detalja pogledajte u odeljku Određivanje polja za čuvanje.

Prepisane metode modela se ne pozivaju kod grupnih operacija
Imajte na umu da delete()se metoda za objekat ne poziva nužno prilikom grupnog brisanja objekata pomoću QuerySet- a ili kao rezultat. Da biste osigurali izvršavanje prilagođene logike brisanja, možete koristiti signale i/ili.cascading deletepre_deletepost_delete

Nažalost, ne postoji zaobilazno rešenje kada se creatingili updatingkoriste objekti zajedno, jer se nijedan od save(), pre_savei post_savene poziva.

### Izvršavanje prilagođenog SQL- a

Još jedan uobičajeni obrazac je pisanje prilagođenih SQL naredbi u metodama modela i metodama na nivou modula. Za više detalja o korišćenju sirovog SQL-a, pogledajte dokumentaciju o korišćenju sirovog SQL-a.

### Nasleđivanje modela 

Nasleđivanje modela u Django-u funkcioniše gotovo identično kao i normalno nasleđivanje klasa u Python-u, ali osnove na početku stranice i dalje treba poštovati. To znači da osnovna klasa treba da napravi podklasu django.db.models.Model.

Jedina odluka koju morate da donesete je da li želite da roditeljski modeli budu modeli sami po sebi (sa sopstvenim tabelama baze podataka) ili su roditelji samo nosioci zajedničkih informacija koje će biti vidljive samo kroz podređene modele.

Postoje tri stila nasleđivanja koja su moguća u Django-u.

- Često ćete želeti da koristite roditeljsku klasu samo za čuvanje informacija koje ne želite da morate da kucate za svaki podređeni model. Ova klasa se nikada neće koristiti izolovano, tako da su apstraktne osnovne klase ono što tražite.

- Ako pravite podklasu postojećeg modela (možda nečega iz potpuno druge aplikacije) i želite da svaki model ima svoju tabelu baze podataka, nasleđivanje više tabela je pravi put.

- Konačno, ako želite samo da izmenite ponašanje modela na nivou Pajtona, bez ikakve promene polja modela, možete koristiti proksi modele.

### Apstraktne osnovne klase

Apstraktne osnovne klase su korisne kada želite da stavite neke zajedničke informacije u više drugih modela. Pišete svoju osnovnu klasu i stavljate je abstract=Trueu klasu Meta. Ovaj model se zatim neće koristiti za kreiranje bilo koje tabele baze podataka. Umesto toga, kada se koristi kao osnovna klasa za druge modele, njena polja će biti dodata poljima podređene klase.

Primer:

```py
from django.db import models

class CommonInfo(models.Model):
    name = models.CharField(max_length=100)
    age = models.PositiveIntegerField()

    class Meta:
        abstract = True

class Student(CommonInfo):
    home_group = models.CharField(max_length=5)
```

Model Student će imati tri polja: name, age i home_group. CommonInfo model se ne može koristiti kao normalan Django model, jer je apstraktna bazna klasa. Ne generiše tabelu baze podataka niti ima menadžer, i ne može se direktno instancirati ili sačuvati.

Polja nasleđena od apstraktnih osnovnih klasa mogu se zameniti drugim poljem ili vrednošću ili ukloniti pomoću None.

Za mnoge primene, ova vrsta nasleđivanja modela će biti upravo ono što želite. Ona pruža način za faktorizaciju zajedničkih informacija na nivou Pajtona, dok se i dalje kreira samo jedna tabela baze podataka po podređenom modelu na nivou baze podataka.

### Meta nasleđivanje

Kada se kreira apstraktna osnovna klasa, Django čini bilo koju unutrašnju Meta klasu koju ste deklarisali u osnovnoj klasi dostupnom kao atribut. Ako podređena klasa ne deklariše sopstvenu Meta klasu, naslediće Meta klasu roditelja. Ako podređena klasa želi da proširi Meta klasu roditelja , može je podklasirati. Na primer:

```py
from django.db import models

class CommonInfo(models.Model):
    #...
    class Meta:
        abstract = True
        ordering = ["name"]

class Student(CommonInfo):
    #...
    class Meta(CommonInfo.Meta):
        db_table = "student_info"
```

Django pravi jedno prilagođavanje klasi Meta apstraktne osnovne klase: pre instaliranja atributa Meta , postavlja abstract=False. To znači da deca apstraktnih osnovnih klasa ne postaju automatski i sama apstraktna klasa. Da biste napravili apstraktnu osnovnu klasu koja nasleđuje drugu apstraktnu osnovnu klasu, potrebno je eksplicitno postaviti abstract=Truena dete.

Neke atribute neće imati smisla uključivati u Meta klasu apstraktne osnovne klase. Na primer, uključivanje db_tablebi značilo da bi sve podklase (one koje ne navode sopstveni Meta ) koristile istu tabelu baze podataka, što gotovo sigurno nije ono što želite.

Zbog načina na koji funkcioniše nasleđivanje u Pajtonu, ako podređena klasa nasleđuje od više apstraktnih osnovnih klasa, podrazumevano će biti nasleđene samo Meta opcije iz prve navedene klase. Da biste nasledili Meta opcije od više apstraktnih osnovnih klasa, morate eksplicitno deklarisati Meta nasleđivanje. Na primer:

```py
from django.db import models

class CommonInfo(models.Model):
    name = models.CharField(max_length=100)
    age = models.PositiveIntegerField()

    class Meta:
        abstract = True
        ordering = ["name"]


class Unmanaged(models.Model):
    class Meta:
        abstract = True
        managed = False

class Student(CommonInfo, Unmanaged):
    home_group = models.CharField(max_length=5)

    class Meta(CommonInfo.Meta, Unmanaged.Meta):
        pass
```

Budite oprezni sa related_namei related_query_name

Ako koristite related_name`or` related_query_namena ` ForeignKeyor` ManyToManyField, uvek morate da navedete jedinstveno obrnuto ime i ime upita za polje. Ovo bi obično izazvalo problem u apstraktnim osnovnim klasama, jer su polja u ovoj klasi uključena u svaku od podklasa, sa potpuno istim vrednostima za atribute (uključujući ` related_namei` i `i` related_query_name) svaki put.

Da biste zaobišli ovaj problem, kada koristite related_nameili related_query_nameu apstraktnoj osnovnoj klasi (samo), deo vrednosti treba da sadrži '%(app_label)s'i '%(class)s'.

'%(class)s'se zamenjuje malim slovima napisanim imenom podređene klase u kojoj se polje koristi.

'%(app_label)s'se zamenjuje malim slovima imena aplikacije u kojoj se nalazi podređena klasa. Svako instalirano ime aplikacije mora biti jedinstveno, a imena klasa modela unutar svake aplikacije takođe moraju biti jedinstvena, stoga će rezultujuće ime na kraju biti drugačije.

Na primer, ako je data aplikacija common/models.py:

```py
from django.db import models

class Base(models.Model):
    m2m = models.ManyToManyField(
        OtherModel,
        related_name="%(app_label)s_%(class)s_related",
        related_query_name="%(app_label)s_%(class)ss",
    )

    class Meta:
        abstract = True

class ChildA(Base):
    pass

class ChildB(Base):
    pass

Zajedno sa još jednom aplikacijom rare/models.py:

from common.models import Base

class ChildB(Base):
    pass
```

Obrnuto ime polja common.ChildA.m2mće biti , common_childa_relateda obrnuto ime upita će biti common_childas. Obrnuto ime polja common.ChildB.m2mće biti , common_childb_relateda obrnuto ime upita će biti common_childbs. Konačno, obrnuto ime polja rare.ChildB.m2mće biti , rare_childb_relateda obrnuto ime upita će biti rare_childbs. Na vama je kako ćete koristiti deo ` '%(class)s'and` '%(app_label)s'da biste konstruisali svoje povezano ime ili povezano ime upita, ali ako zaboravite da ga koristite, Django će izbaciti greške kada izvršite sistemske provere (ili pokrenete migrate).

Ako ne navedete related_nameatribut za polje u apstraktnoj osnovnoj klasi, podrazumevano obrnuto ime će biti ime podređene klase praćeno sa '_set', baš kao što bi to normalno bilo kada biste polje deklarisali direktno na podređenoj klasi. Na primer, u gornjem kodu, ako related_nameje atribut izostavljen, obrnuto ime za m2mpolje bi bilo childa_setu ChildAslučaju i childb_setza ChildBpolje.

### Nasleđivanje više tabela

Drugi tip nasleđivanja modela koji podržava Django je kada je svaki model u hijerarhiji model za sebe. Svaki model odgovara sopstvenoj tabeli baze podataka i može se upitivati i kreirati pojedinačno. Relacija nasleđivanja uvodi veze između podređenog modela i svakog od njegovih roditelja (putem automatski kreiranog OneToOneField). Na primer:

```py
from django.db import models

class Place(models.Model):
    name = models.CharField(max_length=50)
    address = models.CharField(max_length=80)


class Restaurant(Place):
    serves_hot_dogs = models.BooleanField(default=False)
    serves_pizza = models.BooleanField(default=False)
```

Sva polja Placeće takođe biti dostupna u Restaurant, iako će se podaci nalaziti u drugoj tabeli baze podataka. Dakle, oba su moguća:

```py
>>> Place.objects.filter(name="Bob's Cafe")
>>> Restaurant.objects.filter(name="Bob's Cafe")
```

Ako imate Placekoji je takođe Restaurant, možete preći sa Placeobjekta na Restaurantobjekat koristeći malu verziju imena modela:

```py
>>> p = Place.objects.get(id=12)
# If p is a Restaurant object, this will give the child class:
>>> p.restaurant
<Restaurant:...>
```

Međutim, ako pu gornjem primeru nije bilo Restaurant(kreiran je direktno kao Placeobjekat ili je bio roditelj neke druge klase), pozivanje na p.restaurantbi izazvalo Restaurant.DoesNotExistizuzetak.

Automatski kreirana OneToOneFieldadresa Restaurantkoja je povezuje Placeizgleda ovako:

```py
place_ptr = models.OneToOneField(
    Place,
    on_delete=models.CASCADE,
    parent_link=True,
    primary_key=True,
)
```

Možete poništiti to polje deklarišući svoje OneToOneFieldsa parent_link=Trueon Restaurant.

### Meta i nasleđivanje više tabela

U situaciji nasleđivanja više tabela, nema smisla da podređena klasa nasleđuje od Meta klase svog roditelja. Sve Meta opcije su već primenjene na roditeljsku klasu i njihova ponovna primena bi normalno dovela samo do kontradiktornog ponašanja (ovo je u suprotnosti sa slučajem apstraktne osnovne klase, gde osnovna klasa ne postoji sama po sebi).

Dakle, dete modela nema pristup Meta klasi svog roditelja. Međutim, postoji nekoliko ograničenih slučajeva gde dete nasleđuje ponašanje od roditelja: ako dete ne navede orderingatribut ili get_latest_byatribut, naslediće ih od svog roditelja.

Ako roditelj ima redosled, a vi ne želite da dete ima bilo kakav prirodni redosled, možete ga eksplicitno onemogućiti:

```py
class ChildModel(ParentModel):
    #...
    class Meta:
        # Remove parent's ordering effect
        ordering = []
```

### Nasleđivanje i obrnute relacije

Pošto nasleđivanje više tabela koristi implicitnu funkciju OneToOneFielDja povezivanje deteta i roditelja, moguće je preći sa roditelja nadole na dete, kao u gornjem primeru. Međutim, ovo koristi ime koje je podrazumevana related_namevrednost za ForeignKeyi ManyToManyFieldrelacije. Ako stavljate te tipove relacija na podklasu roditeljskog modela, morate navesti related_nameatribut za svako takvo polje. Ako zaboravite, Django će izazvati grešku validacije.

Na primer, ponovo koristeći gornju Placeklasu, hajde da kreiramo još jednu podklasu sa ManyToManyField:

```py
class Supplier(Place):
    customers = models.ManyToManyField(Place)
```

To rezultira greškom:

Reverse query name for 'Supplier.customers' clashes with reverse query name for 'Supplier.place_ptr'.

HINT: Add or change a related_name argument to the definition for 'Supplier.customers' or 'Supplier.place_ptr'.

Dodavanje related_nameu customerspolje na sledeći način bi rešilo grešku:.models.ManyToManyField(Place, related_name='provider')

### Određivanje polja roditeljske veze

Kao što je pomenuto, Django će automatski kreirati OneToOneField vezu između vaše podređene klase i bilo kog roditeljskog modela koji nije apstraktan. Ako želite da kontrolišete ime atributa koji se povezuje sa roditeljskim modelom, možete kreirati svoj OneToOneField i podesiti ga parent_link=True tako da označava da je vaše polje veza sa roditeljskom klasom.

### Proksi modeli

Kada se koristi nasleđivanje više tabela , nova tabela baze podataka se kreira za svaku podklasu modela. Ovo je obično željeno ponašanje, jer podklasi je potrebno mesto za čuvanje svih dodatnih polja podataka koja nisu prisutna u osnovnoj klasi. Međutim, ponekad želite samo da promenite ponašanje modela u Pajtonu – možda da promenite podrazumevani menadžer ili dodate novu metodu.

Za ovo služi nasleđivanje proksi modela: kreiranje proksija za originalni model. Možete kreirati, brisati i ažurirati instance proksi modela i svi podaci će biti sačuvani kao da koristite originalni (neproksirani) model. Razlika je u tome što možete promeniti stvari poput podrazumevanog redosleda modela ili podrazumevanog menadžera u proksiju, bez potrebe da menjate original.

Proksi modeli se deklarišu kao i normalni modeli. Djangu govorite da je to proksi model postavljanjem proxyatributa klase Meta na True.

Na primer, pretpostavimo da želite da dodate metod modelu Person. To možete učiniti ovako:

```py
from django.db import models

class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)

class MyPerson(Person):
    class Meta:
        proxy = True

    def do_something(self):
        #...
        pass
```

Klasa MyPerson radi na istoj tabeli baze podataka kao i njena roditeljska Person klasa. Konkretno, sve nove instance od Person će takođe biti dostupne preko MyPerson, i obrnuto:

```py
>>> p = Person.objects.create(first_name="foobar")
>>> MyPerson.objects.get(first_name="foobar")
<MyPerson: foobar>
```

Takođe možete koristiti proksi model da definišete drugačiji podrazumevani redosled na modelu. Možda nećete uvek želeti da sortirate Person model, ali redovno redite po last_name atributu kada koristite proksi:

```py
class OrderedPerson(Person):
    class Meta:
        ordering = ["last_name"]
        proxy = True
```

Sada Person će normalni upiti biti neuređeni, a Ordered Person upiti će biti poređani po last_name.

Proksi modeli nasleđuju Meta atribute na isti način kao i regularni modeli.

### QuerySet i dalje vraća traženi model

Ne postoji način da Django vrati, recimo, MyPersonobjekat kad god upitate za Personobjekte. Skup upita za Personobjekte će vratiti te tipove objekata. Čitava poenta proksi objekata je u tome što Personće kod koji se oslanja na original koristiti te objekte, a vaš sopstveni kod može koristiti ekstenzije koje ste uključili (na koje se nijedan drugi kod ionako ne oslanja). To nije način da zamenite Person(ili bilo koji drugi) model svuda nečim što ste sami kreirali.

### Ograničenja osnovne klase

Proksi model mora da nasleđuje od tačno jedne neapstraktne klase modela. Ne možete nasleđivati od više neapstraktnih modela jer proksi model ne pruža nikakvu vezu između redova u različitim tabelama baze podataka. Proksi model može da nasleđuje od bilo kog broja apstraktnih klasa modela, pod uslovom da one ne definišu nikakva polja modela. Proksi model takođe može da nasleđuje od bilo kog broja proksi modela koji dele zajedničku neapstraktnu roditeljsku klasu.

### Menadžeri proksi modela

Ako ne navedete nijednog menadžera modela na proksi modelu, on nasleđuje menadžere od svojih roditeljskih modela. Ako definišete menadžer na proksi modelu, on će postati podrazumevani, iako će svi menadžeri definisani na roditeljskim klasama i dalje biti dostupni.

Nastavljajući naš primer odozgo, možete promeniti podrazumevani menadžer koji se koristi kada upitujete Person model na ovaj način:

```py
from django.db import models

class NewManager(models.Manager):
    #...
    pass

class MyPerson(Person):
    objects = NewManager()

    class Meta:
        proxy = True
```

Ako želite da dodate novog menadžera proksiju, bez zamene postojećeg podrazumevanog, možete koristiti tehnike opisane u dokumentaciji za prilagođene menadžere : kreirajte osnovnu klasu koja sadrži nove menadžere i nasledite je nakon primarne osnovne klase:

```py
# Create an abstract class for the new manager.
class ExtraManagers(models.Model):
    secondary = NewManager()

    class Meta:
        abstract = True

class MyPerson(Person, ExtraManagers):
    class Meta:
        proxy = True
```

Verovatno vam ovo neće biti potrebno često, ali kada to uradite, moguće je.
Razlike između proksi nasleđivanja i neupravljanih modela 

Nasleđivanje proksi modela može izgledati prilično slično kreiranju neupravljanog modela, korišćenjem managed atributa na klasi modela Meta.

Pažljivim podešavanjem Meta.db_table možete kreirati neupravljani model koji nadgleda postojeći model i dodaje mu Pajton metode. Međutim, to bi bilo veoma ponavljajuće i krhko jer je potrebno da obe kopije budu sinhronizovane ako napravite bilo kakve izmene.

S druge strane, proksi modeli su namenjeni da se ponašaju potpuno isto kao model za koji se zamenjuju. Oni su uvek sinhronizovani sa roditeljskim modelom jer direktno nasleđuju njegova polja i menadžere.

Opšta pravila su:

Ako preslikavate postojeći model ili tabelu baze podataka i ne želite sve originalne kolone tabele baze podataka, koristite Meta.managed=False. Ta opcija je obično korisna za modeliranje prikaza baze podataka i tabela koje nisu pod kontrolom Django-a.

Ako želite da promenite ponašanje modela samo u Pajtonu, ali da zadržite sva ista polja kao u originalu, koristite Meta.proxy=True. Ovo podešava stvari tako da je proksi model tačna kopija strukture skladištenja originalnog modela kada se podaci sačuvaju.

### Višestruko nasleđivanje

Baš kao i kod podklasiranja u Pajtonu, moguće je da Django model nasleđuje od više roditeljskih modela. Imajte na umu da se primenjuju uobičajena pravila za razrešavanje imena u Pajtonu. Prva osnovna klasa u kojoj se određeno ime (npr. Meta ) pojavi biće ona koja se koristi; na primer, to znači da ako više roditelja sadrži Meta klasu, koristiće se samo prva, a svi ostali će biti ignorisani.

Generalno, nećete morati da nasleđujete od više roditelja. Glavni slučaj upotrebe gde je ovo korisno je za mix-in klase: dodavanje određenog dodatnog polja ili metode svakoj klasi koja nasleđuje mix-in. Pokušajte da vaše hijerarhije nasleđivanja budu što jednostavnije i jasnije kako ne biste morali da se mučite da shvatite odakle dolazi određeni deo informacije.

Imajte na umu da će nasleđivanje iz više modela koji imaju zajedničko idpolje primarnog ključa izazvati grešku. Da biste pravilno koristili višestruko nasleđivanje, možete koristiti eksplicitni izraz AutoField u osnovnim modelima:

```py
class Article(models.Model):
    article_id = models.AutoField(primary_key=True)
   ...

class Book(models.Model):
    book_id = models.AutoField(primary_key=True)
   ...

class BookReview(Book, Article):
    pass
```

Ili koristite zajedničkog pretka za čuvanje AutoField. Ovo zahteva korišćenje eksplicitnog OneToOneField od svakog roditeljskog modela do zajedničkog pretka kako bi se izbegao sukob između polja koja se automatski generišu i nasleđuju od strane deteta:

```py
class Piece(models.Model):
    pass

class Article(Piece):
    article_piece = models.OneToOneField(
        Piece, on_delete=models.CASCADE, parent_link=True
    )
   ...

class Book(Piece):
    book_piece = models.OneToOneField(Piece, on_delete=models.CASCADE, parent_link=True)
   ...

class BookReview(Book, Article):
    pass
```

### Naziv polja hidden nije dozvoljen

U normalnom nasleđivanju klasa u Pajtonu, dozvoljeno je da podređena klasa prepiše bilo koji atribut iz roditeljske klase. U Djangu, ovo obično nije dozvoljeno za polja modela. Ako neapstraktna osnovna klasa modela ima polje pod nazivom author, ne možete kreirati drugo polje modela ili definisati atribut pod nazivom authoru bilo kojoj klasi koja nasleđuje iz te osnovne klase.

Ovo ograničenje se ne odnosi na polja modela nasleđena iz apstraktnog modela. Takva polja mogu biti zamenjena drugim poljem ili vrednošću ili uklonjena postavljanjem.field_name = None

Upozorenje
Menadžeri modela se nasleđuju iz apstraktnih osnovnih klasa. Prepisivanje nasleđenog polja na koje se poziva nasleđena klasa Manager može prouzrokovati suptilne greške. Pogledajte prilagođene menadžere i nasleđivanje modela.

Napomena
Neka polja definišu dodatne atribute na modelu, npr. a ForeignKeydefiniše dodatni atribut sa _id dodatkom nazivu polja, kao i related_namei related_query_namena stranom modelu.

Ovi dodatni atributi ne mogu biti zamenjeni osim ako se polje koje ih definiše ne promeni ili ukloni tako da više ne definiše dodatni atribut.

Prepisivanje polja u roditeljskom modelu dovodi do poteškoća u oblastima kao što su inicijalizacija novih instanci (određivanje koje polje se inicijalizuje u Model.__init__) i serijalizacija. To su funkcije sa kojima se normalno nasleđivanje Pajton klasa ne mora nositi na isti način, tako da razlika između nasleđivanja Django modela i nasleđivanja Pajton klasa nije proizvoljna.

Ovo ograničenje se odnosi samo na atribute koji su Field instance. Normalni Pajton atributi mogu se zameniti ako želite. Takođe se odnosi samo na ime atributa kako ga Pajton vidi: ako ručno navodite ime kolone baze podataka, možete imati isto ime kolone koje se pojavljuje i u podređenom i u prethodnom modelu za nasleđivanje više tabela (to su kolone u dve različite tabele baze podataka).

Django će podići FieldError ako prepišete bilo koje polje modela u bilo kom modelu pretka.

Imajte na umu da se zbog načina na koji se polja razrešavaju tokom definisanja klase, polja modela nasleđena od više apstraktnih roditeljskih modela razrešavaju strogo u dubinu. Ovo je suprotno standardnom Python MRO-u, koji se rešava u širinu u slučajevima nasleđivanja u obliku dijamanta. Ova razlika utiče samo na složene hijerarhije modela, koje (kao što je gore navedeno) treba pokušati da izbegnete.

Organizovanje modela u paketu 
Komanda kreira strukturu aplikacije koja uključuje datoteku. Ako imate mnogo modela, njihovo organizovanje u odvojene datoteke može biti korisno.manage.py startappmodels.py

Da biste to uradili, kreirajte modelspaket. Uklonite models.pyi kreirajte myapp/models/ direktorijum sa __init__.py datotekom i datotekama za čuvanje vaših modela. Morate da uvezete modele u __init__.py datoteku.

Na primer, ako ste imali organic.py i synthetic.py u models direktorijumu:

myapp/models/__init__.py

from.organic import Person
from.synthetic import Robot

Eksplicitni uvoz svakog modela umesto korišćenja from.models import * ima prednosti jer ne zatrpava imenski prostor, čini kod čitljivijim i održava alate za analizu koda korisnim. 

Vidi takođe
Referenca za modele
Pokriva sve API-je povezane sa modelom, uključujući polja modela, povezane objekte i QuerySet.

[Sadržaj](#sadržaj)

## Postavljanje upita

Kada kreirate svoje modele podataka , Django vam automatski daje API za apstrakciju baze podataka koji vam omogućava da kreirate, preuzimate, ažurirate i brišete objekte. Ovaj dokument objašnjava kako se koristi ovaj API. Pogledajte referencu za modele podataka za sve detalje o svim različitim opcijama pretrage modela.

Kroz ovaj vodič (i u referenci), pozivaćemo se na sledeće modele, koji čine blog aplikaciju:

from datetime import date

from django.db import models


class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def __str__(self):
        return self.name


class Author(models.Model):
    name = models.CharField(max_length=200)
    email = models.EmailField()

    def __str__(self):
        return self.name


class Entry(models.Model):
    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)
    headline = models.CharField(max_length=255)
    body_text = models.TextField()
    pub_date = models.DateField()
    mod_date = models.DateField(default=date.today)
    authors = models.ManyToManyField(Author)
    number_of_comments = models.IntegerField(default=0)
    number_of_pingbacks = models.IntegerField(default=0)
    rating = models.IntegerField(default=5)

    def __str__(self):
        return self.headline

Kreiranje objekata

Da bi predstavio podatke tabele baze podataka u Pajton objektima, DŽango koristi intuitivan sistem: klasa modela predstavlja tabelu baze podataka, a instanca te klase predstavlja određeni zapis u tabeli baze podataka.

Da biste kreirali objekat, instancirajte ga koristeći ključne reči kao argumente u klasi modela, a zatim pozovite funkciju save()da biste ga sačuvali u bazi podataka.

Pod pretpostavkom da se modeli nalaze u models.pydatoteci unutar blogDjango aplikacije, evo primera:

>>> from blog.models import Blog
>>> b = Blog(name="Beatles Blog", tagline="All the latest Beatles news.")
>>> b.save()

Ovo izvršava INSERTSQL izraz iza kulisa. Django ne dolazi u bazu podataka dok eksplicitno ne pozovete save().

Metoda save()nema povratnu vrednost.

Vidi takođe

save()koristi niz naprednih opcija koje nisu ovde opisane. Pogledajte dokumentaciju za save()kompletne detalje.

Da biste kreirali i sačuvali objekat u jednom koraku, koristite create()metodu.
Čuvanje promena na objektima

Da biste sačuvali izmene objekta koji se već nalazi u bazi podataka, koristite save().

S obzirom na Bloginstancu b5koja je već sačuvana u bazi podataka, ovaj primer menja njeno ime i ažurira njen zapis u bazi podataka:

>>> b5.name = "New name"
>>> b5.save()

Ovo izvršava UPDATESQL izraz iza kulisa. Django ne dolazi u bazu podataka dok eksplicitno ne pozovete save().
Čuvanje ForeignKeyi ManyToManyFieldpolja

Ažuriranje ForeignKeypolja funkcioniše potpuno na isti način kao i čuvanje normalnog polja – dodelite objekat odgovarajućeg tipa dotičnom polju. Ovaj primer ažurira blogatribut instance Entry, entrypretpostavljajući da su odgovarajuće instance Entryi Blogveć sačuvane u bazi podataka (tako da ih možemo preuzeti u nastavku):

>>> from blog.models import Blog, Entry
>>> entry = Entry.objects.get(pk=1)
>>> cheese_blog = Blog.objects.get(name="Cheddar Talk")
>>> entry.blog = cheese_blog
>>> entry.save()

Ažuriranje ManyToManyFieldfunkcioniše malo drugačije – koristite add()metodu na polju da biste dodali zapis u relaciju. Ovaj primer dodaje Authorinstancu joeobjektu entry:

>>> from blog.models import Author
>>> joe = Author.objects.create(name="Joe")
>>> entry.authors.add(joe)

Da biste dodali više zapisa u ManyToManyFieldodjednom, uključite više argumenata u pozivu funkcije add(), kao što je ovo:

>>> john = Author.objects.create(name="John")
>>> paul = Author.objects.create(name="Paul")
>>> george = Author.objects.create(name="George")
>>> ringo = Author.objects.create(name="Ringo")
>>> entry.authors.add(john, paul, george, ringo)

Django će se žaliti ako pokušate da dodelite ili dodate objekat pogrešnog tipa.
Preuzimanje objekata

Da biste preuzeli objekte iz vaše baze podataka, konstruišite QuerySetvia a Managerna vašoj klasi modela.

A QuerySetpredstavlja kolekciju objekata iz vaše baze podataka. Može imati nula, jedan ili više filtera . Filteri sužavaju rezultate upita na osnovu datih parametara. U SQL terminologiji, a je QuerySetjednako iskazu SELECT, a filter je ograničavajuća klauza kao što je WHERE`or` LIMIT.

Dobijate QuerySetkoristeći `` vašeg modela`` Manager. Svaki model ima barem jedan `` Manager,`` i on se poziva objectspodrazumevano. Pristupite mu direktno preko klase modela, ovako:

>>> Blog.objects
<django.db.models.manager.Manager object at ...>
>>> b = Blog(name="Foo", tagline="Bar")
>>> b.objects
Traceback:
    ...
AttributeError: "Manager isn't accessible via Blog instances."

Napomena

A Managerje dostupan samo preko klasa modela, a ne iz instanci modela, kako bi se sprovelo razdvajanje između operacija „na nivou tabele“ i operacija „na nivou zapisa“.

je Managerglavni izvor skupova upita za model. Na primer, Blog.objects.all()vraća QuerySetkoji sadrži sve Blogobjekte u bazi podataka.
Preuzimanje svih objekata

Najjednostavniji način za preuzimanje objekata iz tabele jeste da ih preuzmete sve. Da biste to uradili, koristite all()metodu na Manager:

>>> all_entries = Entry.objects.all()

Metoda all()vraća broj QuerySetsvih objekata u bazi podataka.
Preuzimanje određenih objekata pomoću filtera

Vraćena QuerySetvrednost all()opisuje sve objekte u tabeli baze podataka. Međutim, obično ćete morati da izaberete samo podskup kompletnog skupa objekata.

Da biste kreirali takav podskup, precizirate početni QuerySet, dodajući uslove filtera. Dva najčešća načina za preciziranje QuerySetsu:

filter(**kwargs)

    Vraća novi QuerySetkoji sadrži objekte koji odgovaraju datim parametrima pretrage.
exclude(**kwargs)

    Vraća novu vrednost QuerySetkoja sadrži objekte koji se ne podudaraju sa datim parametrima pretrage.

Parametri pretrage ( **kwargsu gore navedenim definicijama funkcija) treba da budu u formatu opisanom u odeljku Pretrage polja ispod.

Na primer, da biste dobili QuerySetblog zapise iz 2006. godine, koristite filter()ovako:

Entry.objects.filter(pub_date__year=2006)

Sa podrazumevanom klasom menadžera, to je isto kao:

Entry.objects.all().filter(pub_date__year=2006)

Ulančavanje filtera

Rezultat prečišćavanja a QuerySetje sam po sebi a QuerySet, tako da je moguće povezati prečišćavanja zajedno. Na primer:

>>> Entry.objects.filter(headline__startswith="What").exclude(
...     pub_date__gte=datetime.date.today()
... ).filter(pub_date__gte=datetime.date(2005, 1, 30))

Ovo uzima početno slovo QuerySetsvih unosa u bazi podataka, dodaje filter, zatim isključenje, pa još jedan filter. Konačni rezultat je baza podataka koja QuerySetsadrži sve unose sa naslovom koji počinje sa „Šta“, a koji su objavljeni između 30. januara 2005. i današnjeg dana.
Filtrirani QuerySets su jedinstveni

Svaki put kada precizirate QuerySet, dobijate potpuno novi QuerySetkoji nije ni na koji način vezan za prethodni QuerySet. Svako preciziranje stvara zasebnu i jedinstvenu stavku QuerySetkoja se može čuvati, koristiti i ponovo koristiti.

Primer:

>>> q1 = Entry.objects.filter(headline__startswith="What")
>>> q2 = q1.exclude(pub_date__gte=datetime.date.today())
>>> q3 = q1.filter(pub_date__gte=datetime.date.today())

Ova tri skupa upita su odvojena. Prvi je baza QuerySetkoja sadrži sve unose koji sadrže naslov koji počinje sa „Šta“. Drugi je podskup prvog, sa dodatnim kriterijumom koji isključuje zapise čiji pub_dateje danas ili u budućnosti. Treći je podskup prvog, sa dodatnim kriterijumom koji bira samo zapise čiji pub_dateje danas ili u budućnosti. Početni QuerySet( q1) nije pod uticajem procesa preciziranja.
QuerySetsu lenji

QuerySetobjekti su lenji – čin kreiranja QuerySetne uključuje nikakvu aktivnost baze podataka. Možete slagati filtere zajedno ceo dan, a Django zapravo neće pokrenuti upit dok QuerySetse ne izračuna . Pogledajte ovaj primer:

>>> q = Entry.objects.filter(headline__startswith="What")
>>> q = q.filter(pub_date__lte=datetime.date.today())
>>> q = q.exclude(body_text__icontains="food")
>>> print(q)

Iako ovo izgleda kao tri pogotka u bazi podataka, u stvari pogađa bazu podataka samo jednom, u poslednjem redu ( print(q)). Generalno, rezultati QuerySetse ne preuzimaju iz baze podataka dok ih ne „zatražite“. Kada to uradite, QuerySetse procenjuje pristupom bazi podataka. Za više detalja o tome kada se tačno procena vrši, pogledajte Kada se procenjuju skupovi upita .
Preuzimanje jednog objekta pomoću get()¶

filter()uvek će vam dati QuerySet, čak i ako samo jedan objekat odgovara upitu - u ovom slučaju, to će biti koji QuerySetsadrži jedan element.

Ako znate da postoji samo jedan objekat koji odgovara vašem upitu, možete koristiti get()metodu na Managerkoja direktno vraća objekat:

>>> one_entry = Entry.objects.get(pk=1)

Možete koristiti bilo koji izraz upita sa get(), baš kao i sa filter()-, pogledajte Pretrage polja ispod.

Imajte na umu da postoji razlika između korišćenja get()i korišćenja filter()sa delom [0]. Ako nema rezultata koji odgovaraju upitu, get()će izazvati DoesNotExistizuzetak. Ovaj izuzetak je atribut klase modela na kojoj se upit izvršava - pa u gornjem kodu, ako ne postoji Entryobjekat sa primarnim ključem 1, DŽango će izazvati Entry.DoesNotExist.

Slično tome, Django će se žaliti ako se više od jedne stavke podudara sa get()upitom. U ovom slučaju, podići će MultipleObjectsReturned, što je opet atribut same klase modela.
Druge QuerySetmetode

Većinu vremena ćete koristiti all(), get(), filter()i exclude()kada vam je potrebno da pretražite objekte iz baze podataka. Međutim, to nije sve što postoji; pogledajte QuerySet API referencu za kompletnu listu svih različitih QuerySetmetoda.
Ograničavanje QuerySets

Koristite podskup Pajtonove sintakse za sečenje nizova da biste ograničili QuerySetna određeni broj rezultata. Ovo je ekvivalent SQL-ovima LIMITi OFFSETklauzama.

Na primer, ovo vraća prvih 5 objekata ( ):LIMIT 5

>>> Entry.objects.all()[:5]

Ovo vraća objekte od šestog do desetog ( ):OFFSET 5 LIMIT 5

>>> Entry.objects.all()[5:10]

Negativno indeksiranje (tj. Entry.objects.all()[-1]) nije podržano.

Generalno, sečenje QuerySetvraća new QuerySet– ne procenjuje upit. Izuzetak je ako koristite parametar „step“ sintakse sečenja u Pajtonu. Na primer, ovo bi zapravo izvršilo upit kako bi vratilo listu svakog drugog objekta od prvih 10:

>>> Entry.objects.all()[:10:2]

Dalje filtriranje ili uređivanje isečenog skupa upita je zabranjeno zbog dvosmislene prirode načina na koji bi to moglo da funkcioniše.

Da biste preuzeli jedan objekat umesto liste (npr. ), koristite indeks umesto segmenta. Na primer, ovo vraća prvi objekat u bazi podataka, nakon što se unosi poređaju po abecednom redu po naslovu:SELECT foo FROM bar LIMIT 1Entry

>>> Entry.objects.order_by("headline")[0]

Ovo je otprilike ekvivalentno:

>>> Entry.objects.order_by("headline")[0:1].get()

Međutim, imajte na umu da će se prvi od njih podići, IndexErrordok će se drugi podići DoesNotExistako nijedan objekat ne ispunjava date kriterijume. Vidite get()za više detalja.
Pretrage polja

Pretrage polja su način na koji određujete suštinu SQL WHEREklauzule. Ona se navode kao ključni argumenti za QuerySetmetode filter()`` exclude()i get()``.

Argumenti ključnih reči za osnovne pretrage imaju oblik field__lookuptype=value. (To je dvostruka donja crta). Na primer:

>>> Entry.objects.filter(pub_date__lte="2006-01-01")

prevodi (otprilike) u sledeći SQL:

SELECT * FROM blog_entry WHERE pub_date <= '2006-01-01';

Kako je ovo moguće

Pajton ima mogućnost definisanja funkcija koje prihvataju proizvoljne argumente imena-vrednosti čija se imena i vrednosti procenjuju tokom izvršavanja. Za više informacija pogledajte odeljak „Ključne reči argumenti“ u zvaničnom Pajton tutorijalu.

Polje navedeno u pretrazi mora biti naziv polja modela. Međutim, postoji jedan izuzetak, u slučaju ForeignKeymožete navesti naziv polja sa sufiksom _id. U ovom slučaju, očekuje se da parametar vrednosti sadrži sirovu vrednost primarnog ključa stranog modela. Na primer:

>>> Entry.objects.filter(blog_id=4)

Ako prosledite nevažeći argument ključne reči, funkcija pretraživanja će podići TypeError.

API baze podataka podržava oko dvadesetak tipova pretraga; kompletnu referencu možete pronaći u referenci za pretragu polja . Da biste stekli uvid u ono što je dostupno, evo nekih od najčešćih pretraga koje ćete verovatno koristiti:

exact

    „Potpuno“ podudaranje. Na primer:

    >>> Entry.objects.get(headline__exact="Cat bites dog")

    Generisao bi SQL na sledeći način:

    SELECT ... WHERE headline = 'Cat bites dog';

    Ako ne navedete tip pretrage – to jest, ako vaš argument ključne reči ne sadrži dvostruku donju crtu – pretpostavlja se da je tip pretrage exact.

    Na primer, sledeće dve izjave su ekvivalentne:

    >>> Blog.objects.get(id__exact=14)  # Explicit form
    >>> Blog.objects.get(id=14)  # __exact is implied

    Ovo je zbog praktičnosti, jer exactsu pretrage uobičajeni slučaj.
iexact

    Podudaranje koje ne razlikuje velika i mala slova. Dakle, upit:

    >>> Blog.objects.get(name__iexact="beatles blog")

    Podudaralo bi se sa Blognaslovom , , ili čak ."Beatles Blog""beatles blog""BeAtlES blOG"
contains

    Test ograničenja koji razlikuje velika i mala slova. Na primer:

    Entry.objects.get(headline__contains="Lennon")

    Otprilike se prevodi u ovaj SQL:

    SELECT ... WHERE headline LIKE '%Lennon%';

    Imajte na umu da će se ovo podudarati sa naslovom, ali ne i sa .'Today Lennon honored''today lennon honored'

    Postoji i verzija koja ne razlikuje velika i mala slova, icontains.
startswith,endswith

    Počinje sa i završava se sa pretraga, respektivno. Postoje i verzije koje ne razlikuju velika i mala slova, a koje se zovu istartswithi iendswith.

Opet, ovo je samo površno zagrebanje. Kompletna referenca se može naći u referenci za pretragu polja .
Pretrage koje obuhvataju odnose

Django nudi moćan i intuitivan način za „praćenje“ odnosa u pretragama, JOINautomatski vodeći računa o SQL zahtevima umesto vas, iza kulisa. Da biste obuhvatili odnos, koristite naziv polja povezanih polja u različitim modelima, odvojen dvostrukim donjim crtama, dok ne dođete do željenog polja.

Ovaj primer preuzima sve Entryobjekte sa Blogčijim nameje :'Beatles Blog'

>>> Entry.objects.filter(blog__name="Beatles Blog")

Ovaj raspon može biti dubok koliko želite.

Radi i obrnuto. Iako je , podrazumevano se pozivate na „obrnuti“ odnos u pretrazi koristeći mali naziv modela.can be customized

Ovaj primer preuzima sve Blogobjekte koji imaju barem jedan Entryčiji headlinesadrži 'Lennon':

>>> Blog.objects.filter(entry__headline__contains="Lennon")

Ako filtrirate preko više relacija i jedan od srednjih modela nema vrednost koja ispunjava uslov filtera, Django će ga tretirati kao da postoji prazan (sve vrednosti su NULL), ali validan objekat. Sve ovo znači da se neće pojaviti greška. Na primer, u ovom filteru:

Blog.objects.filter(entry__authors__name="Lennon")

(ako je postojao povezani Authormodel), ako nije bilo authorpovezano sa unosom, tretiralo bi se kao da takođe nije bilo namepridruženog, umesto da se izda greška zbog nedostajućeg author. Obično je to upravo ono što želite da se desi. Jedini slučaj gde bi to moglo biti zbunjujuće je ako koristite isnull. Dakle:

Blog.objects.filter(entry__authors__name__isnull=True)

vratiće Blogobjekte koji imaju prazan ` namena` author, a takođe i one koji imaju prazan ` authorna` entry. Ako ne želite ove druge objekte, možete napisati:

Blog.objects.filter(entry__authors__isnull=False, entry__authors__name__isnull=True)

Obuhvatanje višeznačnih odnosa

Kada se obuhvata a ManyToManyFieldili obrnuto ForeignKey(kao što je od Blogdo Entry), filtriranje po više atributa postavlja pitanje da li je potrebno da se svaki atribut podudara u istom povezanom objektu. Možemo tražiti blogove koji imaju unos iz 2008. sa „Lenon“ u naslovu, ili možemo tražiti blogove koji imaju samo bilo koji unos iz 2008. kao i neki noviji ili stariji unos sa „Lenon“ u naslovu.

Da bismo izabrali sve blogove koji sadrže barem jedan unos iz 2008. godine koji ima „Lenon“ u naslovu (isti unos koji zadovoljava oba uslova), napisali bismo:

Blog.objects.filter(entry__headline__contains="Lennon", entry__pub_date__year=2008)

U suprotnom, da bismo izvršili popustljiviji upit koji bira bilo koje blogove sa samo nekim unosom sa „Lenon“ u naslovu i nekim unosom iz 2008. godine, napisali bismo:

Blog.objects.filter(entry__headline__contains="Lennon").filter(
    entry__pub_date__year=2008
)

Pretpostavimo da postoji samo jedan blog koji ima i unose koji sadrže „Lenon“ i unose iz 2008. godine, ali da nijedan od unosa iz 2008. ne sadrži „Lenon“ . Prvi upit ne bi vratio nijedan blog, ali bi drugi upit vratio taj jedan blog. (To je zato što unosi koje je izabrao drugi filter mogu, ali i ne moraju biti isti kao unosi u prvom filteru. Filtriramo Blogstavke sa svakom izjavom filtera, a ne same Entrystavke.) Ukratko, ako svaki uslov treba da se podudara sa istim povezanim objektom, onda bi svaki trebalo da bude sadržan u jednom filter()pozivu.

Napomena

Kako drugi (dozvoljeniji) upit povezuje više filtera, on vrši višestruka spajanja sa primarnim modelom, što potencijalno rezultira duplikatima.

>>> from datetime import date
>>> beatles = Blog.objects.create(name="Beatles Blog")
>>> pop = Blog.objects.create(name="Pop Music Blog")
>>> Entry.objects.create(
...     blog=beatles,
...     headline="New Lennon Biography",
...     pub_date=date(2008, 6, 1),
... )
<Entry: New Lennon Biography>
>>> Entry.objects.create(
...     blog=beatles,
...     headline="New Lennon Biography in Paperback",
...     pub_date=date(2009, 6, 1),
... )
<Entry: New Lennon Biography in Paperback>
>>> Entry.objects.create(
...     blog=pop,
...     headline="Best Albums of 2008",
...     pub_date=date(2008, 12, 15),
... )
<Entry: Best Albums of 2008>
>>> Entry.objects.create(
...     blog=pop,
...     headline="Lennon Would Have Loved Hip Hop",
...     pub_date=date(2020, 4, 1),
... )
<Entry: Lennon Would Have Loved Hip Hop>
>>> Blog.objects.filter(
...     entry__headline__contains="Lennon",
...     entry__pub_date__year=2008,
... )
<QuerySet [<Blog: Beatles Blog>]>
>>> Blog.objects.filter(
...     entry__headline__contains="Lennon",
... ).filter(
...     entry__pub_date__year=2008,
... )
<QuerySet [<Blog: Beatles Blog>, <Blog: Beatles Blog>, <Blog: Pop Music Blog]>

Napomena

Ponašanje filter()`for` upita koji obuhvataju viševrednosne odnose, kao što je gore opisano, nije ekvivalentno implementirano `for` exclude(). Umesto toga, uslovi u jednom exclude()pozivu neće nužno referisati na istu stavku.

Na primer, sledeći upit bi isključio blogove koji sadrže i unose sa „Lenon“ u naslovu i unose objavljene 2008. godine:

Blog.objects.exclude(
    entry__headline__contains="Lennon",
    entry__pub_date__year=2008,
)

Međutim, za razliku od ponašanja pri korišćenju filter(), ovo neće ograničiti blogove na osnovu unosa koji zadovoljavaju oba uslova. Da biste to uradili, tj. da biste izabrali sve blogove koji ne sadrže unose objavljene sa „Lenon“ koji su objavljeni 2008. godine, potrebno je da napravite dva upita:

Blog.objects.exclude(
    entry__in=Entry.objects.filter(
        headline__contains="Lennon",
        pub_date__year=2008,
    ),
)

Filteri mogu da se pozivaju na polja na modelu

U dosadašnjim primerima, konstruisali smo filtere koji upoređuju vrednost polja modela sa konstantom. Ali šta ako želite da uporedite vrednost polja modela sa drugim poljem na istom modelu?

Django omogućava takva poređenja. Instance deluju kao referenca na polje modela unutar upita. Ove reference se zatim mogu koristiti u filterima upita za poređenje vrednosti dva različita polja na istoj instanci modela.F expressionsF()

Na primer, da bismo pronašli listu svih blogova koji su imali više komentara nego pingbekova, konstruišemo F()objekat koji referencira broj pingbekova i koristimo taj F()objekat u upitu:

>>> from django.db.models import F
>>> Entry.objects.filter(number_of_comments__gt=F("number_of_pingbacks"))

DŽango podržava upotrebu sabiranja, oduzimanja, množenja, deljenja, modula i stepenovanja sa F()objektima, kako sa konstantama, tako i sa drugim F()objektima. Da bismo pronašli sve unose na blogu sa više nego dvostruko više komentara nego pingbekova, modifikujemo upit:

>>> Entry.objects.filter(number_of_comments__gt=F("number_of_pingbacks") * 2)

Da bismo pronašli sve unose gde je ocena unosa manja od zbira broja pingbekova i broja komentara, izdali bismo upit:

>>> Entry.objects.filter(rating__lt=F("number_of_comments") + F("number_of_pingbacks"))

Takođe možete koristiti notaciju sa dvostrukom podvlakom da biste obuhvatili odnose u F()objektu. F()Objekat sa dvostrukom podvlakom će uvesti sva spajanja potrebna za pristup povezanom objektu. Na primer, da bismo preuzeli sve unose gde je ime autora isto kao i ime bloga, mogli bismo da izdamo upit:

>>> Entry.objects.filter(authors__name=F("blog__name"))

Za polja za datum i datum/vreme možete dodati ili oduzeti timedeltaobjekat. Sledeće bi vratilo sve unose koji su izmenjeni više od 3 dana nakon što su objavljeni:

>>> from datetime import timedelta
>>> Entry.objects.filter(mod_date__gt=F("pub_date") + timedelta(days=3))

Objekti F()podržavaju bitne operacije pomoću .bitand(), .bitor(), .bitxor(), .bitrightshift(), i .bitleftshift(). Na primer:

>>> F("somefield").bitand(16)

Proročište

Oracle ne podržava bitnu XOR operaciju.
Izrazi mogu da referenciraju transformacije

Django podržava korišćenje transformacija u izrazima.

Na primer, da biste pronašli sve Entryobjekte objavljene iste godine kada su poslednji put izmenjeni:

>>> from django.db.models import F
>>> Entry.objects.filter(pub_date__year=F("mod_date__year"))

Da bismo pronašli najraniju godinu objavljivanja unosa, možemo pokrenuti upit:

>>> from django.db.models import Min
>>> Entry.objects.aggregate(first_published_year=Min("pub_date__year"))

Ovaj primer pronalazi vrednost najbolje ocenjenog unosa i ukupan broj komentara na sve unose za svaku godinu:

>>> from django.db.models import OuterRef, Subquery, Sum
>>> Entry.objects.values("pub_date__year").annotate(
...     top_rating=Subquery(
...         Entry.objects.filter(
...             pub_date__year=OuterRef("pub_date__year"),
...         )
...         .order_by("-rating")
...         .values("rating")[:1]
...     ),
...     total_comments=Sum("number_of_comments"),
... )

Prečica pkza pretragu

Radi lakšeg snalaženja, Django pruža pkprečicu za pretragu, što je skraćenica od „primarni ključ“.

U datom Blogmodelu, primarni ključ je idpolje, tako da su ove tri izjave ekvivalentne:

>>> Blog.objects.get(id__exact=14)  # Explicit form
>>> Blog.objects.get(id=14)  # __exact is implied
>>> Blog.objects.get(pk=14)  # pk implies id__exact

Upotreba pknije ograničena samo na __exactupite – bilo koji termin upita može se kombinovati sa pkda bi se izvršio upit nad primarnim ključem modela:

# Get blogs entries with id 1, 4 and 7
>>> Blog.objects.filter(pk__in=[1, 4, 7])

# Get all blog entries with id > 14
>>> Blog.objects.filter(pk__gt=14)

pkPretrage takođe rade preko spajanja. Na primer, ove tri izjave su ekvivalentne:

>>> Entry.objects.filter(blog__id__exact=3)  # Explicit form
>>> Entry.objects.filter(blog__id=3)  # __exact is implied
>>> Entry.objects.filter(blog__pk=3)  # __pk implies __id__exact

Izbegavanje znakova procenta i donjih crtica u LIKEiskazima

Pretrage polja koje su ekvivalentne LIKESQL naredbama ( iexact, contains, icontains, startswith, istartswith, endswithi iendswith) će automatski izbeći dva specijalna znaka koja se koriste u LIKEnaredbama – znak procenta i donju crtu. (U LIKEnaredbi, znak procenta označava višeznačni džoker, a donja crtica označava jednoznačni džoker.)

To znači da stvari treba da funkcionišu intuitivno, tako da apstrakcija ne curi. Na primer, da biste preuzeli sve unose koji sadrže znak procenta, koristite znak procenta kao bilo koji drugi znak:

>>> Entry.objects.filter(headline__contains="%")

Django se brine o citiranju umesto vas; rezultujući SQL će izgledati otprilike ovako:

SELECT ... WHERE headline LIKE '%\%%';

Isto važi i za donje crte. I znakovi procenta i donje crte se obrađuju transparentno.
Keširanje i QuerySets

Svaki QuerySetsadrži keš memoriju kako bi se minimizirao pristup bazi podataka. Razumevanje kako funkcioniše omogućiće vam da napišete najefikasniji kod.

In a newly created QuerySet, the cache is empty. The first time a QuerySet is evaluated – and, hence, a database query happens – Django saves the query results in the QuerySet’s cache and returns the results that have been explicitly requested (e.g., the next element, if the QuerySet is being iterated over). Subsequent evaluations of the QuerySet reuse the cached results.

Keep this caching behavior in mind, because it may bite you if you don’t use your QuerySets correctly. For example, the following will create two QuerySets, evaluate them, and throw them away:

>>> print([e.headline for e in Entry.objects.all()])
>>> print([e.pub_date for e in Entry.objects.all()])

That means the same database query will be executed twice, effectively doubling your database load. Also, there’s a possibility the two lists may not include the same database records, because an Entry may have been added or deleted in the split second between the two requests.

To avoid this problem, save the QuerySet and reuse it:

>>> queryset = Entry.objects.all()
>>> print([p.headline for p in queryset])  # Evaluate the query set.
>>> print([p.pub_date for p in queryset])  # Reuse the cache from the evaluation.

When QuerySets are not cached¶

Querysets do not always cache their results. When evaluating only део of the queryset, the cache is checked, but if it is not populated then the items returned by the subsequent query are not cached. Specifically, this means that који ограничава скуп упита using an array slice or an index will not populate the cache.

На пример, вишеструко добијање одређеног индекса у објекту queryset ће сваки пут упитивати базу података:

>>> queryset = Entry.objects.all()
>>> print(queryset[5])  # Queries the database
>>> print(queryset[5])  # Queries the database again

Међутим, ако је цео скуп упита већ процењен, уместо тога ће се проверити кеш:

>>> queryset = Entry.objects.all()
>>> [entry for entry in queryset]  # Queries the database
>>> print(queryset[5])  # Uses cache
>>> print(queryset[5])  # Uses cache

Ево неколико примера других радњи које ће резултирати евалуацијом целог скупа упита и самим тим попуњавањем кеша:

>>> [entry for entry in queryset]
>>> bool(queryset)
>>> entry in queryset
>>> list(queryset)

Напомена

Simply printing the queryset will not populate the cache. This is because the call to __repr__() only returns a slice of the entire queryset.
Asynchronous queries¶

If you are writing asynchronous views or code, you cannot use the ORM for queries in quite the way we have described above, as you cannot call блокирање synchronous code from asynchronous code - it will block up the event loop (or, more likely, Django will notice and raise a SynchronousOnlyOperation to stop that from happening).

Fortunately, you can do many queries using Django’s asynchronous query APIs. Every method that might block - such as get() or delete() - has an asynchronous variant (aget() or adelete()), and when you iterate over results, you can use asynchronous iteration (async for) instead.
Query iteration¶

The default way of iterating over a query - with for - will result in a blocking database query behind the scenes as Django loads the results at iteration time. To fix this, you can swap to async for:

async for entry in Authors.objects.filter(name__startswith="A"):
    ...

Imajte na umu da takođe ne možete da radite druge stvari koje bi mogle da iteriraju kroz skup upita, kao što je obmotavanje list()oko njega da biste nametnuli njegovu evaluaciju (možete koristiti u razumevanju, ako želite).async for

Pošto QuerySetmetode poput filter()i exclude()zapravo ne pokreću upit - one podešavaju skup upita da se pokreće kada se iterira - možete ih slobodno koristiti u asinhronom kodu. Za vodič o tome koje metode se mogu nastaviti koristiti na ovaj način i koje imaju asinhrone verzije, pročitajte sledeći odeljak.
QuerySeti metode menadžera

Neke metode na menadžerima i skupovima upita - poput get()i first()- primoravaju na izvršavanje skupa upita i blokiraju. Neke, poput filter()i exclude(), ne primoravaju na izvršavanje i stoga ih je bezbedno pokretati iz asinhronog koda. Ali kako se očekuje da uočite razliku?

Iako biste mogli da malo progledate i vidite da li postoji averzija metode sa prefiksom - (na primer, imamo aget(), ali ne afilter()), postoji logičniji način - pogledajte o kakvoj je vrsti metode reč u referenci QuerySet .

Tamo ćete pronaći metode na QuerySets grupisane u dva odeljka:

    Metode koje vraćaju nove skupove upita : Ovo su metode koje ne blokiraju i nemaju asinhrone verzije. Možete ih koristiti u bilo kojoj situaciji, mada pročitajte napomene o njima defer()pre only()nego što ih upotrebite.

    Metode koje ne vraćaju skupove upita : Ovo su blokirajuće metode i imaju asinhrone verzije - asinhroni naziv za svaku od njih je naveden u njihovoj dokumentaciji, mada je naš standardni obrazac dodavanje aprefiksa.

Koristeći ovu razliku, možete utvrditi kada treba da koristite asinhrone verzije, a kada ne. Na primer, evo validnog asinhronog upita:

user = await User.objects.filter(username=my_input).afirst()

filter()vraća skup upita, pa je u redu da ga stalno povezujemo unutar asinhronog okruženja, dok first()izvršava i vraća instancu modela - stoga, menjamo u afirst()i koristimo awaitna početku celog izraza kako bismo ga pozvali na asinhroni način.

Napomena

Ako zaboravite da ubacite awaitdeo, možete videti greške poput „objekat korutine nema atribut x“ ili stringova „<korutina …>“ umesto instanci vašeg modela. Ako ikada vidite ove greške, propuštate awaitmesto gde biste tu korutinu pretvorili u stvarnu vrednost.
Transakcije

Transakcije trenutno nisu podržane kod asinhronih upita i ažuriranja. Videćete da pokušaj korišćenja jednog podiže SynchronousOnlyOperation.

Ako želite da koristite transakciju, predlažemo da napišete svoj ORM kod unutar zasebne, sinhrone funkcije, a zatim je pozovete koristeći sync_to_async- pogledajte Podrška za asinhrone funkcije za više informacija.
Upit JSONField¶

Implementacija pretraga je drugačija u JSONField, uglavnom zbog postojanja ključnih transformacija. Da bismo to demonstrirali, koristićemo sledeći primer modela:

from django.db import models


class Dog(models.Model):
    name = models.CharField(max_length=200)
    data = models.JSONField(null=True)

    def __str__(self):
        return self.name

Čuvanje i upiti za None¶

Kao i kod drugih polja, čuvanje Nonekao vrednosti polja će ga čuvati kao SQL NULL. Iako se ne preporučuje, moguće je čuvati JSON skalar nullumesto SQL- NULLa korišćenjem .Value(None, JSONField())

Koja god vrednost da se sačuva, kada se preuzme iz baze podataka, Pajton reprezentacija JSON skalara nullje ista kao SQL NULL, tj None. . Stoga, može biti teško razlikovati ih.

Ovo se odnosi samo na Nonevrednost polja najvišeg nivoa. Ako Noneje unutar traka listili dict, uvek će se interpretirati kao JSON null.

Prilikom upita, Nonevrednost će uvek biti interpretirana kao JSON null. Da biste izvršili upit za SQL NULL, koristite isnull:

>>> Dog.objects.create(name="Max", data=None)  # SQL NULL.
<Dog: Max>
>>> Dog.objects.create(name="Archie", data=Value(None, JSONField()))  # JSON null.
<Dog: Archie>
>>> Dog.objects.filter(data=None)
<QuerySet [<Dog: Archie>]>
>>> Dog.objects.filter(data=Value(None, JSONField()))
<QuerySet [<Dog: Archie>]>
>>> Dog.objects.filter(data__isnull=True)
<QuerySet [<Dog: Max>]>
>>> Dog.objects.filter(data__isnull=False)
<QuerySet [<Dog: Archie>]>

Osim ako niste sigurni da želite da radite sa SQL NULLvrednostima, razmislite o postavljanju null=Falsei obezbeđivanju odgovarajuće podrazumevane vrednosti za prazne vrednosti, kao što su default=dict.

Napomena

Čuvanje JSON skalara nullne krši null=False.
Transformacije ključa, indeksa i putanje

Da biste napravili upit na osnovu datog ključa rečnika, koristite taj ključ kao ime pretrage:

>>> Dog.objects.create(
...     name="Rufus",
...     data={
...         "breed": "labrador",
...         "owner": {
...             "name": "Bob",
...             "other_pets": [
...                 {
...                     "name": "Fishy",
...                 }
...             ],
...         },
...     },
... )
<Dog: Rufus>
>>> Dog.objects.create(name="Meg", data={"breed": "collie", "owner": None})
<Dog: Meg>
>>> Dog.objects.filter(data__breed="collie")
<QuerySet [<Dog: Meg>]>

Više ključeva može biti povezano zajedno da bi se formirala pretraga putanje:

>>> Dog.objects.filter(data__owner__name="Bob")
<QuerySet [<Dog: Rufus>]>

Ako je ključ ceo broj, biće interpretiran kao transformacija indeksa u nizu:

>>> Dog.objects.filter(data__owner__other_pets__0__name="Fishy")
<QuerySet [<Dog: Rufus>]>

Ako se ključ po kojem želite da izvršite upit sukobljava sa imenom druge pretrage, containsumesto toga koristite tu pretragu.

Da biste upitali za nedostajuće ključeve, koristite isnullpretragu:

>>> Dog.objects.create(name="Shep", data={"breed": "collie"})
<Dog: Shep>
>>> Dog.objects.filter(data__owner__isnull=True)
<QuerySet [<Dog: Shep>]>

Napomena

Primeri pretrage dati gore implicitno koriste exactpretragu. Transformacije ključa, indeksa i putanje takođe mogu biti povezane sa: icontains, endswith, iendswith, iexact, regex, , iregex, startswith, istartswith, lt, lte, gt, i gte, kao i sa Containment i pretragama ključa .
KT()izrazi

klasa KT ( pretraga )

    Predstavlja tekstualnu vrednost ključa, indeksa ili transformacije putanje od JSONField. Možete koristiti notaciju sa dvostrukom podvlakom lookupda biste povezali transformacije ključa i indeksa rečnika.

    Na primer:

    >>> from django.db.models.fields.json import KT
    >>> Dog.objects.create(
    ...     name="Shep",
    ...     data={
    ...         "owner": {"name": "Bob"},
    ...         "breed": ["collie", "lhasa apso"],
    ...     },
    ... )
    <Dog: Shep>
    >>> Dog.objects.annotate(
    ...     first_breed=KT("data__breed__1"), owner_name=KT("data__owner__name")
    ... ).filter(first_breed__startswith="lhasa", owner_name="Bob")
    <QuerySet [<Dog: Shep>]>

Napomena

Zbog načina na koji funkcionišu upiti tipa „ključ-putanja“, exclude()nije filter()garantovano da će proizvesti iscrpne skupove. Ako želite da uključite objekte koji nemaju putanju, dodajte isnullpretragu.

Upozorenje

Pošto bilo koji string može biti ključ u JSON objektu, svaka pretraga osim onih navedenih u nastavku biće interpretirana kao pretraga ključa. Neće biti izbačenih grešaka. Budite posebno pažljivi na greške u kucanju i uvek proverite da li vaši upiti funkcionišu kako želite.

Korisnici MariaDB-a i Oracle-a

Korišćenje order_by()transformacija tipa „on key“, „index“ ili „path“ sortiraće objekte koristeći string reprezentaciju vrednosti. To je zato što MariaDB i Oracle Database ne pružaju funkciju koja konvertuje JSON vrednosti u njihove ekvivalentne SQL vrednosti.

Korisnici Orakla

Na Oracle bazi podataka, korišćenje Nonekao vrednosti pretrage u exclude()upitu će vratiti objekte koji nemaju nullkao vrednost na datoj putanji, uključujući objekte koji nemaju putanju. Na drugim bekendovima baza podataka, upit će vratiti objekte koji imaju putanju, a vrednost nije null.

Korisnici PostgreSQL-a

U PostgreSQL-u, ako se koristi samo jedan ključ ili indeks, koristi se SQL operator ->. Ako se koristi više operatora, onda #>se koristi operator .

Korisnici SQLite-a

Na SQLite-u "true", vrednosti "false", i "null"stringovi će uvek biti interpretirane kao True, Falsei JSON, nullrespektivno.
Zadržavanje i pretrage ključeva
contains¶

Pretraga containsse zamenjuje na JSONField. Vraćeni objekti su oni gde su dati dictparovi ključ-vrednost sadržani u najvišem nivou polja. Na primer:

>>> Dog.objects.create(name="Rufus", data={"breed": "labrador", "owner": "Bob"})
<Dog: Rufus>
>>> Dog.objects.create(name="Meg", data={"breed": "collie", "owner": "Bob"})
<Dog: Meg>
>>> Dog.objects.create(name="Fred", data={})
<Dog: Fred>
>>> Dog.objects.create(
...     name="Merry", data={"breed": "pekingese", "tricks": ["fetch", "dance"]}
... )
>>> Dog.objects.filter(data__contains={"owner": "Bob"})
<QuerySet [<Dog: Rufus>, <Dog: Meg>]>
>>> Dog.objects.filter(data__contains={"breed": "collie"})
<QuerySet [<Dog: Meg>]>
>>> Dog.objects.filter(data__contains={"tricks": ["dance"]})
<QuerySet [<Dog: Merry>]>

Oracle i SQLite

containsnije podržano na Oracle-u i SQLite-u.
contained_by¶

Ovo je inverzno od containspretrage - vraćeni objekti će biti oni gde su parovi ključ-vrednost na objektu podskup onih u prosleđenoj vrednosti. Na primer:

>>> Dog.objects.create(name="Rufus", data={"breed": "labrador", "owner": "Bob"})
<Dog: Rufus>
>>> Dog.objects.create(name="Meg", data={"breed": "collie", "owner": "Bob"})
<Dog: Meg>
>>> Dog.objects.create(name="Fred", data={})
<Dog: Fred>
>>> Dog.objects.create(
...     name="Merry", data={"breed": "pekingese", "tricks": ["fetch", "dance"]}
... )
>>> Dog.objects.filter(data__contained_by={"breed": "collie", "owner": "Bob"})
<QuerySet [<Dog: Meg>, <Dog: Fred>]>
>>> Dog.objects.filter(data__contained_by={"breed": "collie"})
<QuerySet [<Dog: Fred>]>
>>> Dog.objects.filter(
...     data__contained_by={"breed": "pekingese", "tricks": ["dance", "fetch", "hug"]}
... )
<QuerySet [<Dog: Merry>, <Dog: Fred>]>

Oracle i SQLite

contained_bynije podržano na Oracle-u i SQLite-u.
has_key¶

Vraća objekte gde se dati ključ nalazi na najvišem nivou podataka. Na primer:

>>> Dog.objects.create(name="Rufus", data={"breed": "labrador"})
<Dog: Rufus>
>>> Dog.objects.create(name="Meg", data={"breed": "collie", "owner": "Bob"})
<Dog: Meg>
>>> Dog.objects.filter(data__has_key="owner")
<QuerySet [<Dog: Meg>]>

has_keys¶

Vraća objekte gde su svi dati ključevi na najvišem nivou podataka. Na primer:

>>> Dog.objects.create(name="Rufus", data={"breed": "labrador"})
<Dog: Rufus>
>>> Dog.objects.create(name="Meg", data={"breed": "collie", "owner": "Bob"})
<Dog: Meg>
>>> Dog.objects.filter(data__has_keys=["breed", "owner"])
<QuerySet [<Dog: Meg>]>

has_any_keys¶

Vraća objekte gde se bilo koji od datih ključeva nalazi na najvišem nivou podataka. Na primer:

>>> Dog.objects.create(name="Rufus", data={"breed": "labrador"})
<Dog: Rufus>
>>> Dog.objects.create(name="Meg", data={"owner": "Bob"})
<Dog: Meg>
>>> Dog.objects.filter(data__has_any_keys=["owner", "breed"])
<QuerySet [<Dog: Rufus>, <Dog: Meg>]>

Složene pretrage sa Qobjektima

Upiti sa argumentima ključnih reči – u filter(), itd. – se kombinuju operacijom „I“. Ako treba da izvršite složenije upite (na primer, upite sa ORizjavama), možete koristiti .Q objects

Objekat ( ) je objekat koji se koristi za kapsuliranje kolekcije ključnih argumenata. Ovi ključni argumenti su navedeni kao u odeljku „Pretrage polja“ iznad.Q objectdjango.db.models.Q

Na primer, ovaj Qobjekat obuhvata jedan LIKEupit:

from django.db.models import Q

Q(question__startswith="What")

QObjekti se mogu kombinovati pomoću operatora &, |i ^. Kada se operator koristi na dva Qobjekta, on daje novi Qobjekat.

Na primer, ova izjava daje jedan Qobjekat koji predstavlja „ILI“ dva "question__startswith"upita:

Q(question__startswith="Who") | Q(question__startswith="What")

Ovo je ekvivalentno sledećoj SQL WHEREklauzuli:

WHERE question LIKE 'Who%' OR question LIKE 'What%'

Možete sastaviti iskaze proizvoljne složenosti kombinovanjem Qobjekata pomoću operatora &, |i ^i korišćenjem grupisanja u zagradama. Takođe, Qobjekti se mogu negirati pomoću ~operatora , što omogućava kombinovane pretrage koje kombinuju i normalan upit i negirani ( NOT) upit:

Q(question__startswith="Who") | ~Q(pub_date__year=2005)

Svakoj funkciji pretrage koja prihvata ključne reči-argumente (npr filter(). , exclude(), get()) može se proslediti i jedan ili više Qobjekata kao pozicioni (neimenovani) argumenti. Ako Qfunkciji pretrage navedete više argumenata objekata, argumenti će biti kombinovani operacijom „I“. Na primer:

Poll.objects.get(
    Q(question__startswith="Who"),
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),
)

... otprilike se prevodi u SQL:

SELECT * from polls WHERE question LIKE 'Who%'
    AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')

Funkcije pretraživanja mogu kombinovati upotrebu Qobjekata i ključnih reči. Svi argumenti dostavljeni funkciji pretraživanja (bilo da su ključne reči ili Qobjekti) se kombinuju pomoću operacije „I“. Međutim, ako Qje dostavljen objekat, on mora prethoditi definiciji bilo kojih ključnih reči. Na primer:

Poll.objects.get(
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),
    question__startswith="Who",
)

... bi bio validan upit, ekvivalentan prethodnom primeru; ali:

# INVALID QUERY
Poll.objects.get(
    question__startswith="Who",
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),
)

... ne bi bilo validno.

Vidi takođe

Primeri ILI pretraga u DŽangovim jediničnim testovima pokazuju neke moguće upotrebe Q.
Poređenje objekata

Da biste uporedili dve instance modela, koristite standardni operator poređenja u Pajtonu, znak jednakosti dvostruko: ==. Iza kulisa, koji upoređuje vrednosti primarnog ključa dva modela.

Koristeći Entrygornji primer, sledeće dve izjave su ekvivalentne:

>>> some_entry == other_entry
>>> some_entry.id == other_entry.id

Ako se primarni ključ modela ne poziva id, nema problema. Poređenja će uvek koristiti primarni ključ, bez obzira na to kako se poziva. Na primer, ako se polje primarnog ključa modela poziva name, ova dva iskaza su ekvivalentna:

>>> some_obj == other_obj
>>> some_obj.name == other_obj.name

Brisanje objekata

Metoda za brisanje, zgodno, nosi ime delete(). Ova metoda odmah briše objekat i vraća broj obrisanih objekata i rečnik sa brojem brisanja po tipu objekta. Primer:

>>> e.delete()
(1, {'blog.Entry': 1})

Takođe možete brisati objekte odjednom. Svaki QuerySetima delete()metodu koja briše sve članove tog QuerySet.

Na primer, ovo briše sve Entryobjekte sa pub_dategodinom 2005:

>>> Entry.objects.filter(pub_date__year=2005).delete()
(5, {'webapp.Entry': 5})

Imajte na umu da će se ovo, kad god je to moguće, izvršavati isključivo u SQL-u, tako da delete()metode pojedinačnih instanci objekata neće nužno biti pozivane tokom procesa. Ako ste obezbedili prilagođenu delete()metodu na klasi modela i želite da osigurate da se ona poziva, moraćete da „ručno“ obrišete instance tog modela (npr. iteracijom kroz a QuerySeti pozivanjem delete()svakog objekta pojedinačno) umesto da koristite grupnu delete()metodu od a QuerySet.

Kada Django obriše objekat, podrazumevano emulira ponašanje SQL ograničenja – drugim rečima, svi objekti koji su imali strane ključeve koji ukazuju na objekat koji treba obrisati biće obrisani zajedno sa njim. Na primer:ON DELETE CASCADE

b = Blog.objects.get(pk=1)
# This will delete the Blog and all of its Entry objects.
b.delete()

Ovo kaskadno ponašanje se može prilagoditi putem on_deleteargumenta za ForeignKey.

Imajte na umu da delete()je to jedina QuerySetmetoda koja nije izložena na Managersamom . Ovo je bezbednosni mehanizam koji sprečava da slučajno zahtevate Entry.objects.delete()i obrišete sve unose. Ako želite da obrišete sve objekte, onda morate eksplicitno da zahtevate kompletan skup upita:

Entry.objects.all().delete()

Kopiranje instanci modela

Iako ne postoji ugrađena metoda za kopiranje instanci modela, moguće je lako kreirati novu instancu sa svim kopiranim vrednostima polja. U najjednostavnijem slučaju, možete podesiti pkna Nonei _state.addingna True. Koristeći naš primer sa bloga:

blog = Blog(name="My blog", tagline="Blogging is easy")
blog.save()  # blog.pk == 1

blog.pk = None
blog._state.adding = True
blog.save()  # blog.pk == 2

Stvari postaju komplikovanije ako koristite nasleđivanje. Razmotrite podklasu od Blog:

class ThemeBlog(Blog):
    theme = models.CharField(max_length=200)


django_blog = ThemeBlog(name="Django", tagline="Django is easy", theme="python")
django_blog.save()  # django_blog.pk == 3

Zbog načina na koji nasleđivanje funkcioniše, morate podesiti i , pki idna None, i _state.addingna True:

django_blog.pk = None
django_blog.id = None
django_blog._state.adding = True
django_blog.save()  # django_blog.pk == 4

Ovaj proces ne kopira relacije koje nisu deo tabele baze podataka modela. Na primer, Entryima ` ManyToManyFieldto` Author. Nakon dupliranja unosa, morate podesiti relacije `više-prema-više` za novi unos:

entry = Entry.objects.all()[0]  # some previous entry
old_authors = entry.authors.all()
entry.pk = None
entry._state.adding = True
entry.save()
entry.authors.set(old_authors)

Za OneToOneField, morate duplirati povezani objekat i dodeliti ga polju novog objekta kako biste izbegli kršenje ograničenja jedinstvenosti jedan-na-jedan. Na primer, pretpostavljajući entryda je već dupliran kao gore:

detail = EntryDetail.objects.all()[0]
detail.pk = None
detail._state.adding = True
detail.entry = entry
detail.save()

Ažuriranje više objekata odjednom

Ponekad želite da postavite polje na određenu vrednost za sve objekte u QuerySet. To možete učiniti pomoću update()metode. Na primer:

# Update all the headlines with pub_date in 2007.
Entry.objects.filter(pub_date__year=2007).update(headline="Everything is the same")

Ovim metodom možete podesiti samo polja koja nisu relacije i ForeignKeypolja. Da biste ažurirali polje koje nije relacija, unesite novu vrednost kao konstantu. Da biste ažurirali ForeignKeypolja, podesite novu vrednost da bude nova instanca modela na koju želite da ukazujete. Na primer:

>>> b = Blog.objects.get(pk=1)

# Change every Entry so that it belongs to this Blog.
>>> Entry.objects.update(blog=b)

Metod update()se primenjuje odmah i vraća broj redova koji se podudaraju sa upitom (koji možda neće biti jednak broju ažuriranih redova ako neki redovi već imaju novu vrednost). Jedino ograničenje za QuerySetažuriranje je da može pristupiti samo jednoj tabeli baze podataka: glavnoj tabeli modela. Možete filtrirati na osnovu povezanih polja, ali možete ažurirati samo kolone u glavnoj tabeli modela. Primer:

>>> b = Blog.objects.get(pk=1)

# Update all the headlines belonging to this Blog.
>>> Entry.objects.filter(blog=b).update(headline="Everything is the same")

Imajte na umu da update()se metod direktno konvertuje u SQL izraz. To je grupna operacija za direktna ažuriranja. Ne pokreće nikakve save()metode na vašim modelima, niti emituje signale ` pre_saveor` post_save(koji su posledica pozivanja `or` save()), niti poštuje auto_nowopciju `field`. Ako želite da sačuvate svaku stavku u `a` QuerySeti da se uverite da save()se metoda poziva u svakoj instanci, ne treba vam nikakva posebna funkcija za to. Pređite preko njih petljom i pozovite save()`: `

for item in my_queryset:
    item.save()

Pozivi funkcije update takođe mogu da se koriste za ažuriranje jednog polja na osnovu vrednosti drugog polja u modelu. Ovo je posebno korisno za povećanje brojača na osnovu njihove trenutne vrednosti. Na primer, da biste povećali brojač pingbekova za svaki unos na blogu:F expressions

>>> Entry.objects.update(number_of_pingbacks=F("number_of_pingbacks") + 1)

Međutim, za razliku od F()objekata u klauzulama filter i exclude, ne možete uvesti spajanja kada koristite F()objekte u ažuriranju – možete referencirati samo polja lokalna za model koji se ažurira. Ako pokušate da uvedete spajanje sa F()objektom, FieldErrorizazvaće se :

# This will raise a FieldError
>>> Entry.objects.update(headline=F("blog__name"))

Povezani objekti

Kada definišete odnos u modelu (tj. , ForeignKey, OneToOneFieldili ManyToManyField), instance tog modela će imati zgodan API za pristup povezanom objektu (objekatima).

Koristeći modele na vrhu ove stranice, na primer, Entryobjekat emože dobiti svoj pridruženi Blogobjekat pristupom blogatributu: e.blog.

(Iza kulisa, ovu funkcionalnost implementiraju Pajton deskriptori . Ovo vam ne bi trebalo biti bitno, ali ovde ističemo za radoznale.)

Django takođe kreira API pristupnike za „drugu“ stranu odnosa – vezu od povezanog modela do modela koji definiše odnos. Na primer, Blogobjekat bima pristup listi svih povezanih Entryobjekata preko entry_setatributa: b.entry_set.all().

Svi primeri u ovom odeljku koriste uzorak Blogi Authormodele Entrydefinisane na vrhu ove stranice.
Relacije jedan-prema-više
Napred

Ako model ima ForeignKey, instance tog modela će imati pristup povezanom (stranom) objektu putem atributa modela.

Primer:

>>> e = Entry.objects.get(id=2)
>>> e.blog  # Returns the related Blog object.

Možete dobiti i podesiti preko atributa stranog ključa. Kao što možete očekivati, promene stranog ključa se ne čuvaju u bazi podataka dok ne pozovete save(). Primer:

>>> e = Entry.objects.get(id=2)
>>> e.blog = some_blog
>>> e.save()

Ako ForeignKeypolje ima null=Truepodešene vrednosti (tj. dozvoljava NULLvrednosti), možete dodeliti Noneda biste uklonili relaciju. Primer:

>>> e = Entry.objects.get(id=2)
>>> e.blog = None
>>> e.save()  # "UPDATE blog_entry SET blog_id = NULL ...;"

Pristup unapred odnosima „jedan-prema-više“ se kešira prvi put kada se pristupi povezanom objektu. Naknadni pristupi stranom ključu na istoj instanci objekta se keširaju. Primer:

>>> e = Entry.objects.get(id=2)
>>> print(e.blog)  # Hits the database to retrieve the associated Blog.
>>> print(e.blog)  # Doesn't hit the database; uses cached version.

Imajte na umu da metoda rekurzivno unapred popunjava keš memoriju svih relacija „jedan-prema-više“. Primer:select_related() QuerySet

>>> e = Entry.objects.select_related().get(id=2)
>>> print(e.blog)  # Doesn't hit the database; uses cached version.
>>> print(e.blog)  # Doesn't hit the database; uses cached version.

Praćenje odnosa „unazad“

Ako model ima ForeignKey, instance modela stranog ključa će imati pristup koji Managervraća sve instance prvog modela. Podrazumevano, ovo Managerse naziva FOO_set, gde FOOje ime izvornog modela, malim slovima. Ovo Managervraća QuerySetinstance, koje se mogu filtrirati i manipulisati njima kao što je opisano u odeljku „Preuzimanje objekata“ iznad.

Primer:

>>> b = Blog.objects.get(id=1)
>>> b.entry_set.all()  # Returns all Entry objects related to Blog.

# b.entry_set is a Manager that returns QuerySets.
>>> b.entry_set.filter(headline__contains="Lennon")
>>> b.entry_set.count()

Možete zameniti FOO_setime postavljanjem related_nameparametra u ForeignKeydefiniciji. Na primer, ako Entryje model izmenjen u , gornji primer koda bi izgledao ovako:blog = ForeignKey(Blog, on_delete=models.CASCADE, related_name='entries')

>>> b = Blog.objects.get(id=1)
>>> b.entries.all()  # Returns all Entry objects related to Blog.

# b.entries is a Manager that returns ``QuerySet`` instances.
>>> b.entries.filter(headline__contains="Lennon")
>>> b.entries.count()

Korišćenje prilagođenog obrnutog menadžera

Podrazumevano, ``koji RelatedManagerse koristi za obrnute relacije`` je podklasa podrazumevanog menadžera za taj model. Ako želite da navedete drugi menadžer za dati upit, možete koristiti sledeću sintaksu:

from django.db import models


class Entry(models.Model):
    # ...
    objects = models.Manager()  # Default Manager
    entries = EntryManager()  # Custom Manager


b = Blog.objects.get(id=1)
b.entry_set(manager="entries").all()

Ako EntryManagerse u njegovoj metodi izvrši podrazumevano filtriranje get_queryset(), to filtriranje bi se primenilo na all()poziv.

Određivanje prilagođenog obrnutog menadžera vam takođe omogućava da pozovete njegove prilagođene metode:

b.entry_set(manager="entries").is_published()

Interakcija sa prethodnim učitavanjem

Prilikom pozivanja prefetch_related()sa obrnutom relacijom, koristiće se podrazumevani menadžer. Ako želite da unapred učitate povezane objekte koristeći prilagođeni obrnuti menadžer, koristite Prefetch(). Na primer:

from django.db.models import Prefetch

prefetch_manager = Prefetch("entry_set", queryset=Entry.entries.all())
Blog.objects.prefetch_related(prefetch_manager)

Dodatne metode za rukovanje povezanim objektima

Pored QuerySetmetoda definisanih u odeljku „Preuzimanje objekata“ iznad, ima dodatne metode koje se koriste za rukovanje skupom povezanih objekata. Sinopsis svake od njih je dat u nastavku, a kompletni detalji se mogu naći u referenci za povezane objekte .ForeignKey Manager

add(obj1, obj2, ...)

    Dodaje navedene objekte modela u povezani skup objekata.
create(**kwargs)

    Kreira novi objekat, čuva ga i stavlja ga u povezani skup objekata. Vraća novokreirani objekat.
remove(obj1, obj2, ...)

    Uklanja navedene objekte modela iz povezanog skupa objekata.
clear()

    Uklanja sve objekte iz povezanog skupa objekata.
set(objs)

    Zamenite skup povezanih objekata.

Da biste dodelili članove povezanog skupa, koristite set()metodu sa iterabilnom vrstom instanci objekata. Na primer, ako su e1i instance:e2Entry

b = Blog.objects.get(id=1)
b.entry_set.set([e1, e2])

Ako clear()je metod dostupan, svi postojeći objekti će biti uklonjeni iz skupa entry_setpre nego što se svi objekti u iterabilnom elementu (u ovom slučaju, listi) dodaju u skup. Ako clear()metod nije dostupan, svi objekti u iterabilnom elementu će biti dodati bez uklanjanja postojećih elemenata.

Svaka „obrnuta“ operacija opisana u ovom odeljku ima trenutni efekat na bazu podataka. Svako dodavanje, kreiranje i brisanje se odmah i automatski čuva u bazi podataka.
Relacije „više prema mnogo“

Oba kraja relacije „više prema više“ dobijaju automatski API pristup drugom kraju. API funkcioniše slično kao „obratna“ relacija „jedan prema više“, gore.

Jedna razlika je u imenovanju atributa: model koji definiše ManyToManyFieldkoristi naziv atributa samog polja, dok „obrnuti“ model koristi malim slovima naziv modela originalnog modela, plus '_set'(baš kao i obrnuti odnosi jedan-prema-više).

Primer olakšava razumevanje ovoga:

e = Entry.objects.get(id=3)
e.authors.all()  # Returns all Author objects for this Entry.
e.authors.count()
e.authors.filter(name__contains="John")

a = Author.objects.get(id=5)
a.entry_set.all()  # Returns all Entry objects for this Author.

Kao ForeignKey, ManyToManyFieldmože da navede related_name. U gornjem primeru, ako je ` ManyToManyFieldin` Entrynaveo related_name='entries', onda bi svaka Authorinstanca imala entriesatribut umesto entry_set.

Još jedna razlika u odnosu na relacije „jedan-prema-više“ je to što pored instanci modela, metode add(), set()i remove()u relacijama „više-prema-više“ prihvataju vrednosti primarnog ključa. Na primer, ako su e1i instance, onda ovi pozivi funkcionišu identično:e2Entryset()

a = Author.objects.get(id=5)
a.entry_set.set([e1, e2])
a.entry_set.set([e1.pk, e2.pk])

Jedan-na-jedan odnosi

Relacije „jedan-prema-jedan“ su veoma slične relacijama „više-prema-jedan“. Ako definišete OneToOneFieldna svom modelu, instance tog modela će imati pristup povezanom objektu putem atributa modela.

Na primer:

class EntryDetail(models.Model):
    entry = models.OneToOneField(Entry, on_delete=models.CASCADE)
    details = models.TextField()


ed = EntryDetail.objects.get(id=2)
ed.entry  # Returns the related Entry object.

Razlika se javlja u „obrnutim“ upitima. Povezani model u odnosu jedan-na-jedan takođe ima pristup objektu Manager, ali on Managerpredstavlja jedan objekat, a ne kolekciju objekata:

e = Entry.objects.get(id=2)
e.entrydetail  # returns the related EntryDetail object

Ako ovoj relaciji nije dodeljen nijedan objekat, Django će izazvati DoesNotExistizuzetak.

Instance se mogu dodeliti obrnutoj relaciji na isti način kao što biste dodelili direktnu relaciju:

e.entrydetail = ed

Kako su moguće obrnute veze?

Drugi maperi objektno-relacionih struktura zahtevaju da definišete odnose na obe strane. Programeri Django-a smatraju da je ovo kršenje DRY (Don't Repeat Yourself) principa, tako da Django zahteva da definišete odnos samo na jednoj strani.

Ali kako je to moguće, s obzirom na to da klasa modela ne zna koje su druge klase modela povezane sa njom dok se te druge klase modela ne učitaju?

Odgovor leži u . Kada se Django pokrene, on uvozi svaku aplikaciju navedenu u , a zatim i modul unutar svake aplikacije. Kad god se kreira nova klasa modela, Django dodaje unazadne veze svim povezanim modelima. Ako povezani modeli još nisu uvezeni, Django prati veze i dodaje ih kada se povezani modeli na kraju uvezu.app registryINSTALLED_APPSmodels

Zbog toga je posebno važno da svi modeli koje koristite budu definisani u aplikacijama navedenim u INSTALLED_APPS. U suprotnom, obrnute relacije možda neće pravilno funkcionisati.
Upiti nad povezanim objektima

Upiti koji uključuju povezane objekte prate ista pravila kao i upiti koji uključuju polja normalne vrednosti. Prilikom određivanja vrednosti koju upit treba da podudara, možete koristiti ili samu instancu objekta ili vrednost primarnog ključa za objekat.

Na primer, ako imate objekat Blog bsa id=5, sledeća tri upita bi bila identična:

Entry.objects.filter(blog=b)  # Query using object instance
Entry.objects.filter(blog=b.id)  # Query using id from instance
Entry.objects.filter(blog=5)  # Query using id directly

Povratak na sirovi SQL

Ako se nađete u situaciji da treba da napišete SQL upit koji je previše složen za obradu od strane Django-ovog mapera baze podataka, možete se osloniti na ručno pisanje SQL-a. Django ima nekoliko opcija za pisanje sirovih SQL upita; pogledajte Izvršavanje sirovih SQL upita .

Konačno, važno je napomenuti da je sloj baze podataka Django samo interfejs ka vašoj bazi podataka. Možete pristupiti svojoj bazi podataka putem drugih alata, programskih jezika ili okvira baza podataka; nema ničeg specifičnog za Django u vezi sa vašom bazom podataka.

[⚠️ Suspicious Content] Agregacija

Vodič kroz teme o Django-ovom API-ju za apstrakciju baze podataka opisao je način na koji možete koristiti Django upite koji kreiraju, preuzimaju, ažuriraju i brišu pojedinačne objekte. Međutim, ponekad će vam biti potrebno da preuzmete vrednosti koje su izvedene sumiranjem ili agregacijom kolekcije objekata. Ovaj vodič kroz teme opisuje načine na koje se agregatne vrednosti mogu generisati i vratiti pomoću Django upita.

U ovom vodiču ćemo se pozivati na sledeće modele. Ovi modeli se koriste za praćenje zaliha za niz onlajn knjižara:

from django.db import models


class Author(models.Model):
    name = models.CharField(max_length=100)
    age = models.IntegerField()


class Publisher(models.Model):
    name = models.CharField(max_length=300)


class Book(models.Model):
    name = models.CharField(max_length=300)
    pages = models.IntegerField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    rating = models.FloatField()
    authors = models.ManyToManyField(Author)
    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)
    pubdate = models.DateField()


class Store(models.Model):
    name = models.CharField(max_length=300)
    books = models.ManyToManyField(Book)

Špargalka

U žurbi? Evo kako se izvode uobičajeni agregatni upiti, pod pretpostavkom gore navedenih modela:

# Total number of books.
>>> Book.objects.count()
2452

# Total number of books with publisher=BaloneyPress
>>> Book.objects.filter(publisher__name="BaloneyPress").count()
73

# Average price across all books, provide default to be returned instead
# of None if no books exist.
>>> from django.db.models import Avg
>>> Book.objects.aggregate(Avg("price", default=0))
{'price__avg': 34.35}

# Max price across all books, provide default to be returned instead of
# None if no books exist.
>>> from django.db.models import Max
>>> Book.objects.aggregate(Max("price", default=0))
{'price__max': Decimal('81.20')}

# Difference between the highest priced book and the average price of all books.
>>> from django.db.models import FloatField
>>> Book.objects.aggregate(
...     price_diff=Max("price", output_field=FloatField()) - Avg("price")
... )
{'price_diff': 46.85}

# All the following queries involve traversing the Book<->Publisher
# foreign key relationship backwards.

# Each publisher, each with a count of books as a "num_books" attribute.
>>> from django.db.models import Count
>>> pubs = Publisher.objects.annotate(num_books=Count("book"))
>>> pubs
<QuerySet [<Publisher: BaloneyPress>, <Publisher: SalamiPress>, ...]>
>>> pubs[0].num_books
73

# Each publisher, with a separate count of books with a rating above and below 5
>>> from django.db.models import Q
>>> above_5 = Count("book", filter=Q(book__rating__gt=5))
>>> below_5 = Count("book", filter=Q(book__rating__lte=5))
>>> pubs = Publisher.objects.annotate(below_5=below_5).annotate(above_5=above_5)
>>> pubs[0].above_5
23
>>> pubs[0].below_5
12

# The top 5 publishers, in order by number of books.
>>> pubs = Publisher.objects.annotate(num_books=Count("book")).order_by("-num_books")[:5]
>>> pubs[0].num_books
1323

Generisanje agregata preko QuerySet¶

DŽango pruža dva načina za generisanje agregata. Prvi način je generisanje rezimiranih vrednosti za ceo period QuerySet. Na primer, recimo da želite da izračunate prosečnu cenu svih knjiga dostupnih za prodaju. DŽangoova sintaksa upita pruža način za opisivanje skupa svih knjiga:

>>> Book.objects.all()

Potreban nam je način da izračunamo zbirne vrednosti za objekte koji pripadaju ovom QuerySet. To se radi dodavanjem aggregate()klauzule na QuerySet:

>>> from django.db.models import Avg
>>> Book.objects.all().aggregate(Avg("price"))
{'price__avg': 34.35}

U ovom primeru je all()suvišno, pa bi se ovo moglo pojednostaviti na:

>>> Book.objects.aggregate(Avg("price"))
{'price__avg': 34.35}

Argument klauzule aggregate()opisuje agregatnu vrednost koju želimo da izračunamo - u ovom slučaju, prosek polja pricena Bookmodelu. Lista dostupnih agregatnih funkcija može se naći u referenci QuerySet .

aggregate()je terminalna klauzula za QuerySetkoja, kada se pozove, vraća rečnik parova ime-vrednost. Ime je identifikator za agregatnu vrednost; vrednost je izračunati agregat. Ime se automatski generiše iz imena polja i agregatne funkcije. Ako želite ručno da navedete ime za agregatnu vrednost, to možete učiniti tako što ćete navesti to ime kada navodite agregatnu klauzulu:

>>> Book.objects.aggregate(average_price=Avg("price"))
{'average_price': 34.35}

Ako želite da generišete više od jednog agregata, dodajete još jedan argument klauzuli aggregate(). Dakle, ako bismo takođe želeli da znamo maksimalnu i minimalnu cenu svih knjiga, izdali bismo upit:

>>> from django.db.models import Avg, Max, Min
>>> Book.objects.aggregate(Avg("price"), Max("price"), Min("price"))
{'price__avg': 34.35, 'price__max': Decimal('81.20'), 'price__min': Decimal('12.99')}

Generisanje agregata za svaku stavku u QuerySet¶

Drugi način generisanja rezimiranih vrednosti je generisanje nezavisnog rezimea za svaki objekat u QuerySet. Na primer, ako preuzimate listu knjiga, možda ćete želeti da znate koliko je autora doprinelo svakoj knjizi. Svaka knjiga ima odnos „više-prema-više“ sa autorom; želimo da sumiramo ovaj odnos za svaku knjigu u QuerySet.

Rezimei po objektu mogu se generisati pomoću annotate()klauzule. Kada annotate()je klauzula navedena, svaki objekat u QuerySetće biti anotiran navedenim vrednostima.

Sintaksa za ove napomene je identična onoj koja se koristi za aggregate()klauzulu. Svaki argument annotate()opisuje agregat koji treba izračunati. Na primer, da biste anotirali knjige brojem autora:

# Build an annotated queryset
>>> from django.db.models import Count
>>> q = Book.objects.annotate(Count("authors"))
# Interrogate the first object in the queryset
>>> q[0]
<Book: The Definitive Guide to Django>
>>> q[0].authors__count
2
# Interrogate the second object in the queryset
>>> q[1]
<Book: Practical Django Projects>
>>> q[1].authors__count
1

Kao i kod aggregate(), ime za anotaciju se automatski izvodi iz imena agregatne funkcije i imena polja koje se agregira. Možete poništiti ovo podrazumevano ime tako što ćete navesti alias kada navodite anotaciju:

>>> q = Book.objects.annotate(num_authors=Count("authors"))
>>> q[0].num_authors
2
>>> q[1].num_authors
1

Za razliku od aggregate(), annotate()nije terminalna klauzula. Izlaz klauzule je ; ovo se može izmeniti korišćenjem bilo koje druge operacije, uključujući , , ili čak dodatne pozive funkcije .annotate()QuerySetQuerySetQuerySetfilter()order_by()annotate()
Kombinovanje više agregacija

Kombinovanje više agregacija sa annotate()će dati pogrešne rezultate jer se umesto podupita koriste spajanja:

>>> book = Book.objects.first()
>>> book.authors.count()
2
>>> book.store_set.count()
3
>>> q = Book.objects.annotate(Count("authors"), Count("store"))
>>> q[0].authors__count
6
>>> q[0].store__count
6

Za većinu agregata ne postoji način da se izbegne ovaj problem, međutim, Countagregat ima distinctparametar koji može pomoći:

>>> q = Book.objects.annotate(
...     Count("authors", distinct=True), Count("store", distinct=True)
... )
>>> q[0].authors__count
2
>>> q[0].store__count
3

Ako ste u nedoumici, proverite SQL upit!

Da biste razumeli šta se dešava u vašem upitu, razmislite o proveri querysvojstva vašeg QuerySet.
Spajanja i agregacije

Do sada smo se bavili agregatima preko polja koja pripadaju modelu koji se ispituje. Međutim, ponekad vrednost koju želite da agregirate pripada modelu koji je povezan sa modelom koji se ispituje.

Prilikom određivanja polja koje treba agregirati u agregatnoj funkciji, Django će vam omogućiti da koristite istu notaciju sa dvostrukom podvlakom koja se koristi prilikom referenciranja na povezana polja u filterima. Django će zatim obraditi sva spajanja tabela koja su potrebna za preuzimanje i agregiranje povezane vrednosti.

Na primer, da biste pronašli raspon cena knjiga koje se nude u svakoj prodavnici, možete koristiti anotaciju:

>>> from django.db.models import Max, Min
>>> Store.objects.annotate(min_price=Min("books__price"), max_price=Max("books__price"))

Ovo govori DŽangu da preuzme Storemodel, spoji ga (kroz vezu „više-prema-više“) sa Bookmodelom i agregira ga na polju cene modela knjige kako bi se dobila minimalna i maksimalna vrednost.

Ista pravila važe i za aggregate()klauzulu. Ako želite da znate najnižu i najvišu cenu bilo koje knjige koja je dostupna za prodaju u bilo kojoj od prodavnica, možete koristiti agregat:

>>> Store.objects.aggregate(min_price=Min("books__price"), max_price=Max("books__price"))

Lanci spajanja mogu biti duboki koliko vam je potrebno. Na primer, da biste izdvojili godine najmlađeg autora bilo koje knjige dostupne za prodaju, mogli biste da izdate upit:

>>> Store.objects.aggregate(youngest_age=Min("books__authors__age"))

Praćenje odnosa unazad

Na način sličan pretragama koje obuhvataju odnose , agregacije i anotacije na poljima modela ili modela koji su povezani sa onim koji upitujete mogu uključivati prelazak preko „obrnutih“ odnosa. Ovde se takođe koriste mala slova imena povezanih modela i dvostruke donje crte.

Na primer, možemo da zatražimo sve izdavače, sa oznakom njihovih odgovarajućih brojača ukupnog brojača knjiga (obratite pažnju na to kako koristimo 'book'za određivanje obrnutog skoka stranog ključa Publisher-> ):Book

>>> from django.db.models import Avg, Count, Min, Sum
>>> Publisher.objects.annotate(Count("book"))

(Svaki Publisheru rezultujućem QuerySetće imati dodatni atribut pod nazivom book__count.)

Takođe možemo tražiti najstariju knjigu bilo koje od onih koje vodi svaki izdavač:

>>> Publisher.objects.aggregate(oldest_pubdate=Min("book__pubdate"))

(Dobijeni rečnik će imati ključ pod nazivom 'oldest_pubdate'. Ako takav alias nije naveden, to bi bio prilično dugačak 'book__pubdate__min'.)

Ovo se ne odnosi samo na strane ključeve. Takođe funkcioniše sa relacijama „više-prema-više“. Na primer, možemo pitati za svakog autora, sa navedenim ukupnim brojem stranica uzimajući u obzir sve knjige koje je autor (ko)autor (obratite pažnju na to kako koristimo 'book'da bismo odredili Author-> Bookobrnuti skok „više-prema-više“):

>>> Author.objects.annotate(total_pages=Sum("book__pages"))

(Svaki Authoru rezultujućem QuerySetće imati dodatni atribut pod nazivom total_pages. Ako takav alias nije naveden, to bi bio prilično dugačak book__pages__sum.)

Ili zatražite prosečnu ocenu svih knjiga koje je napisao autor(i) koje imamo u dosijeu:

>>> Author.objects.aggregate(average_rating=Avg("book__rating"))

(Dobijeni rečnik će imati ključ pod nazivom 'average_rating'. Ako takav alias nije naveden, to bi bio prilično dugačak 'book__rating__avg'.)
Agregacije i druge QuerySetklauzule
filter()i exclude()¶

Agregati takođe mogu učestvovati u filterima. Bilo koji filter()(ili exclude()) primenjen na normalna polja modela imaće efekat ograničavanja objekata koji se razmatraju za agregaciju.

Kada se koristi sa annotate()klauzulom, filter ima efekat ograničavanja objekata za koje se izračunava anotacija. Na primer, možete generisati anotiranu listu svih knjiga čiji naslov počinje sa „Django“ koristeći upit:

>>> from django.db.models import Avg, Count
>>> Book.objects.filter(name__startswith="Django").annotate(num_authors=Count("authors"))

Kada se koristi sa aggregate()klauzulom, filter ima efekat ograničavanja objekata nad kojima se izračunava agregat. Na primer, možete generisati prosečnu cenu svih knjiga sa naslovom koji počinje sa „Django“ koristeći upit:

>>> Book.objects.filter(name__startswith="Django").aggregate(Avg("price"))

Filtriranje po napomenama

Anotirane vrednosti se takođe mogu filtrirati. Alias za anotaciju može se koristiti u filter()klauzulama exclude()i na isti način kao i bilo koje drugo polje modela.

Na primer, da biste generisali listu knjiga koje imaju više od jednog autora, možete pokrenuti upit:

>>> Book.objects.annotate(num_authors=Count("authors")).filter(num_authors__gt=1)

Ovaj upit generiše anotirani skup rezultata, a zatim generiše filter na osnovu te anotacije.

Ako su vam potrebne dve anotacije sa dva odvojena filtera, možete koristiti filterargument sa bilo kojim agregatom. Na primer, da biste generisali listu autora sa brojem visoko ocenjenih knjiga:

>>> highly_rated = Count("book", filter=Q(book__rating__gte=7))
>>> Author.objects.annotate(num_books=Count("book"), highly_rated_books=highly_rated)

Svaki Authoru skupu rezultata će imati atribute num_booksi highly_rated_books. Vidite takođe Uslovna agregacija .

Izbor između filteriQuerySet.filter()

Izbegavajte korišćenje filterargumenta sa jednom anotacijom ili agregacijom. Efikasnije je koristiti ga QuerySet.filter()za isključivanje redova. filterArgument agregacije je koristan samo kada se koriste dve ili više agregacija nad istim relacijama sa različitim uslovima.
Redosled annotate()klauzulafilter()​

Prilikom razvoja složenog upita koji uključuje annotate()i filter()klauzule , obratite posebnu pažnju na redosled kojim se klauzule primenjuju na QuerySet.

Kada annotate()se klauzula primeni na upit, anotacija se izračunava preko stanja upita do tačke gde se anotacija zahteva. Praktična implikacija ovoga je da filter()i annotate()nisu komutativne operacije.

Dato:

    Izdavač A ima dve knjige sa ocenama 4 i 5.

    Izdavač B ima dve knjige sa ocenama 1 i 4.

    Izdavač C ima jednu knjigu sa ocenom 1.

Evo primera sa Countagregatom:

>>> a, b = Publisher.objects.annotate(num_books=Count("book", distinct=True)).filter(
...     book__rating__gt=3.0
... )
>>> a, a.num_books
(<Publisher: A>, 2)
>>> b, b.num_books
(<Publisher: B>, 2)

>>> a, b = Publisher.objects.filter(book__rating__gt=3.0).annotate(num_books=Count("book"))
>>> a, a.num_books
(<Publisher: A>, 2)
>>> b, b.num_books
(<Publisher: B>, 1)

Oba upita vraćaju listu izdavača koji imaju barem jednu knjigu sa ocenom većom od 3,0, pa je izdavač C isključen.

U prvom upitu, anotacija prethodi filteru, tako da filter nema uticaja na anotaciju. distinct=Trueje potrebno da bi se izbegla greška u upitu .

Drugi upit broji knjige koje imaju ocenu veću od 3,0 za svakog izdavača. Filter prethodi anotaciji, tako da filter ograničava objekte koji se uzimaju u obzir prilikom izračunavanja anotacije.

Evo još jednog primera sa Avgagregatom:

>>> a, b = Publisher.objects.annotate(avg_rating=Avg("book__rating")).filter(
...     book__rating__gt=3.0
... )
>>> a, a.avg_rating
(<Publisher: A>, 4.5)  # (5+4)/2
>>> b, b.avg_rating
(<Publisher: B>, 2.5)  # (1+4)/2

>>> a, b = Publisher.objects.filter(book__rating__gt=3.0).annotate(
...     avg_rating=Avg("book__rating")
... )
>>> a, a.avg_rating
(<Publisher: A>, 4.5)  # (5+4)/2
>>> b, b.avg_rating
(<Publisher: B>, 4.0)  # 4/1 (book with rating 1 excluded)

Prvi upit traži prosečnu ocenu svih knjiga izdavača za izdavače koji imaju barem jednu knjigu sa ocenom većom od 3,0. Drugi upit traži prosek ocena knjiga izdavača samo za one ocene veće od 3,0.

Teško je intuitivno shvatiti kako će ORM pretvoriti složene skupove upita u SQL upite, pa kada niste sigurni, proverite SQL str(queryset.query)i napišite mnoštvo testova.
order_by()¶

Anotacije se mogu koristiti kao osnova za uređivanje. Kada definišete order_by()klauzulu, agregati koje navedete mogu da se pozivaju na bilo koji alias definisan kao deo annotate()klauzule u upitu.

Na primer, da biste poređali QuerySetknjige po broju autora koji su doprineli knjizi, možete koristiti sledeći upit:

>>> Book.objects.annotate(num_authors=Count("authors")).order_by("num_authors")

values()¶

Obično se anotacije generišu za svaki objekat ponavljajući se - anotirana grupa QuerySetće vratiti jedan rezultat za svaki objekat u originalnom skupu rezultata QuerySet. Međutim, kada values()se klauzula koristi za ograničavanje kolona koje se vraćaju u skupu rezultata, metod za procenu anotacija je malo drugačiji. Umesto vraćanja anotiranog rezultata za svaki rezultat u originalnom skupu rezultata QuerySet, originalni rezultati se grupišu prema jedinstvenim kombinacijama polja navedenih u values()klauzuli. Zatim se za svaku jedinstvenu grupu daje anotacija; anotacija se izračunava za sve članove grupe.

Na primer, razmotrite upit za autora koji pokušava da sazna prosečnu ocenu knjiga koje je napisao svaki autor:

>>> Author.objects.annotate(average_rating=Avg("book__rating"))

Ovo će vratiti jedan rezultat za svakog autora u bazi podataka, sa napomenama o njihovoj prosečnoj oceni knjige.

Međutim, rezultat će biti malo drugačiji ako koristite values()klauzulu:

>>> Author.objects.values("name").annotate(average_rating=Avg("book__rating"))

U ovom primeru, autori će biti grupisani po imenu, tako da ćete dobiti samo anotiran rezultat za svako jedinstveno ime autora. To znači da ako imate dva autora sa istim imenom, njihovi rezultati će biti spojeni u jedan rezultat u izlazu upita; prosek će biti izračunat kao prosek knjiga koje su napisala oba autora.
Redosled annotate()klauzulavalues()​

Kao i kod filter()klauzule , redosled kojim se klauzule annotate()i values()primenjuju na upit je značajan. Ako values()klauzula prethodi annotate(), anotacija će biti izračunata korišćenjem grupisanja opisanog u values()klauzuli.

Međutim, ako annotate()klauzula prethodi values()klauzuli, anotacije će biti generisane za ceo skup upita. U ovom slučaju, values()klauzula ograničava samo polja koja se generišu na izlazu.

Na primer, ako obrnemo redosled klauzule „ values()and annotate()“ iz našeg prethodnog primera:

>>> Author.objects.annotate(average_rating=Avg("book__rating")).values(
...     "name", "average_rating"
... )

average_ratingOvo će sada dati jedan jedinstveni rezultat za svakog autora; međutim, u izlaznim podacima će biti vraćeni samo ime autora i napomena.

Takođe treba napomenuti da average_ratingje eksplicitno uključeno u listu vrednosti koje treba vratiti. Ovo je potrebno zbog redosleda klauzule values()and annotate().

Ako values()klauzula prethodi annotate()klauzuli, sve napomene će biti automatski dodate u skup rezultata. Međutim, ako values()se klauzula primenjuje nakon annotate()klauzule, potrebno je eksplicitno uključiti agregatnu kolonu.
Interakcija sa order_by()¶

Polja koja se pominju u order_by()delu skupa upita koriste se pri izboru izlaznih podataka, čak i ako nisu drugačije navedena u values()pozivu. Ova dodatna polja se koriste za grupisanje „sličnih“ rezultata i mogu učiniti da inače identični redovi rezultata izgledaju odvojeno. Ovo se posebno pojavljuje prilikom brojanja stvari.

Na primer, pretpostavimo da imate model poput ovog:

from django.db import models


class Item(models.Model):
    name = models.CharField(max_length=10)
    data = models.IntegerField()

Ako želite da izbrojite koliko puta se svaka različita datavrednost pojavljuje u uređenom skupu upita, možete pokušati ovo:

items = Item.objects.order_by("name")
# Warning: not quite correct!
items.values("data").annotate(Count("id"))

...što će grupisati Itemobjekte po njihovim zajedničkim datavrednostima, a zatim prebrojati broj idvrednosti u svakoj grupi. Osim što to neće baš funkcionisati. Redosled po nameće takođe igrati ulogu u grupisanju, tako da će ovaj upit grupisati po različitim parovima, što nije ono što želite. Umesto toga, trebalo bi da konstruišete ovaj skup upita:(data, name)

items.values("data").annotate(Count("id")).order_by()

...brisanjem bilo kakvog redosleda u upitu. Takođe možete da poređate, recimo, databez ikakvih štetnih efekata, pošto to već igra ulogu u upitu.

Ovo ponašanje je isto kao ono koje je navedeno u dokumentaciji skupa upita za , distinct()a opšte pravilo je isto: obično nećete želeti da dodatne kolone igraju ulogu u rezultatu, zato razjasnite redosled ili barem uverite se da je ograničen samo na ona polja koja takođe izaberete u values()pozivu.

Napomena

Možda se razumno pitate zašto Django ne uklanja nepotrebne kolone umesto vas. Glavni razlog je konzistentnost sa [ime metode] distinct()i drugim mestima: Django nikada ne uklanja ograničenja redosleda koja ste naveli (i ne možemo promeniti ponašanje tih drugih metoda, jer bi to kršilo našu politiku stabilnosti API-ja ).
Agregiranje anotacija

Takođe možete generisati agregat na osnovu rezultata anotacije. Kada definišete aggregate()klauzulu, agregati koje navedete mogu da se pozivaju na bilo koji alias definisan kao deo klauzule annotate()u upitu.

Na primer, ako želite da izračunate prosečan broj autora po knjizi, prvo anotirate skup knjiga brojem autora, a zatim agregirate taj broj autora, pozivajući se na polje za anotaciju:

>>> from django.db.models import Avg, Count
>>> Book.objects.annotate(num_authors=Count("authors")).aggregate(Avg("num_authors"))
{'num_authors__avg': 1.66}

Agregiranje na praznim skupovima upita ili grupama

Kada se agregacija primeni na prazan skup upita ili grupu, rezultat se podrazumevano vraća na podrazumevani parametar, obično None. Ovo ponašanje se javlja zato što agregatne funkcije vraćaju vrednost NULLkada izvršeni upit ne vrati nijedan red.

Možete navesti povratnu vrednost tako što ćete navesti podrazumevani argument za većinu agregacija. Međutim, pošto Countne podržava podrazumevani argument, uvek će se vratiti 0za prazne skupove upita ili grupe.

Na primer, pod pretpostavkom da nijedna knjiga ne sadrži „web“ u svom nazivu, izračunavanje ukupne cene za ovaj skup knjiga bi vratilo rezultat Nonejer nema odgovarajućih redova za izračunavanje Sumagregacije:

>>> from django.db.models import Sum
>>> Book.objects.filter(name__contains="web").aggregate(Sum("price"))
{"price__sum": None}

Međutim, podrazumevani argument može se podesiti prilikom pozivanja Sumda bi se vratila drugačija podrazumevana vrednost ako se ne mogu pronaći knjige:

>>> Book.objects.filter(name__contains="web").aggregate(Sum("price", default=0))
{"price__sum": Decimal("0")}

Ispod haube, podrazumevani argument je implementiran obmotavanjem agregatne funkcije sa Coalesce.

[⚠️ Suspicious Content] 
Prethodna stranica i sledeća stranica
Agregacija
Menadžeri
Dodatne informacije
Podržite DŽanga!
Подржите Џанга!

    Advokatska kancelarija Forsajt je donirala Fondaciji za softver DŽango kako bi podržala razvoj DŽanga. Donirajte danas!

Sadržaj

    Pretraga
        Slučajevi upotrebe
            Standardni tekstualni upiti
            Naprednije funkcije poređenja baze podataka
            Pretraga zasnovana na dokumentima
                Podrška za PostgreSQL

Pregledaj

    Prethodno: Agregacija
    Sledeće: Menadžeri
    Sadržaj
    Opšti indeks
    Indeks Pajton modula

Vi ste ovde:

    Dokumentacija za Django 5.2
        Korišćenje Django-a
            Modeli i baze podataka
                Pretraga

Dobijanje pomoći

Česta pitanja
    Isprobajte ČPP — ima odgovore na mnoga uobičajena pitanja. 
Indeks , indeks modula ili sadržaj
    Korisno kada tražite određene informacije. 
Django Discord server
    Pridružite se Django Discord zajednici. 
Zvanični Django forum
    Pridružite se zajednici na Django forumu. 
Praćenje karata
    Prijavite greške pomoću Django-a ili Django dokumentacije u našem sistemu za praćenje tiketa. 

Preuzmi:

Oflajn (Django 5.2): HTML | PDF | ePub
Obezbedio Read the Docs .
DŽango linkovi
Saznajte više

    O DŽangu
    Početak rada sa Django-om
    Organizacija tima
    Fondacija za softver DŽango
    Kodeks ponašanja
    Izjava o raznolikosti

Uključite se

    Pridružite se grupi
    Doprinesite Django-u
    Prijavi grešku
    Prijavi bezbednosni problem
    Individualno članstvo

Potražite pomoć

    Česta pitanja o dobijanju pomoći
    DŽango Diskord
    Zvanični Django forum

Pratite nas

    GitHab
    Tviter
    Fedivers (Mastodont)
    RSS vesti

Podržite nas

    Sponzor DŽango
    Korporativno članstvo
    Zvanična prodavnica robe
    Program dobrotvornih davanja na radnom mestu

DŽango

    Domaćin Donatori u naturi
    Dizajn od strane Tri tačke & andrevv

© 2005-2025 Fondacija Django Software i pojedinačni saradnici. Django je registrovani zaštitni znak Fondacije Django Software.

[⚠️ Suspicious Content] Menadžeri

Menadžer klasa [izvor]

A Managerje interfejs preko kojeg se operacije upita baze podataka pružaju Django modelima. ManagerPostoji bar jedan za svaki model u Django aplikaciji.

Način na koji Managerklase rade dokumentovan je u odeljku „Pravljenje upita“ ; ovaj dokument se posebno dotiče opcija modela koje prilagođavaju Managerponašanje.
Imena menadžera

Podrazumevano, Django dodaje Managersa imenom objectssvakoj Django klasi modela. Međutim, ako želite da koristite objectskao ime polja ili ako želite da koristite ime koje nije objectsza Manager, možete ga preimenovati za svaki model pojedinačno. Da biste preimenovali Managerza datu klasu, definišite atribut klase tipa models.Manager()na tom modelu. Na primer:

from django.db import models


class Person(models.Model):
    # ...
    people = models.Manager()

Korišćenjem ovog primera modela, Person.objectsgenerisaće se AttributeErrorizuzetak, ali Person.people.all()će se prikazati lista svih Personobjekata.
Prilagođeni menadžeri

Možete koristiti prilagođenu klasu Manageru određenom modelu proširivanjem osnovne Managerklase i kreiranjem vaše prilagođene klase Manageru vašem modelu.

Postoje dva razloga zašto biste možda želeli da prilagodite Manager: da dodate dodatne Managermetode i/ili da izmenite početne QuerySetvrednosti Managerkoje vraćate.
Dodavanje dodatnih metoda menadžera

Dodavanje dodatnih Managermetoda je preferirani način za dodavanje funkcionalnosti „na nivou tabele“ vašim modelima. (Za funkcionalnost „na nivou reda“ – tj. funkcije koje deluju na jednu instancu objekta modela – koristite metode modela , a ne prilagođene Managermetode.)

Na primer, ovaj običaj Managerdodaje metod with_counts():

from django.db import models
from django.db.models.functions import Coalesce


class PollManager(models.Manager):
    def with_counts(self):
        return self.annotate(num_responses=Coalesce(models.Count("response"), 0))


class OpinionPoll(models.Model):
    question = models.CharField(max_length=200)
    objects = PollManager()


class Response(models.Model):
    poll = models.ForeignKey(OpinionPoll, on_delete=models.CASCADE)
    # ...

U ovom primeru, koristili biste OpinionPoll.objects.with_counts()da biste dobili broj QuerySetobjekata OpinionPollsa priloženim num_responsesatributom .

Prilagođena Managermetoda može da vrati bilo šta što želite. Ne mora da vrati QuerySet.

Još jedna stvar koju treba napomenuti je da Managermetode mogu pristupiti self.modelklasi modela kojoj su pridružene.
Izmena inicijala menadžera QuerySet¶

ManagerBaza broja A QuerySetvraća sve objekte u sistemu. Na primer, korišćenjem ovog modela:

from django.db import models


class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.CharField(max_length=50)

...izjava Book.objects.all()će vratiti sve knjige u bazi podataka.

Možete prepisati Managerbazu metode QuerySetprepisivanjem Manager.get_queryset()metode. get_queryset()trebalo bi da vrati `a` QuerySetsa svojstvima koja su vam potrebna.

Na primer, sledeći model ima dva Manager objekta – jedan koji vraća sve objekte i jedan koji vraća samo knjige Roalda Dala:

# First, define the Manager subclass.
class DahlBookManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(author="Roald Dahl")


# Then hook it into the Book model explicitly.
class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.CharField(max_length=50)

    objects = models.Manager()  # The default manager.
    dahl_objects = DahlBookManager()  # The Dahl-specific manager.

Sa ovim primernim modelom, Book.objects.all()vratiće sve knjige u bazi podataka, ali Book.dahl_objects.all()će vratiti samo one koje je napisao Roald Dal.

Pošto get_queryset()vraća QuerySetobjekat, možete koristiti filter(), exclude()kao i sve ostale QuerySetmetode na njemu. Dakle, svi ovi iskazi su legalni:

Book.dahl_objects.all()
Book.dahl_objects.filter(title="Matilda")
Book.dahl_objects.count()

Ovaj primer je takođe ukazao na još jednu zanimljivu tehniku: korišćenje više menadžera na istom modelu. Možete dodati onoliko Manager()instanci koliko želite modelu. Ovo je način definisanja zajedničkih „filtera“ za vaše modele koji se ne ponavlja.

Na primer:

class AuthorManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(role="A")


class EditorManager(models.Manager):
    def get_queryset(self):
        return super().get_queryset().filter(role="E")


class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    role = models.CharField(max_length=1, choices={"A": _("Author"), "E": _("Editor")})
    people = models.Manager()
    authors = AuthorManager()
    editors = EditorManager()

Ovaj primer vam omogućava da zahtevate Person.authors.all(), Person.editors.all(), i Person.people.all(), što daje predvidljive rezultate.
Podrazumevani menadžeri

Model. _default_manager

Ako koristite prilagođene Managerobjekte, imajte na umu da prvi Managersusreti koje Django upoznaje (redosledom kojim su definisani u modelu) imaju poseban status. Django tumači prvi Managerdefinisani menadžer u klasi kao „podrazumevani“ Manager, a nekoliko delova Django-a (uključujući dumpdata) će ga koristiti Managerisključivo za taj model. Zbog toga je dobra ideja da budete pažljivi pri izboru podrazumevanog menadžera kako biste izbegli situaciju u kojoj zamena get_queryset()rezultira nemogućnošću preuzimanja objekata sa kojima želite da radite.

Možete da odredite prilagođeni podrazumevani menadžer koristeći Meta.default_manager_name.

Ako pišete kod koji mora da obrađuje nepoznati model, na primer, u aplikaciji treće strane koja implementira generički prikaz, koristite ovaj menadžer (ili _base_manager) umesto da pretpostavite da model ima objectsmenadžer.
Menadžeri baza

Model. _base_manager

Korišćenje menadžera za pristup povezanim objektima

Podrazumevano, Django koristi instancu Model._base_managerklase manager kada pristupa povezanim objektima (npr. choice.question), a ne `manager` _default_managerna povezanom objektu. To je zato što Django mora biti u mogućnosti da preuzme povezani objekat, čak i ako bi ga podrazumevani menadžer inače filtrirao (i samim tim bio nedostupan).

Ako normalna klasa osnovnog menadžera ( django.db.models.Manager) nije odgovarajuća za vaše okolnosti, možete reći Django-u koju klasu da koristi tako što ćete podesiti Meta.base_manager_name.

Bazni menadžeri se ne koriste prilikom upita na povezanim modelima ili prilikom pristupanja relaciji jedan-prema-više ili više-prema-više . Na primer, ako Questionmodel iz tutorijala ima deletedpolje i bazni menadžer koji filtrira instance sa deleted=True, skup upita poput Choice.objects.filter(question__name__startswith='What')bi uključivao izbore vezane za obrisana pitanja.
Ne filtrirajte nikakve rezultate u ovoj vrsti podklase menadžera

Ovaj menadžer se koristi za pristup objektima koji su povezani sa nekim drugim modelom. U tim situacijama, Django mora biti u stanju da vidi sve objekte za model koji preuzima, tako da se sve na šta se poziva može preuzeti.

Stoga, ne bi trebalo da prevazilazite ovu opciju get_queryset()da biste filtrirali bilo koje redove. Ako to uradite, Django će vratiti nepotpune rezultate.
Pozivanje prilagođenih QuerySetmetoda iz menadžera

Iako je većina metoda iz standarda QuerySetdostupna direktno iz Manager, to je slučaj samo za dodatne metode definisane na prilagođenom okruženju QuerySetako ih implementirate i na Manager:

class PersonQuerySet(models.QuerySet):
    def authors(self):
        return self.filter(role="A")

    def editors(self):
        return self.filter(role="E")


class PersonManager(models.Manager):
    def get_queryset(self):
        return PersonQuerySet(self.model, using=self._db)

    def authors(self):
        return self.get_queryset().authors()

    def editors(self):
        return self.get_queryset().editors()


class Person(models.Model):
    first_name = models.CharField(max_length=50)
    last_name = models.CharField(max_length=50)
    role = models.CharField(max_length=1, choices={"A": _("Author"), "E": _("Editor")})
    people = PersonManager()

Ovaj primer vam omogućava da pozovete i authors()i editors()direktno od menadžera Person.people.
Kreiranje menadžera sa QuerySetmetodama

Umesto gore navedenog pristupa koji zahteva dupliranje metoda i na QuerySeti na Manager, QuerySet.as_manager()može se koristiti za kreiranje instance Managersa kopijom prilagođenih QuerySetmetoda :

class Person(models.Model):
    ...
    people = PersonQuerySet.as_manager()

Instanca Managerkoju kreira QuerySet.as_manager()biće praktično identična onoj PersonManageriz prethodnog primera.

Nema svaka QuerySetmetoda smisla na tom Managernivou; na primer, namerno sprečavamo QuerySet.delete()kopiranje metode na Managerklasu.

Metode se kopiraju prema sledećim pravilima:

    Javne metode se kopiraju podrazumevano.

    Privatne metode (koje počinju podvlakom) se ne kopiraju podrazumevano.

    Metode sa queryset_onlyatributom podešenim na Falsese uvek kopiraju.

    Metode sa queryset_onlyatributom podešenim na se Truenikada ne kopiraju.

Na primer:

class CustomQuerySet(models.QuerySet):
    # Available on both Manager and QuerySet.
    def public_method(self):
        return

    # Available only on QuerySet.
    def _private_method(self):
        return

    # Available only on QuerySet.
    def opted_out_public_method(self):
        return

    opted_out_public_method.queryset_only = True

    # Available on both Manager and QuerySet.
    def _opted_in_private_method(self):
        return

    _opted_in_private_method.queryset_only = False

from_queryset()¶

classmethod from_queryset ( queryset_class )

Za naprednu upotrebu možda ćete želeti i custom Manageri custom QuerySet. To možete učiniti pozivanjem , Manager.from_queryset()koja vraća podklasu vaše baze Managersa kopijom custom QuerySetmetoda:

class CustomManager(models.Manager):
    def manager_only_method(self):
        return


class CustomQuerySet(models.QuerySet):
    def manager_and_queryset_method(self):
        return


class MyModel(models.Model):
    objects = CustomManager.from_queryset(CustomQuerySet)()

Takođe možete sačuvati generisanu klasu u promenljivoj:

MyManager = CustomManager.from_queryset(CustomQuerySet)


class MyModel(models.Model):
    objects = MyManager()

Prilagođeni menadžeri i nasleđivanje modela

Evo kako Django rukuje prilagođenim menadžerima i nasleđivanjem modela :

    Menadžere iz osnovnih klasa uvek nasleđuje podređena klasa, koristeći Pajtonov normalan redosled rezolucije imena (imena u podređenoj klasi nadjačavaju sva ostala; zatim dolaze imena u prvoj roditeljskoj klasi i tako dalje).

    Ako na modelu i/ili njegovim roditeljima nisu deklarisani menadžeri, Django automatski kreira objectsmenadžera.

    Podrazumevani menadžer u klasi je ili onaj izabran sa Meta.default_manager_name, ili prvi menadžer deklarisan na modelu, ili podrazumevani menadžer prvog roditeljskog modela.

Ova pravila pružaju neophodnu fleksibilnost ako želite da instalirate kolekciju prilagođenih menadžera na grupu modela, putem apstraktne osnovne klase, ali i dalje prilagodite podrazumevani menadžer. Na primer, pretpostavimo da imate ovu osnovnu klasu:

class AbstractBase(models.Model):
    # ...
    objects = CustomManager()

    class Meta:
        abstract = True

Ako ovo koristite direktno u podređenoj klasi, objectsbiće podrazumevani menadžer ako ne deklarišete nijedan menadžer u podređenoj klasi:

class ChildA(AbstractBase):
    # ...
    # This class has CustomManager as the default manager.
    pass

Ako želite da nasledite od AbstractBase, ali da obezbedite drugi podrazumevani menadžer, možete da obezbedite podrazumevani menadžer na podređenoj klasi:

class ChildB(AbstractBase):
    # ...
    # An explicit default manager.
    default_manager = OtherManager()

Ovde default_managerje podrazumevana vrednost. objectsMenadžer je i dalje dostupan, jer je nasleđen, ali se ne koristi kao podrazumevana.

Konačno, za ovaj primer, pretpostavimo da želite da dodate dodatne menadžere podređenoj klasi, ali da i dalje koristite podrazumevanu vrednost iz AbstractBase. Ne možete direktno dodati novog menadžera u podređenu klasu, jer bi to poništilo podrazumevanu vrednost i morali biste eksplicitno uključiti sve menadžere iz apstraktne osnovne klase. Rešenje je da se dodatni menadžeri stave u drugu osnovnu klasu i uvedu u hijerarhiju nasleđivanja nakon podrazumevanih vrednosti:

class ExtraManager(models.Model):
    extra_manager = OtherManager()

    class Meta:
        abstract = True


class ChildC(AbstractBase, ExtraManager):
    # ...
    # Default manager is CustomManager, but OtherManager is
    # also available via the "extra_manager" attribute.
    pass

Imajte na umu da, iako možete definisati prilagođeni menadžer na apstraktnom modelu, ne možete pozivati nijednu metodu koristeći apstraktni model. To jest:

ClassA.objects.do_something()

je legalno, ali:

AbstractBase.objects.do_something()

će izazvati izuzetak. To je zato što su menadžeri namenjeni da obuhvate logiku za upravljanje kolekcijama objekata. Pošto ne možete imati kolekciju apstraktnih objekata, nema smisla upravljati njima. Ako imate funkcionalnost koja se primenjuje na apstraktni model, trebalo bi da tu funkcionalnost stavite u staticmethodili classmethodna apstraktni model.
Problemi sa implementacijom

Koje god funkcije da dodate svom prilagođenom Manager, mora biti moguće napraviti plitku kopiju instance Manager; tj. sledeći kod mora da radi:

>>> import copy
>>> manager = MyManager()
>>> my_copy = copy.copy(manager)

DŽango pravi plitke kopije objekata menadžera tokom određenih upita; ako vaš menadžer ne može biti kopiran, ti upiti će biti neuspešni.

Ovo neće biti problem za većinu prilagođenih menadžera. Ako samo dodajete jednostavne metode svom Manager, malo je verovatno da ćete nenamerno učiniti instance vašeg tako Managerda se ne mogu kopirati. Međutim, ako prepisujete __getattr__ili koristite neku drugu privatnu metodu vašeg Managerobjekta koja kontroliše stanje objekta, trebalo bi da se uverite da to ne utiče na mogućnost Managerkopiranja vašeg .

[⚠️ Suspicious Content] Извршавање сирових SQL упита

Django вам нуди два начина за извршавање сирових SQL упита: можете користити Manager.raw()за извршавање сирових упита и враћање инстанци модела , или можете потпуно избећи слој модела и директно извршити прилагођени SQL .

Истражите ORM пре него што почнете да користите сиров SQL!

Django ORM пружа многе алате за изражавање упита без писања сировог SQL-а. На пример:

    QuerySet API је опсежан.

    Можете annotateагрегирати податке користећи многе уграђене функције базе података . Поред тога, можете креирати прилагођене изразе упита .

Пре коришћења сировог SQL-а, истражите ORM . Питајте на једном од канала за подршку да бисте видели да ли ORM подржава ваш случај употребе.

Упозорење

Требало би да будете веома опрезни кад год пишете сирови SQL код. Сваки пут када га користите, требало би да правилно избегнете све параметре које корисник може да контролише помоћу paramsкако бисте се заштитили од SQL инјекција напада. Молимо вас да прочитате више о заштити од SQL инјекција .
Извршавање сирових упита

Метод raw()manager може се користити за извршавање сирових SQL упита који враћају инстанце модела:

Manager.raw ( raw_query , params = ( ) , translations = None )

Ова метода узима сирови SQL упит, извршава га и враћа django.db.models.query.RawQuerySetинстанцу. Ова RawQuerySetинстанца се може итеративно прелазити преко ње као и нормална метода QuerySetда би се обезбедиле инстанце објеката.

Ово је најбоље илустровано примером. Претпоставимо да имате следећи модел:

class Person(models.Model):
    first_name = models.CharField(...)
    last_name = models.CharField(...)
    birth_date = models.DateField(...)

Затим бисте могли да извршите прилагођени SQL овако:

>>> for p in Person.objects.raw("SELECT * FROM myapp_person"):
...     print(p)
...
John Smith
Jane Jones

Овај пример није баш узбудљив – потпуно је исти као и покретање Person.objects.all(). Међутим, raw()има гомилу других опција које га чине веома моћним.

Имена табела модела

Одакле је дошао назив Personтабеле у том примеру?

Подразумевано, Django проналази име табеле базе података спајањем „ознаке апликације“ модела – имена које сте користили у – са именом класе модела, са подвлаком између њих. У примеру смо претпоставили да се модел налази у апликацији под називом , тако да би његова табела била .manage.py startappPersonmyappmyapp_person

За више детаља погледајте документацију за db_tableопцију, која вам такође омогућава да ручно подесите име табеле базе података.

Упозорење

Не врши се никаква провера SQL израза који се прослеђује у .raw(). Django очекује да ће израз вратити скуп редова из базе података, али не ради ништа да то спроведе. Ако упит не врати редове, резултираће (могуће криптичном) грешком.

Упозорење

Ако извршавате упите на MySQL-у, имајте на уму да MySQL-ова тиха примена типова може проузроковати неочекиване резултате при мешању типова. Ако упитујете колону типа стринг, али са целобројном вредношћу, MySQL ће применити типове свих вредности у табели на цео број пре него што изврши поређење. На пример, ако ваша табела садржи вредности 'abc', 'def'а ви упитујете за , оба реда ће се подударати. Да бисте то спречили, извршите исправно претварање типова пре него што употребите вредност у упиту.WHERE mycolumn=0
Мапирање поља упита на поља модела

raw()аутоматски мапира поља у упиту на поља на моделу.

Редослед поља у вашем упиту није важан. Другим речима, оба следећа упита раде идентично:

>>> Person.objects.raw("SELECT id, first_name, last_name, birth_date FROM myapp_person")
>>> Person.objects.raw("SELECT last_name, birth_date, first_name, id FROM myapp_person")

Упаривање се врши по имену. То значи да можете користити SQL ASклаузуле за мапирање поља у упиту на поља модела. Дакле, ако бисте имали неку другу табелу која садржи Personподатке, лако бисте је могли мапирати на Personинстанце:

>>> Person.objects.raw(
...     """
...     SELECT first AS first_name,
...            last AS last_name,
...            bd AS birth_date,
...            pk AS id,
...     FROM some_other_table
...     """
... )

Све док се имена подударају, инстанце модела ће бити правилно креиране.

Алтернативно, можете мапирати поља у упиту на поља модела користећи translationsаргумент raw(). Ово је речник који мапира имена поља у упиту на имена поља на моделу. На пример, горњи упит би се могао написати и као:

>>> name_map = {"first": "first_name", "last": "last_name", "bd": "birth_date", "pk": "id"}
>>> Person.objects.raw("SELECT * FROM some_other_table", translations=name_map)

Претраге индекса

raw()подржава индексирање, тако да ако вам је потребан само први резултат можете написати:

>>> first_person = Person.objects.raw("SELECT * FROM myapp_person")[0]

Међутим, индексирање и сечење се не врше на нивоу базе података. Ако имате велики број Personобјеката у бази података, ефикасније је ограничити упит на нивоу SQL-а:

>>> first_person = Person.objects.raw("SELECT * FROM myapp_person LIMIT 1")[0]

Одлагање поља модела

Поља се такође могу изоставити:

>>> people = Person.objects.raw("SELECT id, first_name FROM myapp_person")

Објекти Personкоје враћа овај упит биће одложене инстанце модела (видети defer()). То значи да ће поља која су изостављена из упита бити учитана по потреби. На пример:

>>> for p in Person.objects.raw("SELECT id, first_name FROM myapp_person"):
...     print(
...         p.first_name,  # This will be retrieved by the original query
...         p.last_name,  # This will be retrieved on demand
...     )
...
John Smith
Jane Jones

Споља гледано, изгледа као да је упит преузео и име и презиме. Међутим, овај пример је заправо издао 3 упита. raw()Упит је преузео само имена – оба презимена су преузета на захтев када су исписана.

Постоји само једно поље које не можете изоставити - поље примарног кључа. Django користи примарни кључ за идентификацију инстанци модела, тако да увек мора бити укључен у сирови упит. FieldDoesNotExistИзузетак ће бити изазван ако заборавите да укључите примарни кључ.
Додавање напомена

Такође можете извршити упите који садрже поља која нису дефинисана у моделу. На пример, могли бисмо да користимо PostgreSQL-ову функцију age() да бисмо добили листу људи са њиховим годинама израчунатим од стране базе података:

>>> people = Person.objects.raw("SELECT *, age(birth_date) AS age FROM myapp_person")
>>> for p in people:
...     print("%s is %s." % (p.first_name, p.age))
...
John is 37.
Jane is 42.
...

Често можете избећи коришћење сировог SQL-а за израчунавање анотација тако што ћете уместо тога користити Func() израз .
Преношење параметара у raw()¶

Ако треба да извршите параметризоване упите, можете користити paramsаргумент да бисте raw():

>>> lname = "Doe"
>>> Person.objects.raw("SELECT * FROM myapp_person WHERE last_name = %s", [lname])

paramsје листа или речник параметара. Користићете %sрезервисана места у стрингу упита за листу или %(key)sрезервисана места за речник (где keyје замењено кључем речника), без обзира на ваш механизам базе података. Таква резервисана места ће бити замењена параметрима из paramsаргумента.

Напомена

Параметри речника нису подржани у SQLite бекенду; са овим бекендом морате проследити параметре као листу.

Упозорење

Не користите форматирање стрингова на сировим упитима или резервисане цитате у вашим SQL стринговима!

Примамљиво је написати горњи упит као:

>>> query = "SELECT * FROM myapp_person WHERE last_name = %s" % lname
>>> Person.objects.raw(query)

Можда бисте такође помислили да би требало да напишете свој упит овако (са наводницима %s):

>>> query = "SELECT * FROM myapp_person WHERE last_name = '%s'"

Не правите ниједну од ових грешака.

Као што је објашњено у заштити од SQL инјекција , коришћење paramsаргумента и остављање резервисаних места без наводника штити вас од напада SQL инјекцијама , уобичајене злоупотребе где нападачи убризгавају произвољни SQL у вашу базу података. Ако користите интерполацију низова или стављате резервисано место под наводнике, постоји ризик од SQL инјекције.
Директно извршавање прилагођеног SQL- а

Понекад чак ни Manager.raw()није сасвим довољно: можда ћете морати да извршите упите који се не мапирају јасно на моделе или директно извршавате UPDATE, INSERT, или DELETEупите.

У овим случајевима, увек можете директно приступити бази података, потпуно заобилазећи слој модела.

Објекат django.db.connectionпредставља подразумевану везу са базом података. Да бисте користили везу са базом података, позовите connection.cursor()да бисте добили објекат курсора. Затим, позовите да бисте извршили SQL и или да бисте вратили резултујуће редове.cursor.execute(sql, [params])cursor.fetchone()cursor.fetchall()

На пример:

from django.db import connection


def my_custom_sql(self):
    with connection.cursor() as cursor:
        cursor.execute("UPDATE bar SET foo = 1 WHERE baz = %s", [self.baz])
        cursor.execute("SELECT foo FROM bar WHERE baz = %s", [self.baz])
        row = cursor.fetchone()

    return row

Да бисте се заштитили од SQL инјекције, не смете стављати наводнике око %sрезервисаних места у SQL стрингу.

Имајте на уму да ако желите да укључите знаке процента у упит, морате их удвостручити у случају да прослеђујете параметре:

cursor.execute("SELECT foo FROM bar WHERE baz = '30%'")
cursor.execute("SELECT foo FROM bar WHERE baz = '30%%' AND id = %s", [self.id])

Ако користите више од једне базе података , можете користити django.db.connectionsда бисте добили везу (и курсор) за одређену базу података. django.db.connectionsје објекат сличан речнику који вам омогућава да преузмете одређену везу користећи њен алиас:

from django.db import connections

with connections["my_db_alias"].cursor() as cursor:
    # Your code here
    ...

Подразумевано, Python DB API ће вратити резултате без имена њихових поља, што значи да ћете на крају добити listвредности a, уместо a dict. Уз мале трошкове перформанси и меморије, можете вратити резултате као a dictкористећи нешто попут овога:

def dictfetchall(cursor):
    """
    Return all rows from a cursor as a dict.
    Assume the column names are unique.
    """
    columns = [col[0] for col in cursor.description]
    return [dict(zip(columns, row)) for row in cursor.fetchall()]

Друга опција је коришћење collections.namedtuple()из стандардне Пајтон библиотеке. А namedtupleје објекат сличан торци који има поља доступна претрагом атрибута; такође је индексабилан и итерабилан. Резултати су непроменљиви и доступни су путем имена поља или индекса, што може бити корисно:

from collections import namedtuple


def namedtuplefetchall(cursor):
    """
    Return all rows from a cursor as a namedtuple.
    Assume the column names are unique.
    """
    desc = cursor.description
    nt_result = namedtuple("Result", [col[0] for col in desc])
    return [nt_result(*row) for row in cursor.fetchall()]

Примери dictfetchall()са и namedtuplefetchall()претпостављају јединствена имена колона, јер курсор не може да разликује колоне из различитих табела.

Ево примера разлике између њих три:

>>> cursor.execute("SELECT id, parent_id FROM test LIMIT 2")
>>> cursor.fetchall()
((54360982, None), (54360880, None))

>>> cursor.execute("SELECT id, parent_id FROM test LIMIT 2")
>>> dictfetchall(cursor)
[{'parent_id': None, 'id': 54360982}, {'parent_id': None, 'id': 54360880}]

>>> cursor.execute("SELECT id, parent_id FROM test LIMIT 2")
>>> results = namedtuplefetchall(cursor)
>>> results
[Result(id=54360982, parent_id=None), Result(id=54360880, parent_id=None)]
>>> results[0].id
54360982
>>> results[0][0]
54360982

Везе и курсори

connectionи cursorуглавном имплементирају стандардни Пајтон DB-API описан уPEP 249 — осим када је у питању руковање трансакцијама .

Ако нисте упознати са Python DB-API-јем, имајте на уму да SQL израз у cursor.execute()користи резервисана места, "%s", уместо да додаје параметре директно унутар SQL-а. Ако користите ову технику, основна библиотека базе података ће аутоматски избегавати ваше параметре по потреби.

Такође имајте на уму да Django очекује "%s"привремени знак, а не привремени "?"знак, који користе SQLite Python повезивања. Ово је ради доследности и разумности.

Коришћење курсора као менаџера контекста:

with connection.cursor() as c:
    c.execute(...)

је еквивалентно:

c = connection.cursor()
try:
    c.execute(...)
finally:
    c.close()

Позивање складиштених процедура

CursorWrapper.callproc ( procname , params = None , kparams = None )​

    Позива складиштену процедуру базе података са датим именом. Може се навести низ ( params) или речник ( kparams) улазних параметара. Већина база података не подржава kparams. Од Django-ових уграђених бекенд-ова, само Oracle га подржава.

    На пример, с обзиром на ову складиштену процедуру у Oracle бази података:

    CREATE PROCEDURE "TEST_PROCEDURE"(v_i INTEGER, v_text NVARCHAR2(10)) AS
        p_i INTEGER;
        p_text NVARCHAR2(10);
    BEGIN
        p_i := v_i;
        p_text := v_text;
        ...
    END;

    Ово ће га назвати:

    with connection.cursor() as cursor:
        cursor.callproc("test_procedure", [1, "test"])

[⚠️ Suspicious Content] 

    Добијање помоћи 

    Језик : ен 

    Верзија документације: 5.2 

Трансакције базе података

Django вам даје неколико начина за контролу начина управљања трансакцијама у бази података.
Управљање трансакцијама базе података
Django-ово подразумевано понашање трансакција

Подразумевано понашање Django-а је да се покреће у режиму аутоматског потврђивања (autocommit). Сваки упит се одмах потврђује у базу података, осим ако је трансакција активна. Више детаља погледајте испод .

Django аутоматски користи трансакције или тачке чувања како би гарантовао интегритет ORM операција које захтевају вишеструке упите, посебно упите delete() и update() .

Џангова TestCaseкласа такође завршава сваки тест у трансакцији из разлога перформанси.
Повезивање трансакција са HTTP захтевима

Уобичајени начин за руковање трансакцијама на вебу је да се сваки захтев умотава у трансакцију. Подесите ATOMIC_REQUESTSна Trueу конфигурацији сваке базе података за коју желите да омогућите ово понашање.

Ради овако. Пре позивања функције приказа (view), Django покреће трансакцију. Ако се одговор генерише без проблема, Django потврђује трансакцију. Ако приказ произведе изузетак, Django враћа трансакцију.

Можете извршити подтрансакције користећи тачке чувања у вашем коду приказа, обично помоћу atomic()менаџера контекста. Међутим, на крају приказа, све или ниједна од промена ће бити сачувана.

Упозорење

Иако је једноставност овог модела трансакција привлачна, она га такође чини неефикасним када се саобраћај повећа. Отварање трансакције за сваки приказ има одређено оптерећење. Утицај на перформансе зависи од образаца упита ваше апликације и од тога колико добро ваша база података обрађује закључавање.

Трансакције по захтеву и стриминг одговори

Када приказ врати StreamingHttpResponse, читање садржаја одговора често ће извршити код за генерисање садржаја. Пошто је приказ већ вратио, такав код се извршава ван трансакције.

Генерално говорећи, није препоручљиво писати у базу података током генерисања стриминг одговора, јер не постоји разуман начин за руковање грешкама након почетка слања одговора.

У пракси, ова функција обухвата сваку функцију приказа у atomic()декоратору описаном у наставку.

Имајте на уму да је само извршавање вашег приказа обухваћено трансакцијама. Мидлвер се покреће изван трансакције, као и рендеровање одговора шаблона.

Када ATOMIC_REQUESTSје омогућено, и даље је могуће спречити покретање прегледа у трансакцији.

non_atomic_requests ( користећи = None ) [извор]

    Овај декоратер ће поништити ефекат ATOMIC_REQUESTSза дати приказ:

    from django.db import transaction


    @transaction.non_atomic_requests
    def my_view(request):
        do_stuff()


    @transaction.non_atomic_requests(using="other")
    def my_other_view(request):
        do_stuff_on_the_other_database()

    Ради само ако се примени на сам приказ.

Експлицитна контрола трансакција

Django пружа јединствени API за контролу трансакција у бази података.

atomic ( коришћење = None , savepoint = True , durable = False ) [извор]

    Атомичност је дефинишуће својство трансакција базе података. atomicОмогућава нам да креирамо блок кода унутар којег је атомичност у бази података загарантована. Ако је блок кода успешно завршен, промене се чувају у бази података. Ако постоји изузетак, промене се враћају.

    atomicБлокови се могу угњежaвати. У овом случају, када се унутрашњи блок успешно заврши, његови ефекти се и даље могу вратити ако се касније појави изузетак у спољашњем блоку.

    Понекад је корисно осигурати да atomicблок увек буде најудаљенији atomicблок, осигуравајући да се све промене у бази података сачувају када се блок изађе без грешака. Ово се назива трајност и може се постићи постављањем durable=True. Ако atomicје блок угнежђен унутар другог блока, он подиже RuntimeError.

    atomicможе се користити и као декоратер :

    from django.db import transaction


    @transaction.atomic
    def viewfunc(request):
        # This code executes inside a transaction.
        do_stuff()

    и као менаџер контекста :

    from django.db import transaction


    def viewfunc(request):
        # This code executes in autocommit mode (Django's default).
        do_stuff()

        with transaction.atomic():
            # This code executes inside a transaction.
            do_more_stuff()

    Умотавање atomicу блок try/except омогућава природно руковање грешкама интегритета:

    from django.db import IntegrityError, transaction


    @transaction.atomic
    def viewfunc(request):
        create_parent()

        try:
            with transaction.atomic():
                generate_relationships()
        except IntegrityError:
            handle_exception()

        add_children()

    У овом примеру, чак и ако generate_relationships()изазива грешку базе података кршењем ограничења интегритета, можете извршити упите у add_children(), а промене из create_parent()су и даље ту и везане за исту трансакцију. Имајте на уму да generate_relationships()ће све операције покушане у већ бити безбедно враћене када handle_exception()се позове, тако да обрађивач изузетака може да ради и на бази података ако је потребно.

    Избегавајте хватање изузетака унутра atomic!

    Приликом изласка из atomicблока, Django проверава да ли је излазак извршен нормално или са изузетком како би утврдио да ли да изврши потврду (commit) или да се врати уназад. Ако хватате и обрађујете изузетке унутар atomicблока, можете сакрити од Django-а чињеницу да се догодио проблем. То може довести до неочекиваног понашања.

    Ово је углавном проблем за DatabaseErrorи његове подкласе као што је IntegrityError. Након такве грешке, трансакција је прекинута и Django ће извршити враћање на претходну вредност на крају блока atomic. Ако покушате да покренете упите базе података пре него што се враћање деси, Django ће подићи изузетак TransactionManagementError. На ово понашање можете наићи и када обрађивач сигнала повезан са ORM-ом подигне изузетак.

    Исправан начин за хватање грешака у бази података је око atomicблока као што је приказано горе. Ако је потребно, додајте додатни atomicблок за ову сврху. Овај образац има још једну предност: експлицитно ограничава које ће операције бити враћене ако се догоди изузетак.

    Ако ухватите изузетке које изазвали сирови SQL упити, понашање Django-а је неодређено и зависи од базе података.

    Можда ћете морати ручно да вратите стање апликације приликом враћања трансакције.

    Вредности поља модела неће бити враћене када се деси враћање трансакције. То може довести до неконзистентног стања модела, осим ако ручно не вратите оригиналне вредности поља.

    На пример, када је дат MyModelса activeпољем, овај исечак осигурава да провера на крају користи исправну вредност ако ажурирање не успе у трансакцији:if obj.activeactiveTrue

    from django.db import DatabaseError, transaction

    obj = MyModel(active=False)
    obj.active = True
    try:
        with transaction.atomic():
            obj.save()
    except DatabaseError:
        obj.active = False

    if obj.active:
        ...

    Ово се такође односи на било који други механизам који може да чува стање апликације, као што су кеширање или глобалне променљиве. На пример, ако код проактивно ажурира податке у кешу након чувања објекта, препоручује се да се уместо тога користи transaction.on_commit() , да би се одложиле измене кеша док се трансакција заиста не потврди (commit).

    Да би се гарантовала атомичност, atomicонемогућава неке API-је. Покушај потврђивања, враћања или промене стања аутоматског потврђивања везе са базом података унутар atomicблока изазваће изузетак.

    atomicузима usingаргумент који треба да буде име базе података. Ако овај аргумент није наведен, Django користи "default"базу података.

    Испод хаубе, Django-ов код за управљање трансакцијама:

        отвара трансакцију при уласку у најудаљенији atomicблок;

        креира тачку чувања при уласку у унутрашњи atomicблок;

        отпушта или се враћа на тачку чувања при изласку из унутрашњег блока;

        потврђује или враћа трансакцију при изласку из најудаљенијег блока.

    Можете онемогућити креирање тачака чувања за унутрашње блокове постављањем savepointаргумента на False. Ако дође до изузетка, Django ће извршити враћање на претходно стање при изласку из првог родитељског блока са тачком чувања ако постоји, а у супротном из најудаљенијег блока. Атомичност је и даље загарантована спољашњом трансакцијом. Ову опцију треба користити само ако је приметно оптерећење тачака чувања. Има ману што нарушава руковање грешкама описано горе.

    Можете користити atomicкада је аутоматско потврђивање искључено. Користиће само тачке чувања, чак и за најудаљенији блок.

Разматрања перформанси

Отворене трансакције имају негативне ефекте на перформансе вашег сервера базе података. Да бисте смањили ово оптерећење, одржавајте трансакције што је могуће краћим. Ово је посебно важно ако користите програм atomic()у дуготрајним процесима, ван Django циклуса захтева/одговора.
Аутоматско потврђивање
Зашто Django користи аутоматско потврђивање

У SQL стандардима, сваки SQL упит покреће трансакцију, осим ако нека већ није активна. Такве трансакције се затим морају експлицитно потврдити (commit) или вратити (rollback).

Ово није увек згодно за програмере апликација. Да би се ублажио овај проблем, већина база података пружа режим аутоматског потврђивања (autocommit). Када је аутоматско потврђивање (autocommit) укључено и ниједна трансакција није активна, сваки SQL упит се обавлачи у сопствену трансакцију. Другим речима, не само да сваки такав упит покреће трансакцију, већ се трансакција аутоматски потврђује (commit) или враћа (return), у зависности од тога да ли је упит успео.

PEP 249 , спецификација Python Database API v2.0, захтева да аутоматско потврђивање (autocommit) буде иницијално искључено. Django поништава ову подразумевану вредност и укључује аутоматско потврђивање (autocommit).

Да бисте то избегли, можете деактивирати управљање трансакцијама , али се то не препоручује.
Деактивирање управљања трансакцијама

Можете потпуно онемогућити Django-ово управљање трансакцијама за дату базу података подешавањем AUTOCOMMITу Falseњеној конфигурацији. Ако то урадите, Django неће омогућити аутоматско потврђивање (autocommit) и неће извршити никаква потврђивања (commit). Добићете уобичајено понашање основне библиотеке базе података.

Ово захтева да експлицитно потврдите сваку трансакцију, чак и оне које је покренуо Django или библиотеке трећих страна. Стога се ово најбоље користи у ситуацијама када желите да покренете сопствени посреднички софтвер за контролу трансакција или да урадите нешто заиста чудно.
Извршавање акција након commit- а

Понекад је потребно да извршите радњу везану за тренутну трансакцију базе података, али само ако се трансакција успешно потврди. Примери могу укључивати позадински задатак, обавештење е-поштом или поништавање кеша.

on_commit()омогућава вам да региструјете повратне позиве који ће се извршити након што је отворена трансакција успешно потврђена:

on_commit ( func , using = None , robust = False ) [извор]

Проследите функцију, или било коју функцију која се може позвати, на on_commit():

from django.db import transaction


def send_welcome_email(): ...


transaction.on_commit(send_welcome_email)

Повратним позивима се неће прослеђивати никакви аргументи, али их можете повезати са functools.partial():

from functools import partial

for user in users:
    transaction.on_commit(partial(send_invite_email, user=user))

Повратни позиви се позивају након што је отворена трансакција успешно потврђена. Ако се трансакција уместо тога врати (обично када се у atomic()блоку појави необрађени изузетак), повратни позив ће бити одбачен и никада неће бити позван.

Ако позовете функцију on_commit()док нема отворене трансакције, повратни позив ће бити извршен одмах.

Понекад је корисно регистровати повратне позиве који могу да не успеју. Преношење robust=Trueомогућава извршавање следећих повратних позива чак и ако тренутни избаци изузетак. Све грешке изведене из Пајтонове Exceptionкласе се хватају и евидентирају у django.db.backends.baseлогер.

Можете користити TestCase.captureOnCommitCallbacks()за тестирање повратних позива регистрованих са on_commit().
Тачке чувања

Тачке чувања (тј. угнежђени atomic()блокови) се правилно обрађују. То јест, on_commit()позивљива функција регистрована након тачке чувања (у угнежђеном atomic()блоку) биће позвана након што се спољашња трансакција потврди, али не ако се током трансакције догодило враћање на ту тачку чувања или било коју претходну тачку чувања:

with transaction.atomic():  # Outer atomic, start a new transaction
    transaction.on_commit(foo)

    with transaction.atomic():  # Inner atomic block, create a savepoint
        transaction.on_commit(bar)

# foo() and then bar() will be called when leaving the outermost block

С друге стране, када се тачка чувања врати уназад (због изузетка), унутрашња позивљива функција се неће позивати:

with transaction.atomic():  # Outer atomic, start a new transaction
    transaction.on_commit(foo)

    try:
        with transaction.atomic():  # Inner atomic block, create a savepoint
            transaction.on_commit(bar)
            raise SomeError()  # Raising an exception - abort the savepoint
    except SomeError:
        pass

# foo() will be called, but not bar()

Редослед извршења

Функције при потврђивању трансакције (on-commit) за дату трансакцију се извршавају редоследом којим су регистроване.
Обрада изузетака

Ако једна on-commit функција регистрована са robust=Falseунутар дате трансакције подигне неухваћен изузетак, ниједна касније регистрована функција у истој трансакцији се неће покренути. Ово је исто понашање као да сте сами извршили функције секвенцијално без on_commit().
Време извршења

Ваши повратни позиви се извршавају након успешног потврђивања извршења, тако да неуспех у повратном позиву неће проузроковати поништавање трансакције. Они се извршавају условно након успеха трансакције, али нису део трансакције. За предвиђене случајеве употребе (обавештења путем е-поште, позадински задаци итд.), ово би требало да буде у реду. Ако није (ако је ваша накнадна акција толико критична да њен неуспех треба да значи неуспех саме трансакције), онда не желите да користите on_commit()куку. Уместо тога, можда ћете желети двофазно потврђивање извршења као што је подршка за протокол Two-Phase Commit од стране psycopg иопционална проширења двофазног извршења у спецификацији Python DB-API .

Повратни позиви се не покрећу док се аутоматско потврђивање (autocommit) не врати на конекцију након потврђивања (јер би у супротном сви упити извршени у повратном позиву отворили имплицитну трансакцију, спречавајући конекцију да се врати у режим аутоматског потврђивања (autocommit).

Када је у режиму аутоматског потврђивања (autocommit) и ван блока atomic(), функција ће се покренути одмах, а не приликом потврђивања (commit).

Функције при потврђивању раде само са режимом аутоматског потврђивања и atomic()(или ATOMIC_REQUESTS) трансакционим API-јем. Позивање on_commit()када је аутоматско потврђивање онемогућено и нисте унутар атомског блока резултираће грешком.
Користи у тестовима

Џангова TestCaseкласа обухвата сваки тест трансакцијом и враћа ту трансакцију након сваког теста, како би се обезбедила изолација теста. То значи да се ниједна трансакција никада заправо не потврђује, па се ваши on_commit()повратни позиви никада неће покренути.

Ово ограничење можете превазићи коришћењем TestCase.captureOnCommitCallbacks(). Ово бележи ваше on_commit()повратне позиве у листу, што вам омогућава да правите тврдње о њима или емулирате извршење трансакције њиховим позивањем.

Други начин да се превазиђе ограничење јесте да се TransactionTestCaseуместо користи TestCase. То ће значити да су ваше трансакције потврђене и да ће се покренути повратни позиви. Међутим, TransactionTestCaseисти празни базу података између тестова, што је знатно спорије него TestCaseизолација `s`.
Зашто нема закачке за враћање уназад?

Ролбек хоок је теже имплементирати робусно него commit хоок, јер разне ствари могу изазвати имплицитни ролбек.

На пример, ако је ваша веза са базом података прекинута зато што је ваш процес заустављен без могућности да се правилно искључи, ваш ролбек се никада неће покренути.

Али постоји решење: уместо да нешто урадите током атомског блока (трансакције), а затим то поништите ако трансакција не успе, користите on_commit()да одложите то извршавање док се трансакција не заврши успешно. Много је лакше поништити нешто што никада нисте урадили!
API-ји ниског нивоа

Упозорење

Увек преферирајте atomic()ако је икако могуће. То узима у обзир особености сваке базе података и спречава неважеће операције.

API-ји ниског нивоа су корисни само ако имплементирате сопствено управљање трансакцијама.
Аутоматско потврђивање

Django пружа API у django.db.transactionмодулу за управљање стањем аутоматског потврђивања сваке везе са базом података.

get_autocommit ( користећи = None ) [извор]

set_autocommit ( autocommit , коришћење = None ) [извор]

Ове функције узимају usingаргумент који треба да буде име базе података. Ако није наведен, Django користи "default"базу података.

Аутоматско потврђивање је првобитно укључено. Ако га искључите, ваша је одговорност да га вратите.

Када искључите аутоматско потврђивање (autocommit), добићете подразумевано понашање вашег адаптера базе података и Django вам неће помоћи. Иако је то понашање наведено уPEP 249 , имплементације адаптера нису увек једна доследне. Пажљиво прегледајте документацију адаптера који користите.

Морате се уверити да ниједна трансакција није активна, обично издавањем commit()или rollback(), пре него што поново укључите аутоматско потврђивање.

Django ће одбити да искључи аутоматско потврђивање (autocommit) када atomic()је блок активан, јер би то нарушило атомичност.
Трансакције

Трансакција је атомски скуп упита базе података. Чак и ако се ваш програм сруши, база података гарантује да ће се или применити све промене или ниједна.

Django не пружа API за покретање трансакције. Очекивани начин за покретање трансакције је онемогућавање аутоматског потврђивања (autocommit) са set_autocommit().

Када сте у трансакцији, можете да изаберете да ли ћете применити измене које сте до сада извршили помоћу commit()или да их откажете помоћу rollback(). Ове функције су дефинисане у django.db.transaction.

commit ( користећи = None ) [source]

враћање уназад ( користећи = None ) [извор]

Ове функције узимају usingаргумент који треба да буде име базе података. Ако није наведен, Django користи "default"базу података.

Django ће одбити да изврши потврду (commit) или враћање (rollback) када atomic()је блок активан, јер би то нарушило атомичност.
Тачке чувања

Тачка чувања је маркер унутар трансакције који вам омогућава да вратите део трансакције, уместо целе трансакције. Тачке чувања су доступне са SQLite, PostgreSQL, Oracle и MySQL (када се користи InnoDB механизам за складиштење). Други бекендови пружају функције тачака чувања, али су то празне операције – оне заправо не раде ништа.

Тачке чувања нису посебно корисне ако користите аутоматско потврђивање (autocommit), подразумевано понашање Django-а. Међутим, када отворите трансакцију са atomic(), градите низ операција у бази података које чекају потврђивање (commit) или враћање на претходно стање (rollback). Ако издате враћање на претходно стање, цела трансакција се враћа на претходно стање. Тачке чувања пружају могућност извршавања детаљног враћања на претходно стање, уместо потпуног враћања на претходно стање које би извршио transaction.rollback().

Када atomic()је декоратор угнежђен, он креира тачку чувања како би омогућио делимично потврђивање измена или враћање измена. Топло вам се препоручује да користите atomic()функције описане у наставку, али оне су и даље део јавног API-ја и не постоји план да се укину.

Свака од ових функција узима usingаргумент који треба да буде име базе података за коју се понашање примењује. Ако није usingнаведен аргумент, онда "default"се користи база података.

Тачке чувања контролишу три функције у django.db.transaction:

тачка чувања ( користећи = None ) [извор]

    Креира нову тачку чувања. Ово означава тачку у трансакцији за коју се зна да је у „добром“ стању. Враћа ИД тачке чувања ( sid).

savepoint_commit ( sid , користећи = None ) [извор]

    Ослобађа тачку чувања sid. Промене извршене од креирања тачке чувања постају део трансакције.

savepoint_rollback ( sid , коришћење = None ) [извор]

    Враћа трансакцију на тачку чувања sid.

Ове функције не раде ништа ако тачке чувања нису подржане или ако је база података у режиму аутоматског потврђивања (automatskog potvrdjivanja).

Поред тога, постоји и корисна функција:

clean_savepoints ( користећи = None ) [извор]

    Ресетује бројач који се користи за генерисање јединствених ИД-ова тачака чувања.

Следећи пример показује употребу тачака чувања:

from django.db import transaction


# open a transaction
@transaction.atomic
def viewfunc(request):
    a.save()
    # transaction now contains a.save()

    sid = transaction.savepoint()

    b.save()
    # transaction now contains a.save() and b.save()

    if want_to_keep_b:
        transaction.savepoint_commit(sid)
        # open transaction still contains a.save() and b.save()
    else:
        transaction.savepoint_rollback(sid)
        # open transaction now contains only a.save()

Тачке чувања могу се користити за опоравак од грешке у бази података извршавањем делимичног враћања на претходно стање. Ако ово радите унутар atomic()блока, цео блок ће и даље бити враћен, јер не зна да сте решили ситуацију на нижем нивоу! Да бисте то спречили, можете контролисати понашање враћања на претходно стање помоћу следећих функција.

get_rollback ( користећи = None ) [извор]

set_rollback ( rollback , користећи = None ) [извор]

Постављање заставице враћања на претходно Trueстање приморава враћање на претходно стање при изласку из најдубљег атомског блока. Ово може бити корисно за покретање враћања на претходно стање без избацивања изузетка.

Постављање на Falseспречава такво враћање уназад. Пре него што то урадите, уверите се да сте вратили трансакцију на познато исправну тачку чувања унутар тренутног атомског блока! У супротном, нарушавате атомичност и може доћи до оштећења података.
Напомене специфичне за базу података
Тачке чувања у SQLite- у

Иако SQLite подржава тачке чувања, мана у дизајну модула sqlite3их чини тешко употребљивим.

Када је аутоматско потврђивање (autocommit) омогућено, тачке чувања немају смисла. Када је онемогућено, sqlite3потврђује се имплицитно пре наредби за тачке чувања. (У ствари, потврђује се пре било које наредбе осим SELECT, INSERT, UPDATE, DELETEи REPLACE.) Ова грешка има две последице:

    API-ји ниског нивоа за тачке чувања могу се користити само унутар трансакције, тј. унутар atomic()блока.

    Немогуће је користити atomic()када је аутоматско потврђивање искључено.

Трансакције у MySQL- у

Ако користите MySQL, ваше табеле могу, али и не морају да подржавају трансакције; то зависи од ваше верзије MySQL-а и типова табела које користите. (Под „типовима табела“ мислимо на нешто попут „InnoDB“ или „MyISAM“.) Посебности MySQL трансакција су ван оквира овог чланка, али MySQL сајт има информације о MySQL трансакцијама .

Ако ваша MySQL поставка не подржава трансакције, онда ће Django увек функционисати у режиму аутоматског потврђивања (autocommit): наредбе ће бити извршене и потврђене чим се позову. Ако ваша MySQL поставка подржава трансакције, Django ће обрадити трансакције као што је објашњено у овом документу.
Обрада изузетака унутар PostgreSQL трансакција

Напомена

Овај одељак је релевантан само ако имплементирате сопствено управљање трансакцијама. Овај проблем се не може појавити у подразумеваном режиму Django-а и atomic()он се аутоматски решава.

Унутар трансакције, када позив PostgreSQL курсора покрене изузетак (обично IntegrityError), сви наредни SQL у истој трансакцији ће бити неуспешни са грешком „тренутна трансакција је прекинута, упити игнорисани до краја блока трансакције“. Иако основна употреба save()вероватно неће покренути изузетак у PostgreSQL-у, постоје напреднији обрасци коришћења који би могли, као што је чување објеката са јединственим пољима, чување помоћу заставице force_insert/ force_updateили позивање прилагођеног SQL-а.

Постоји неколико начина за опоравак од ове врсте грешке.
Враћање трансакције

Прва опција је да се поништи цела трансакција. На пример:

a.save()  # Succeeds, but may be undone by transaction rollback
try:
    b.save()  # Could throw exception
except IntegrityError:
    transaction.rollback()
c.save()  # Succeeds, but a.save() may have been undone

Позивање transaction.rollback()враћа целу трансакцију. Све непотврђене операције базе података биће изгубљене. У овом примеру, промене направљене од стране a.save()би биле изгубљене, иако та операција сама по себи није изазвала грешку.
Враћање на тачку чувања

Можете користити тачке чувања да бисте контролисали обим враћања уназад. Пре него што извршите операцију базе података која би могла да не успе, можете поставити или ажурирати тачку чувања; на тај начин, ако операција не успе, можете вратити једну спорну операцију, уместо целе трансакције. На пример:

a.save()  # Succeeds, and never undone by savepoint rollback
sid = transaction.savepoint()
try:
    b.save()  # Could throw exception
    transaction.savepoint_commit(sid)
except IntegrityError:
    transaction.savepoint_rollback(sid)
c.save()  # Succeeds, and a.save() is never undone

У овом примеру, a.save()неће бити поништено у случају да b.save()се појави изузетак.

[⚠️ Suspicious Content] 

    Dobijanje pomoći 

    Jezik : en 

    Verzija dokumentacije: 5.2 

Više baza podataka

Ovaj vodič opisuje Django-ovu podršku za interakciju sa više baza podataka. Većina ostatka Django-ove dokumentacije pretpostavlja da interagujete sa jednom bazom podataka. Ako želite da interagujete sa više baza podataka, moraćete da preduzmete neke dodatne korake.

Vidi takođe

Pogledajte odeljak Podrška za više baza podataka za informacije o testiranju sa više baza podataka.
Definisanje vaših baza podataka

Prvi korak u korišćenju više od jedne baze podataka sa Django-om jeste da obavestite Django o serverima baza podataka koje ćete koristiti. To se radi pomoću DATABASESpodešavanja . Ovo podešavanje mapira alijase baze podataka, koji su način da se referencira određena baza podataka u Django-u, u rečnik podešavanja za tu specifičnu vezu. Podešavanja u unutrašnjim rečnicima su detaljno opisana u DATABASESdokumentaciji.

Baze podataka mogu imati bilo koji alias koji izaberete. Međutim, alias defaultima posebno značenje. Django koristi bazu podataka sa aliasom defaultkada nije izabrana nijedna druga baza podataka.

Sledi primer settings.pyisečka koji definiše dve baze podataka – podrazumevanu PostgreSQL bazu podataka i MySQL bazu podataka pod nazivom users:

DATABASES = {
    "default": {
        "NAME": "app_data",
        "ENGINE": "django.db.backends.postgresql",
        "USER": "postgres_user",
        "PASSWORD": "s3krit",
    },
    "users": {
        "NAME": "user_data",
        "ENGINE": "django.db.backends.mysql",
        "USER": "mysql_user",
        "PASSWORD": "priv4te",
    },
}

Ako koncept defaultbaze podataka nema smisla u kontekstu vašeg projekta, morate biti pažljivi i uvek navodite bazu podataka koju želite da koristite. Django zahteva da defaultse definiše unos u bazu podataka, ali rečnik parametara može ostati prazan ako se neće koristiti. Da biste to uradili, morate podesiti DATABASE_ROUTERSza sve modele vaših aplikacija, uključujući one u bilo kom contrib-u i aplikacijama trećih strana koje koristite, tako da se nijedan upit ne usmerava ka podrazumevanoj bazi podataka. Sledi primer settings.pyisečka koji definiše dve baze podataka koje nisu podrazumevane, pri čemu defaultje unos namerno ostavljen prazan:

DATABASES = {
    "default": {},
    "users": {
        "NAME": "user_data",
        "ENGINE": "django.db.backends.mysql",
        "USER": "mysql_user",
        "PASSWORD": "superS3cret",
    },
    "customers": {
        "NAME": "customer_data",
        "ENGINE": "django.db.backends.mysql",
        "USER": "mysql_cust",
        "PASSWORD": "veryPriv@ate",
    },
}

Ako pokušate da pristupite bazi podataka koju niste definisali u svojim DATABASESpodešavanjima, Django će izazvati django.utils.connection.ConnectionDoesNotExistizuzetak.
Sinhronizacija vaših baza podataka

Komanda migrateza upravljanje radi samo na jednoj bazi podataka istovremeno. Podrazumevano, radi samo na defaultbazi podataka, ali pružanjem --databaseopcije možete joj reći da sinhronizuje drugu bazu podataka. Dakle, da biste sinhronizovali sve modele na svim bazama podataka u prvom primeru iznad, morali biste pozvati:

$ ./manage.py migrate
$ ./manage.py migrate --database=users

Ako ne želite da svaka aplikacija bude sinhronizovana sa određenom bazom podataka, možete definisati ruter baze podataka koji implementira politiku ograničavanja dostupnosti određenih modela.

Ako ste, kao u drugom primeru iznad, ostavili defaultbazu podataka praznu, morate svaki put kada pokrenete migrate`.` Izostavljanje imena baze podataka bi izazvalo grešku. Za drugi primer:

$ ./manage.py migrate --database=users
$ ./manage.py migrate --database=customers

Korišćenje drugih komandi za upravljanje

Većina ostalih django-adminkomandi koje interaguju sa bazom podataka funkcionišu na isti način kao i migrate– rade samo na jednoj bazi podataka istovremeno, koristeći --databaseza kontrolu korišćene baze podataka.

Izuzetak od ovog pravila je makemigrationskomanda . Ona proverava istoriju migracija u bazama podataka kako bi otkrila probleme sa postojećim datotekama migracije (koji bi mogli biti uzrokovani njihovim uređivanjem) pre kreiranja novih migracija. Podrazumevano, proverava samo defaultbazu podataka, ali konsultuje allow_migrate()metod rutera ako su neki instalirani.
Automatsko rutiranje baze podataka

Najlakši način za korišćenje više baza podataka jeste podešavanje šeme rutiranja baze podataka. Podrazumevana šema rutiranja osigurava da objekti ostanu „vezani“ za svoju originalnu bazu podataka (tj. objekat preuzet iz foobaze podataka biće sačuvan u istoj bazi podataka). Podrazumevana šema rutiranja osigurava da, ako baza podataka nije navedena, svi upiti se vraćaju u defaultbazu podataka.

Ne morate ništa da uradite da biste aktivirali podrazumevanu šemu rutiranja – ona je obezbeđena „odmah po instalaciji“ u svakom Django projektu. Međutim, ako želite da implementirate zanimljivija ponašanja alokacije baze podataka, možete definisati i instalirati sopstvene rutere baze podataka.
Ruteri baze podataka

Ruter baze podataka je klasa koja pruža do četiri metode:

db_for_read ( model , ** nagoveštaji )

    Predložite bazu podataka koja bi trebalo da se koristi za operacije čitanja objekata tipa model.

    Ako operacija baze podataka može da pruži bilo kakve dodatne informacije koje bi mogle pomoći u izboru baze podataka, one će biti date u hintsrečniku. Detalji o validnim savetima dati su u nastavku .

    Vraća Noneako nema predloga.

db_for_write ( model , ** nagoveštaji )

    Predložite bazu podataka koja bi trebalo da se koristi za pisanje objekata tipa Model.

    Ako operacija baze podataka može da pruži bilo kakve dodatne informacije koje bi mogle pomoći u izboru baze podataka, one će biti date u hintsrečniku. Detalji o validnim savetima dati su u nastavku .

    Vraća Noneako nema predloga.

allow_relation ( obj1 , obj2 , ** hints )

    Vrati Trueda li relacija između obj1treba obj2da bude dozvoljena, Falseda li relacija treba da bude sprečena ili Noneako ruter nema mišljenje. Ovo je čisto operacija validacije, koju koriste spoljni ključ i operacije „više prema mnogo“ da bi se utvrdilo da li relacija treba da bude dozvoljena između dva objekta.

    Ako nijedan ruter nema mišljenje (tj. svi ruteri vraćaju None), dozvoljene su samo relacije unutar iste baze podataka.

allow_migrate ( db , app_label , model_name = None , ** hints )

    Utvrdi da li je operaciji migracije dozvoljeno da se pokrene na bazi podataka sa aliasom db. Vrati Trueda li operacija treba da se pokrene, Falseda li ne treba da se pokrene ili Noneda li ruter nema mišljenje.

    Pozicioni app_labelargument je oznaka aplikacije koja se migrira.

    model_namese postavlja većinom operacija migracije na vrednost model._meta.model_name(mala slova navedenog modela __name__) modela koji se migrira. NJegova vrednost je Noneza operacije RunPythoni RunSQL, osim ako je ne daju koristeći naznake.

    hintskoriste se od strane određenih operacija za komunikaciju dodatnih informacija sa ruterom.

    Kada model_nameje podešeno , hintsobično sadrži klasu modela pod ključem 'model'. Imajte na umu da može biti istorijski model , i stoga nema nikakve prilagođene atribute, metode ili menadžere. Trebalo bi da se oslanjate samo na _meta.

    Ova metoda se takođe može koristiti za određivanje dostupnosti modela u datoj bazi podataka.

    makemigrationsuvek kreira migracije za promene modela, ali ako allow_migrate()vrati False, sve operacije migracije za model_nameće biti tiho preskočene prilikom pokretanja migratena db. Promena ponašanja allow_migrate()za modele koji već imaju migracije može dovesti do oštećenih stranih ključeva, dodatnih tabela ili nedostajućih tabela. Kada makemigrationsproverava istoriju migracije, preskače baze podataka gde nijednoj aplikaciji nije dozvoljeno da migrira.

Ruter ne mora da obezbedi sve ove metode – može izostaviti jednu ili više njih. Ako je jedna od metoda izostavljena, Django će preskočiti taj ruter prilikom izvršavanja relevantne provere.
Saveti

Naznake koje ruter baze podataka primi mogu se koristiti za odlučivanje koja baza podataka treba da primi dati zahtev.

Trenutno, jedini nagoveštaj koji će biti dat je instance, instanca objekta koja je povezana sa operacijom čitanja ili pisanja koja je u toku. Ovo može biti instanca koja se čuva ili može biti instanca koja se dodaje u relaciji „više-prema-više“. U nekim slučajevima, nagoveštaj instance uopšte neće biti dat. Ruter proverava postojanje nagoveštaja instance i određuje da li taj nagoveštaj treba koristiti za promenu ponašanja rutiranja.
Korišćenje rutera

Ruteri baze podataka se instaliraju pomoću DATABASE_ROUTERSpodešavanja . Ovo podešavanje definiše listu imena klasa, pri čemu svako određuje ruter koji bi trebalo da koristi osnovni ruter ( django.db.router).

Bazni ruter se koristi od strane Django operacija baze podataka za dodelu korišćenja baze podataka. Kad god upit treba da zna koju bazu podataka da koristi, on poziva bazni ruter, pružajući model i nagoveštaj (ako je dostupan). Bazni ruter isprobava svaku klasu rutera redom dok jedan ne vrati predlog baze podataka. Ako nijedan ruter ne vrati predlog, bazni ruter isprobava trenutnu instance._state.dbinstancu nagoveštaja. Ako nije data instanca nagoveštaja ili instance._state.dbje None, bazni ruter će dodeliti defaultbazu podataka.
Primer

Samo za primer!

Ovaj primer je zamišljen kao demonstracija kako se infrastruktura rutera može koristiti za promenu korišćenja baze podataka. Namerno ignoriše neka složena pitanja kako bi se demonstriralo kako se ruteri koriste.

Ovaj primer neće raditi ako bilo koji od modela myappsadrži veze sa modelima van otherbaze podataka. Veze između baza podataka uvode probleme referencijalnog integriteta koje Django trenutno ne može da reši.

Opisana konfiguracija primarni/replika (koju neke baze podataka nazivaju master/rob) je takođe manjkava – ne pruža nikakvo rešenje za rukovanje kašnjenjem replikacije (tj. nedoslednosti upita nastale zbog vremena potrebnog da se pisanje proširi na replike). Takođe ne uzima u obzir interakciju transakcija sa strategijom korišćenja baze podataka.

Dakle - šta ovo znači u praksi? Hajde da razmotrimo još jedan primer konfiguracije. Ovaj će imati nekoliko baza podataka: jednu za authaplikaciju, a sve ostale aplikacije će koristiti primarnu/repličnu postavku sa dve replike za čitanje. Evo podešavanja koja određuju ove baze podataka:

DATABASES = {
    "default": {},
    "auth_db": {
        "NAME": "auth_db_name",
        "ENGINE": "django.db.backends.mysql",
        "USER": "mysql_user",
        "PASSWORD": "swordfish",
    },
    "primary": {
        "NAME": "primary_name",
        "ENGINE": "django.db.backends.mysql",
        "USER": "mysql_user",
        "PASSWORD": "spam",
    },
    "replica1": {
        "NAME": "replica1_name",
        "ENGINE": "django.db.backends.mysql",
        "USER": "mysql_user",
        "PASSWORD": "eggs",
    },
    "replica2": {
        "NAME": "replica2_name",
        "ENGINE": "django.db.backends.mysql",
        "USER": "mysql_user",
        "PASSWORD": "bacon",
    },
}

Sada ćemo morati da se pozabavimo rutiranjem. Prvo nam je potreban ruter koji zna da šalje upite za authi contenttypesaplikacije na auth_db( authmodeli su povezani sa ContentType, tako da moraju biti sačuvani u istoj bazi podataka):

class AuthRouter:
    """
    A router to control all database operations on models in the
    auth and contenttypes applications.
    """

    route_app_labels = {"auth", "contenttypes"}

    def db_for_read(self, model, **hints):
        """
        Attempts to read auth and contenttypes models go to auth_db.
        """
        if model._meta.app_label in self.route_app_labels:
            return "auth_db"
        return None

    def db_for_write(self, model, **hints):
        """
        Attempts to write auth and contenttypes models go to auth_db.
        """
        if model._meta.app_label in self.route_app_labels:
            return "auth_db"
        return None

    def allow_relation(self, obj1, obj2, **hints):
        """
        Allow relations if a model in the auth or contenttypes apps is
        involved.
        """
        if (
            obj1._meta.app_label in self.route_app_labels
            or obj2._meta.app_label in self.route_app_labels
        ):
            return True
        return None

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        """
        Make sure the auth and contenttypes apps only appear in the
        'auth_db' database.
        """
        if app_label in self.route_app_labels:
            return db == "auth_db"
        return None

Takođe želimo ruter koji šalje sve ostale aplikacije u primarnu/repličnu konfiguraciju i nasumično bira repliku sa koje će čitati:

import random


class PrimaryReplicaRouter:
    def db_for_read(self, model, **hints):
        """
        Reads go to a randomly-chosen replica.
        """
        return random.choice(["replica1", "replica2"])

    def db_for_write(self, model, **hints):
        """
        Writes always go to primary.
        """
        return "primary"

    def allow_relation(self, obj1, obj2, **hints):
        """
        Relations between objects are allowed if both objects are
        in the primary/replica pool.
        """
        db_set = {"primary", "replica1", "replica2"}
        if obj1._state.db in db_set and obj2._state.db in db_set:
            return True
        return None

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        """
        All non-auth models end up in this pool.
        """
        return True

Konačno, u datoteci podešavanja dodajemo sledeće (zamenjujući path.to.stvarnom Pajton putanjom do modula(a) gde su definisani ruteri):

DATABASE_ROUTERS = ["path.to.AuthRouter", "path.to.PrimaryReplicaRouter"]

Redosled kojim se ruteri obrađuju je značajan. Ruteri će biti upitivani redosledom kojim su navedeni u podešavanju DATABASE_ROUTERS. U ovom primeru, AuthRouterse obrađuje pre PrimaryReplicaRouter, i kao rezultat toga, odluke koje se tiču modela u authse obrađuju pre nego što se donese bilo koja druga odluka. Ako je DATABASE_ROUTERSpodešavanje navelo dva rutera drugim redosledom, PrimaryReplicaRouter.allow_migrate()bi se prvo obradio. Priroda sveobuhvatnosti implementacije PrimaryReplicaRouter značila bi da bi svi modeli bili dostupni u svim bazama podataka.

Nakon što je ova postavka instalirana i sve baze podataka migrirane kao što je opisano u odeljku Sinhronizacija baza podataka , pokrenimo Django kod:

>>> # This retrieval will be performed on the 'auth_db' database
>>> fred = User.objects.get(username="fred")
>>> fred.first_name = "Frederick"

>>> # This save will also be directed to 'auth_db'
>>> fred.save()

>>> # These retrieval will be randomly allocated to a replica database
>>> dna = Person.objects.get(name="Douglas Adams")

>>> # A new object has no database allocation when created
>>> mh = Book(title="Mostly Harmless")

>>> # This assignment will consult the router, and set mh onto
>>> # the same database as the author object
>>> mh.author = dna

>>> # This save will force the 'mh' instance onto the primary database...
>>> mh.save()

>>> # ... but if we re-retrieve the object, it will come back on a replica
>>> mh = Book.objects.get(title="Mostly Harmless")

Ovaj primer je definisao ruter za rukovanje interakcijom sa modelima iz authaplikacije i druge rutere za rukovanje interakcijom sa svim ostalim aplikacijama. Ako ste ostavili defaultbazu podataka praznu i ne želite da definišete ruter baze podataka koji obuhvata sve aplikacije koje nisu drugačije navedene, vaši ruteri moraju da obrade imena svih aplikacija INSTALLED_APPSpre nego što migrirate. Pogledajte Ponašanje aplikacija za doprinos za informacije o aplikacijama za doprinos koje moraju biti zajedno u jednoj bazi podataka.
Ručno biranje baze podataka

Django takođe pruža API koji vam omogućava da zadržite potpunu kontrolu nad korišćenjem baze podataka u vašem kodu. Ručno određena alokacija baze podataka imaće prioritet nad bazom podataka koju je dodelio ruter.
Ručno biranje baze podataka za QuerySet¶

Možete odabrati bazu podataka za QuerySetu bilo kojoj tački u QuerySet„lancu“. Pozovite using()da QuerySetbiste dobili drugu QuerySetkoja koristi navedenu bazu podataka.

using()prima jedan argument: alias baze podataka na kojoj želite da pokrenete upit. Na primer:

>>> # This will run on the 'default' database.
>>> Author.objects.all()

>>> # So will this.
>>> Author.objects.using("default")

>>> # This will run on the 'other' database.
>>> Author.objects.using("other")

Izbor baze podataka za save()¶

Koristite usingključnu reč „to“ Model.save()da biste naveli u koju bazu podataka treba sačuvati podatke.

Na primer, da biste sačuvali objekat u legacy_usersbazi podataka, koristili biste ovo:

>>> my_object.save(using="legacy_users")

Ako ne navedete using, save()metoda će sačuvati u podrazumevanu bazu podataka koju su dodelili ruteri.
Premeštanje objekta iz jedne baze podataka u drugu

Ako ste sačuvali instancu u jednoj bazi podataka, možda bi bilo primamljivo da je koristite save(using=...)kao način za migraciju instance u novu bazu podataka. Međutim, ako ne preduzmete odgovarajuće korake, ovo bi moglo imati neke neočekivane posledice.

Razmotrite sledeći primer:

>>> p = Person(name="Fred")
>>> p.save(using="first")  # (statement 1)
>>> p.save(using="second")  # (statement 2)

U prvoj naredbi, novi Personobjekat se čuva u firstbazi podataka. U ovom trenutku, pnema primarni ključ, pa Django izdaje SQL INSERTnaredbu. Ovo kreira primarni ključ, a Django dodeljuje taj primarni ključ objektu p.

Kada se čuvanje desi u naredbi 2, pveć ima vrednost primarnog ključa i Django će pokušati da koristi taj primarni ključ na novoj bazi podataka. Ako vrednost primarnog ključa nije u upotrebi u secondbazi podataka, onda nećete imati nikakvih problema – objekat će biti kopiran u novu bazu podataka.

Međutim, ako je primarni ključ pveć u upotrebi u secondbazi podataka, postojeći objekat u secondbazi podataka će biti zamenjen kada pse sačuva.

Ovo možete izbeći na dva načina. Prvo, možete obrisati primarni ključ instance. Ako objekat nema primarni ključ, Django će ga tretirati kao novi objekat, izbegavajući gubitak podataka u secondbazi podataka:

>>> p = Person(name="Fred")
>>> p.save(using="first")
>>> p.pk = None  # Clear the primary key.
>>> p.save(using="second")  # Write a completely new object.

Druga opcija je korišćenje force_insertopcije kako bi save()se osiguralo da Django izvrši SQL INSERT:

>>> p = Person(name="Fred")
>>> p.save(using="first")
>>> p.save(using="second", force_insert=True)

Ovo će osigurati da će imenovana osoba Fredimati isti primarni ključ u obe baze podataka. Ako se taj primarni ključ već koristi kada pokušate da sačuvate podatke u secondbazi podataka, pojaviće se greška.
Izbor baze podataka za brisanje

Podrazumevano, poziv za brisanje postojećeg objekta biće izvršen na istoj bazi podataka koja je korišćena za prvobitno preuzimanje objekta:

>>> u = User.objects.using("legacy_users").get(username="fred")
>>> u.delete()  # will delete from the `legacy_users` database

Da biste odredili bazu podataka iz koje će model biti obrisan, prosledite usingključni argument metodi Model.delete(). Ovaj argument funkcioniše isto kao i usingključni argument metodi save().

Na primer, ako migrirate korisnika iz legacy_usersbaze podataka u new_usersbazu podataka, možete koristiti ove komande:

>>> user_obj.save(using="new_users")
>>> user_obj.delete(using="legacy_users")

Korišćenje menadžera sa više baza podataka

Koristite db_manager()metodu na menadžerima da biste menadžerima dali pristup bazi podataka koja nije podrazumevana.

Na primer, recimo da imate prilagođenu metodu menadžera koja dodiruje bazu podataka – User.objects.create_user(). Pošto create_user()je metoda menadžera, a ne QuerySetmetoda, ne možete da uradite User.objects.using('new_users').create_user(). ( create_user()Metoda je dostupna samo na User.objects, menadžeru, a ne na QuerySetobjektima izvedenim iz menadžera.) Rešenje je da koristite db_manager(), ovako:

User.objects.db_manager("new_users").create_user(...)

db_manager()vraća kopiju menadžera vezanog za bazu podataka koju navedete.
Korišćenje get_queryset()sa više baza podataka

Ako vršite prepisivanje get_queryset()na svom menadžeru, obavezno pozovite metodu na roditelju (koristeći super()) ili izvršite odgovarajuću obradu atributa _dbna menadžeru (string koji sadrži ime baze podataka koju treba koristiti).

Na primer, ako želite da vratite prilagođenu QuerySetklasu iz get_querysetmetode, možete to učiniti:

class MyManager(models.Manager):
    def get_queryset(self):
        qs = CustomQuerySet(self.model)
        if self._db is not None:
            qs = qs.using(self._db)
        return qs

Prikazivanje više baza podataka u administratorskom interfejsu Django-a

Django-ov administratorski interfejs nema eksplicitnu podršku za više baza podataka. Ako želite da obezbedite administratorski interfejs za model na bazi podataka koja nije ona koju navodi vaš lanac rutera, moraćete da napišete prilagođene ModelAdminklase koje će usmeriti administratora da koristi određenu bazu podataka za sadržaj.

ModelAdminobjekti imaju sledeće metode koje zahtevaju prilagođavanje za podršku više baza podataka:

class MultiDBModelAdmin(admin.ModelAdmin):
    # A handy constant for the name of the alternate database.
    using = "other"

    def save_model(self, request, obj, form, change):
        # Tell Django to save objects to the 'other' database.
        obj.save(using=self.using)

    def delete_model(self, request, obj):
        # Tell Django to delete objects from the 'other' database
        obj.delete(using=self.using)

    def get_queryset(self, request):
        # Tell Django to look for objects on the 'other' database.
        return super().get_queryset(request).using(self.using)

    def formfield_for_foreignkey(self, db_field, request, **kwargs):
        # Tell Django to populate ForeignKey widgets using a query
        # on the 'other' database.
        return super().formfield_for_foreignkey(
            db_field, request, using=self.using, **kwargs
        )

    def formfield_for_manytomany(self, db_field, request, **kwargs):
        # Tell Django to populate ManyToMany widgets using a query
        # on the 'other' database.
        return super().formfield_for_manytomany(
            db_field, request, using=self.using, **kwargs
        )

Implementacija koja je ovde data implementira strategiju više baza podataka gde se svi objekti datog tipa čuvaju u određenoj bazi podataka (npr. svi Userobjekti su u otherbazi podataka). Ako je vaše korišćenje više baza podataka složenije, ModelAdminmoraćete da odrazite tu strategiju.

InlineModelAdminobjekti se mogu obraditi na sličan način. Potrebne su im tri prilagođene metode:

class MultiDBTabularInline(admin.TabularInline):
    using = "other"

    def get_queryset(self, request):
        # Tell Django to look for inline objects on the 'other' database.
        return super().get_queryset(request).using(self.using)

    def formfield_for_foreignkey(self, db_field, request, **kwargs):
        # Tell Django to populate ForeignKey widgets using a query
        # on the 'other' database.
        return super().formfield_for_foreignkey(
            db_field, request, using=self.using, **kwargs
        )

    def formfield_for_manytomany(self, db_field, request, **kwargs):
        # Tell Django to populate ManyToMany widgets using a query
        # on the 'other' database.
        return super().formfield_for_manytomany(
            db_field, request, using=self.using, **kwargs
        )

Kada napišete definicije administratora modela, one se mogu registrovati sa bilo kojom Admininstancom:

from django.contrib import admin
from myapp.models import Author, Book, Publisher

# Import our custom ModelAdmin and TabularInline from where they're defined.
from myproject.admin import MultiDBModelAdmin, MultiDBTabularInline


# Specialize the multi-db admin objects for use with specific models.
class BookInline(MultiDBTabularInline):
    model = Book


class PublisherAdmin(MultiDBModelAdmin):
    inlines = [BookInline]


admin.site.register(Author, MultiDBModelAdmin)
admin.site.register(Publisher, PublisherAdmin)

othersite = admin.AdminSite("othersite")
othersite.register(Publisher, MultiDBModelAdmin)

Ovaj primer podešava dve administratorske stranice. Na prvoj stranici su izloženi objekti Authori ; objekti imaju tabelarni ugrađeni prikaz knjiga koje je objavio taj izdavač. Druga stranica prikazuje samo izdavače, bez ugrađenih stranica.PublisherPublisher
Korišćenje sirovih kursora sa više baza podataka

Ako koristite više od jedne baze podataka, možete koristiti django.db.connectionsda biste dobili vezu (i kursor) za određenu bazu podataka. django.db.connectionsje objekat sličan rečniku koji vam omogućava da preuzmete određenu vezu koristeći njen alias:

from django.db import connections

with connections["my_db_alias"].cursor() as cursor:
    ...

Ograničenja višestrukih baza podataka
Međubazne relacije

Django trenutno ne pruža nikakvu podršku za spoljni ključ ili odnose „više-prema-više“ koji obuhvataju više baza podataka. Ako ste koristili ruter za particionisanje modela na različite baze podataka, svaki spoljni ključ i odnosi „više-prema-više“ definisani tim modelima moraju biti interni u jednoj bazi podataka.

To je zbog referencijalnog integriteta. Da bi se održao odnos između dva objekta, Django mora da zna da je primarni ključ povezanog objekta validan. Ako je primarni ključ sačuvan u posebnoj bazi podataka, nije moguće lako proceniti validnost primarnog ključa.

Ako koristite Postgres, SQLite, Oracle ili MySQL sa InnoDB-om, ovo se sprovodi na nivou integriteta baze podataka – ograničenja ključeva na nivou baze podataka sprečavaju kreiranje relacija koje se ne mogu validirati.

Međutim, ako koristite MySQL sa MyISAM tabelama, ne postoji obavezni referencijalni integritet; kao rezultat toga, možda ćete moći da „lažirate“ strane ključeve iz različitih baza podataka. Međutim, Django zvanično ne podržava ovu konfiguraciju.
Ponašanje aplikacija za doprinos

Nekoliko aplikacija za doprinos uključuju modele, a neke aplikacije zavise od drugih. Pošto su veze između baza podataka nemoguće, ovo stvara neka ograničenja u načinu na koji možete podeliti ove modele između baza podataka:

    svaki od contenttypes.ContentType, sessions.Sessioni sites.Sitemože se sačuvati u bilo kojoj bazi podataka, uz odgovarajući ruter.

    authModeli — User, Groupi Permission— su povezani zajedno i povezani sa ContentType, tako da moraju biti sačuvani u istoj bazi podataka kao i ContentType.

    adminzavisi od auth, tako da njegovi modeli moraju biti u istoj bazi podataka kao i auth.

    flatpagesi redirectszavise od sites, tako da njihovi modeli moraju biti u istoj bazi podataka kao i sites.

Pored toga, neki objekti se automatski kreiraju odmah nakon migratekreiranja tabele koja ih čuva u bazi podataka:

    podrazumevano Site,

    za ContentTypesvaki model (uključujući i one koji nisu sačuvani u toj bazi podataka),

    s Permissionza svaki model (uključujući i one koji nisu sačuvani u toj bazi podataka).

Za uobičajena podešavanja sa više baza podataka, nije korisno imati ove objekte u više od jedne baze podataka. Uobičajena podešavanja uključuju primarnu/repliku i povezivanje sa eksternim bazama podataka. Stoga se preporučuje pisanje rutera baze podataka koji omogućava sinhronizaciju ova tri modela samo sa jednom bazom podataka. Koristite isti pristup za contrib i aplikacije trećih strana kojima nisu potrebne tabele u više baza podataka.

Upozorenje

Ako sinhronizujete tipove sadržaja sa više baza podataka, imajte na umu da se njihovi primarni ključevi možda neće podudarati u različitim bazama podataka. To može dovesti do oštećenja ili gubitka podataka.



    Dobijanje pomoći 

    Jezik : en 

    Verzija dokumentacije: 5.2 

Tabelarni prostori

Uobičajena paradigma za optimizaciju performansi u sistemima baza podataka je korišćenje tabličnih prostora za organizovanje rasporeda diska.

Upozorenje

Django ne kreira tabelarne prostore umesto vas. Molimo pogledajte dokumentaciju vašeg sistema za bazu podataka za detalje o kreiranju i upravljanju tabelarnim prostorima.
Deklarisanje tabelarnih prostora za tabele

Tablični prostor može biti naveden za tabelu koju generiše model navođenjem db_tablespaceopcije unutar modela . Ova opcija takođe utiče na tabele koje se automatski kreiraju za s u modelu.class MetaManyToManyField

Možete koristiti DEFAULT_TABLESPACEpodešavanje da biste odredili podrazumevanu vrednost za db_tablespace. Ovo je korisno za podešavanje tabličnog prostora za ugrađene Django aplikacije i druge aplikacije čiji kod ne možete da kontrolišete.
Deklarisanje tabelarnih prostora za indekse

Možete proslediti db_tablespaceopciju konstruktoru Indexda biste naveli ime tabelarnog prostora koji će se koristiti za indeks. Za indekse sa jednim poljem, možete proslediti db_tablespaceopciju konstruktoru Fieldda biste naveli alternativni tabelarni prostor za indeks kolone polja. Ako kolona nema indeks, opcija se ignoriše.

Možete koristiti DEFAULT_INDEX_TABLESPACEpodešavanje da biste odredili podrazumevanu vrednost za db_tablespace.

Ako db_tablespacenije navedeno i niste podesili DEFAULT_INDEX_TABLESPACE, indeks se kreira u istom tabelarnom prostoru kao i tabele.
Primer

class TablespaceExample(models.Model):
    name = models.CharField(max_length=30, db_index=True, db_tablespace="indexes")
    data = models.CharField(max_length=255, db_index=True)
    shortcut = models.CharField(max_length=7)
    edges = models.ManyToManyField(to="self", db_tablespace="indexes")

    class Meta:
        db_tablespace = "tables"
        indexes = [models.Index(fields=["shortcut"], db_tablespace="other_indexes")]

U ovom primeru, tabele koje generiše TablespaceExamplemodel (tj. tabela modela i tabela „više-prema-više“) bi bile sačuvane u tablestabelarnom prostoru. Indeks za polje sa imenom i indeksi na tabeli „više-prema-više“ bi bili sačuvani u indexestabelarnom prostoru. dataPolje bi takođe generisalo indeks, ali za njega nije naveden tabelarni prostor, pa bi podrazumevano bilo sačuvano u tabelarnom prostoru modela tables. Indeks za shortcutpolje bi bio sačuvan u other_indexestabelarnom prostoru.
Podrška za baze podataka

PostgreSQL i Oracle podržavaju tabelarne prostore. SQLite, MariaDB i MySQL ih ne podržavaju.

Kada koristite bekend koji nema podršku za tablespace-ove, Django ignoriše sve opcije vezane za tablespace.

[⚠️ Suspicious Content] Optimizacija pristupa bazi podataka

DŽangoov sloj baze podataka pruža razne načine da pomogne programerima da izvuku maksimum iz svojih baza podataka. Ovaj dokument okuplja veze do relevantne dokumentacije i dodaje razne savete, organizovane pod nekoliko naslova koji opisuju korake koje treba preduzeti kada pokušavate da optimizujete korišćenje baze podataka.
Prvo profil

Kao opšta programska praksa, ovo se podrazumeva. Saznajte koje upite radite i koliko vas koštaju . Koristite da biste razumeli kako vaša baza podataka izvršava QuerySet.explain()određene upite. Možda ćete želeti da koristite i eksterni projekat poput django-debug-toolbar -a ili alat koji direktno prati vašu bazu podataka.QuerySet

Zapamtite da možete optimizovati brzinu ili memoriju ili oboje, u zavisnosti od vaših zahteva. Ponekad će optimizacija za jedno biti štetna za drugo, ali ponekad će se međusobno pomoći. Takođe, posao koji obavlja proces baze podataka možda neće imati istu cenu (za vas) kao ista količina posla obavljena u vašem Pajton procesu. Na vama je da odlučite koji su vaši prioriteti, gde mora biti ravnoteža i da profilišete sve ovo po potrebi, jer će to zavisiti od vaše aplikacije i servera.

Uz sve što sledi, ne zaboravite da napravite profil nakon svake promene kako biste bili sigurni da je promena korisna, i dovoljno velika s obzirom na smanjenje čitljivosti vašeg koda. Svi dole navedeni predlozi dolaze uz napomenu da se u vašim okolnostima opšti princip možda neće primeniti ili čak može biti obrnut.
Koristite standardne tehnike optimizacije baze podataka

...uključujući:

    Indeksi . Ovo je prioritet broj jedan, nakon što ste iz profilisanja utvrdili koje indekse treba dodati. Koristite Meta.indexesili Field.db_indexda biste ih dodali iz Django-a. Razmislite o dodavanju indeksa poljima koja često upitujete koristeći filter(), exclude(), order_by(), itd., jer indeksi mogu pomoći u ubrzavanju pretrage. Imajte na umu da je određivanje najboljih indeksa složena tema koja zavisi od baze podataka i vaše konkretne aplikacije. Troškovi održavanja indeksa mogu nadmašiti bilo kakve dobitke u brzini upita.

    Odgovarajuća upotreba tipova polja.

Pretpostavićemo da ste uradili gore navedene stvari. Ostatak ovog dokumenta fokusira se na to kako da koristite Django na takav način da ne obavljate nepotreban posao. Ovaj dokument se takođe ne bavi drugim tehnikama optimizacije koje se primenjuju na sve skupe operacije, kao što je keširanje opšte namene .
Razumeti QuerySet¶​

Razumevanje QuerySets -ova je ključno za postizanje dobrih performansi sa jednostavnim kodom. Konkretno:
Razumevanje QuerySetevaluacije

Da biste izbegli probleme sa performansama, važno je razumeti:

    da su QuerySets-ovi lenji .

    kada se ocenjuju .

    kako se podaci čuvaju u memoriji .

Razumevanje keširanih atributa

Pored keširanja celog QuerySet, postoji i keširanje rezultata atributa na ORM objektima. Generalno, atributi koji se ne mogu pozvati biće keširani. Na primer, pod pretpostavkom da su primerni modeli bloga :

>>> entry = Entry.objects.get(id=1)
>>> entry.blog  # Blog object is retrieved at this point
>>> entry.blog  # cached version, no DB access

Ali generalno, pozivajući atributi svaki put izazivaju pretrage baze podataka:

>>> entry = Entry.objects.get(id=1)
>>> entry.authors.all()  # query performed
>>> entry.authors.all()  # query performed again

Budite oprezni pri čitanju koda šablona - sistem šablona ne dozvoljava upotrebu zagrada, već će automatski pozivati pozivajuće elemente, skrivajući gore navedenu razliku.

Budite pažljivi sa sopstvenim prilagođenim svojstvima - na vama je da implementirate keširanje kada je potrebno, na primer koristeći cached_propertydekorator.
Koristite withoznaku šablona

Da biste koristili ponašanje keširanja od QuerySet, možda ćete morati da koristite withoznaku šablona.
Koristite iterator()¶

Kada imate mnogo objekata, keširanje QuerySetmože prouzrokovati korišćenje velike količine memorije. U ovom slučaju, iterator()može pomoći.
Koristite explain()¶

QuerySet.explain()daje vam detaljne informacije o tome kako baza podataka izvršava upit, uključujući indekse i spajanja koja se koriste. Ovi detalji vam mogu pomoći da pronađete upite koji bi se mogli efikasnije prepisati ili da identifikujete indekse koji bi se mogli dodati radi poboljšanja performansi.
Da li radite sa bazom podataka u bazi podataka umesto u Pajtonu

Na primer:

    Na najosnovnijem nivou, koristite filter i isključenje za filtriranje u bazi podataka.

    Koristite za filtriranje na osnovu drugih polja unutar istog modela.F expressions

    Koristite anotaciju za agregaciju u bazi podataka .

Ako ovo nije dovoljno za generisanje SQL-a koji vam je potreban:
Koristite RawSQL¶

Manje prenosiva, ali moćnija metoda je RawSQLizraz, koji omogućava eksplicitno dodavanje SQL koda upitu. Ako to i dalje nije dovoljno moćno:
Koristite sirovi SQL

Napišite sopstveni prilagođeni SQL za preuzimanje podataka ili popunjavanje modela . Koristite ga django.db.connection.queriesda biste saznali šta Django piše za vas i počnite odatle.
Preuzmite pojedinačne objekte koristeći jedinstvenu, indeksiranu kolonu

Postoje dva razloga za korišćenje kolone sa uniqueili db_indexkada se koristi get()za preuzimanje pojedinačnih objekata. Prvo, upit će biti brži zbog osnovnog indeksa baze podataka. Takođe, upit bi mogao da se izvršava mnogo sporije ako se više objekata podudara sa pretragom; jedinstveno ograničenje na koloni garantuje da se to nikada neće dogoditi.

Dakle, koristeći primere modela bloga :

>>> entry = Entry.objects.get(id=10)

biće brže nego:

>>> entry = Entry.objects.get(headline="News Item Title")

jer idje indeksiran od strane baze podataka i garantovano je jedinstven.

Obavljanje sledećeg je potencijalno prilično sporo:

>>> entry = Entry.objects.get(headline__startswith="News")

Pre svega, headlinenije indeksirano, što će usporiti preuzimanje osnovne baze podataka.

Drugo, pretraga ne garantuje da će biti vraćen samo jedan objekat. Ako upit odgovara više od jednog objekta, preuzeće i preneti sve iz baze podataka. Ova kazna može biti značajna ako se vrate stotine ili hiljade zapisa. Kazna će biti još veća ako se baza podataka nalazi na posebnom serveru, gde opterećenje mreže i latencija takođe igraju ulogu.
Preuzmite sve odjednom ako znate da će vam trebati

Višestruko pretraživanje baze podataka za različite delove jednog „skupa“ podataka čiji će vam svi delovi biti potrebni je, generalno, manje efikasno nego preuzimanje svih podataka u jednom upitu. Ovo je posebno važno ako imate upit koji se izvršava u petlji i stoga bi mogao da završi sa mnoštvom upita baze podataka, kada je potreban samo jedan. Dakle:
Koristite QuerySet.select_related()i prefetch_related()¶

Razumeti select_related()i prefetch_related()temeljno ih koristiti:

    u menadžerima i podrazumevanim menadžerima gde je to prikladno. Budite svesni kada se vaš menadžer koristi, a kada se ne; ponekad je ovo teško, zato nemojte praviti pretpostavke.

    u kodu prikaza ili drugim slojevima, eventualno koristeći prefetch_related_objects()gde je potrebno.

Ne vraćajte stvari koje vam ne trebaju
Koristite QuerySet.values()i values_list()¶

Kada želite samo vrednosti tipa ` dictor` listi ne trebaju vam objekti ORM modela, koristite `na odgovarajući način` values(). Ovo može biti korisno za zamenu objekata modela u kodu šablona - sve dok reči koje navedete imaju iste atribute kao oni koji se koriste u šablonu, sve je u redu.
Koristite QuerySet.defer()i only()¶

Koristite defer()i only()ako postoje kolone baze podataka za koje znate da vam neće biti potrebne (ili vam neće biti potrebne u većini slučajeva) da biste izbegli njihovo učitavanje. Imajte na umu da ako ih koristite , ORM će morati da ih preuzme u posebnom upitu, što ovo čini pesimizacijom ako ga koristite neodgovarajuće.

Nemojte biti previše agresivni u odlaganju polja bez profilisanja jer baza podataka mora da pročita većinu netekstualnih VARCHARpodataka sa diska za jedan red u rezultatima, čak i ako na kraju koristi samo nekoliko kolona. Metode defer()i only()su najkorisnije kada možete da izbegnete učitavanje velike količine tekstualnih podataka ili za polja čija bi konverzija nazad u Pajton mogla zahtevati mnogo obrade. Kao i uvek, prvo profilišite, pa optimizujte.
Koristite QuerySet.contains(obj)¶

...ako samo želite da saznate da li objje u skupu upita, a ne .if obj in queryset
Koristite QuerySet.count()¶

...ako želite samo brojanje, umesto da radite len(queryset).
Koristite QuerySet.exists()¶

...ako želite samo da saznate da li postoji barem jedan rezultat, a ne .if queryset

Ali:
Ne preterujte sa contains(), count(), i exists()¶

Ako će vam biti potrebni drugi podaci iz QuerySet-a, odmah ih procenite.

Na primer, pod pretpostavkom da Groupmodel ima relaciju „više-prema-više“ sa User, sledeći kod je optimalan:

members = group.members.all()

if display_group_members:
    if members:
        if current_user in members:
            print("You and", len(members) - 1, "other users are members of this group.")
        else:
            print("There are", len(members), "members in this group.")

        for member in members:
            print(member.username)
    else:
        print("There are no members in this group.")

Optimalno je jer:

    Pošto su QuerySets-ovi lenji, ovo ne vrši upite bazi podataka ako display_group_membersje False.

    Čuvanje group.members.all()u memberspromenljivoj omogućava ponovnu upotrebu njenog keša rezultata.

    Linija uzrokuje poziv , što dovodi do pokretanja upita na bazi podataka. Ako nema rezultata, vratiće se , u suprotnom .if members:QuerySet.__bool__()group.members.all()FalseTrue

    Linija proverava da li se korisnik nalazi u kešu rezultata, tako da se ne izdaju dodatni upiti bazi podataka.if current_user in members:

    Upotreba len(members)poziva QuerySet.__len__(), ponovno korišćenje keša rezultata, tako da se ponovo ne izdaju upiti bazi podataka.

    Petlja se ponavlja kroz keš rezultata.for member

Ukupno, ovaj kod vrši jedan ili nula upita bazi podataka. Jedina namerna optimizacija koja se izvodi je korišćenje memberspromenljive . Korišćenje QuerySet.exists()za if, QuerySet.contains()za inili QuerySet.count()za bi izazvalo dodatne upite.
Koristite QuerySet.update()i delete()¶

Umesto da preuzimate gomilu objekata, postavljate neke vrednosti i čuvate ih pojedinačno, koristite grupni SQL UPDATE izraz, putem QuerySet.update() . Slično tome, vršite grupno brisanje gde god je to moguće.

Međutim, imajte na umu da ove metode grupnog ažuriranja ne mogu pozivati metode save()ili delete()pojedinačnih instanci, što znači da se bilo koje prilagođeno ponašanje koje ste dodali za ove metode neće izvršiti, uključujući i sve što je pokrenuto iz normalnih signala objekata baze podataka .
Direktno korišćenje vrednosti stranog ključa

Ako vam je potrebna samo vrednost stranog ključa, koristite vrednost stranog ključa koja se već nalazi na objektu koji imate, umesto da uzmete ceo povezani objekat i njegov primarni ključ. Na primer, uradite sledeće:

entry.blog_id

umesto:

entry.blog.id

Ne sortiraj rezultate ako ti nije stalo

Uređivanje nije besplatno; svako polje za uređivanje je operacija koju baza podataka mora da izvrši. Ako model ima podrazumevano uređivanje ( Meta.ordering) i nije vam potrebno, uklonite ga na QuerySetpozivanjem order_by()bez parametara.

Dodavanje indeksa u vašu bazu podataka može pomoći u poboljšanju performansi naručivanja.
Koristite grupne metode

Koristite grupne metode da biste smanjili broj SQL naredbi.
Kreiraj grupno

Prilikom kreiranja objekata, gde god je to moguće, koristite bulk_create()metod za smanjenje broja SQL upita. Na primer:

Entry.objects.bulk_create(
    [
        Entry(headline="This is a test"),
        Entry(headline="This is only a test"),
    ]
)

... je poželjnije od:

Entry.objects.create(headline="This is a test")
Entry.objects.create(headline="This is only a test")

Imajte na umu da ih postoji nekoliko , zato se uverite da je to prikladno za vaš slučaj upotrebe.caveats to this method
Ažuriraj grupno

Prilikom ažuriranja objekata, gde god je to moguće, koristite bulk_update()metod za smanjenje broja SQL upita. Data je lista ili skup upita objekata:

entries = Entry.objects.bulk_create(
    [
        Entry(headline="This is a test"),
        Entry(headline="This is only a test"),
    ]
)

Sledeći primer:

entries[0].headline = "This is not a test"
entries[1].headline = "This is no longer a test"
Entry.objects.bulk_update(entries, ["headline"])

... je poželjnije od:

entries[0].headline = "This is not a test"
entries[0].save()
entries[1].headline = "This is no longer a test"
entries[1].save()

Imajte na umu da ih postoji nekoliko , zato se uverite da je to prikladno za vaš slučaj upotrebe.caveats to this method
Ubaci grupno

Prilikom umetanja objekata u ManyToManyFields, koristite add()sa više objekata da biste smanjili broj SQL upita. Na primer:

my_band.members.add(me, my_friend)

... je poželjnije od:

my_band.members.add(me)
my_band.members.add(my_friend)

...gde su Bandi Artistmodeli sa relacijom „više-prema-više“.

Prilikom umetanja različitih parova objekata u ManyToManyFieldili kada je prilagođena throughtabela definisana, koristite bulk_create()metodu da biste smanjili broj SQL upita. Na primer:

PizzaToppingRelationship = Pizza.toppings.through
PizzaToppingRelationship.objects.bulk_create(
    [
        PizzaToppingRelationship(pizza=my_pizza, topping=pepperoni),
        PizzaToppingRelationship(pizza=your_pizza, topping=pepperoni),
        PizzaToppingRelationship(pizza=your_pizza, topping=mushroom),
    ],
    ignore_conflicts=True,
)

... je poželjnije od:

my_pizza.toppings.add(pepperoni)
your_pizza.toppings.add(pepperoni, mushroom)

...gde Pizzai Toppingimaju relaciju „više-prema-više“. Imajte na umu da postoji više , zato se uverite da je to prikladno za vaš slučaj upotrebe.caveats to this method
Ukloni grupno

Prilikom uklanjanja objekata iz ManyToManyFields, koristite remove()sa više objekata da biste smanjili broj SQL upita. Na primer:

my_band.members.remove(me, my_friend)

... je poželjnije od:

my_band.members.remove(me)
my_band.members.remove(my_friend)

...gde su Bandi Artistmodeli sa relacijom „više-prema-više“.

Prilikom uklanjanja različitih parova objekata iz ManyToManyFields, koristite delete()na Qizrazu sa više throughinstanci modela da biste smanjili broj SQL upita. Na primer:

from django.db.models import Q

PizzaToppingRelationship = Pizza.toppings.through
PizzaToppingRelationship.objects.filter(
    Q(pizza=my_pizza, topping=pepperoni)
    | Q(pizza=your_pizza, topping=pepperoni)
    | Q(pizza=your_pizza, topping=mushroom)
).delete()

... je poželjnije od:

my_pizza.toppings.remove(pepperoni)
your_pizza.toppings.remove(pepperoni, mushroom)

...gde Pizzai Toppingimaju relaciju „više-prema-više“.



    Dobijanje pomoći 

    Jezik : en 

    Verzija dokumentacije: 5.2 

Instrumentacija baze podataka

Da bi vam pomogao da razumete i kontrolišete upite koje izdaje vaš kod, Django pruža alatku za instaliranje omotačkih funkcija oko izvršavanja upita baze podataka. Na primer, omotači mogu da broje upite, mere trajanje upita, evidentiraju upite ili čak spreče izvršavanje upita (npr. da bi se osiguralo da se ne izdaju upiti tokom renderovanja šablona sa unapred učitanim podacima).

Omotači su modelirani po poređenju sa midlverom – to su pozivajući objekti koji uzimaju drugi pozivajući objekt kao jedan od svojih argumenata. Oni pozivaju taj pozivajući objekt da bi pozvali (moguće upakovani) upit baze podataka i mogu da rade šta god žele oko tog poziva. Međutim, njih kreira i instalira korisnički kod, tako da im nije potrebna posebna fabrika kao midlveru.

Instaliranje omotača se vrši u menadžeru konteksta – tako da su omotači privremeni i specifični za neki tok u vašem kodu.

Kao što je gore pomenuto, primer omotača je blokator izvršavanja upita. Mogao bi izgledati ovako:

def blocker(*args):
    raise Exception("No database access allowed here.")

I koristilo bi se u prikazu za blokiranje upita iz šablona ovako:

from django.db import connection
from django.shortcuts import render


def my_view(request):
    context = {...}  # Code to generate context with all data.
    template_name = ...
    with connection.execute_wrapper(blocker):
        return render(request, template_name, context)

Parametri koji se šalju omotačima su:

    execute– pozivljiva funkcija, koju treba pozvati sa ostalim parametrima da bi se izvršio upit.

    sql– a str, SQL upit koji treba poslati bazi podataka.

    params– lista/torka vrednosti parametara za SQL komandu, ili lista/torka lista/torki ako je završeni poziv executemany().

    many– a koji boolpokazuje da li je konačno pozvani poziv execute()ili executemany()(i da li paramsse očekuje da bude niz vrednosti ili niz nizova vrednosti).

    context– rečnik sa dodatnim podacima o kontekstu pozivanja. Ovo uključuje vezu i kursor.

Koristeći parametre, malo složenija verzija blokatora mogla bi da uključi ime veze u poruku o grešci:

def blocker(execute, sql, params, many, context):
    alias = context["connection"].alias
    raise Exception("Access to database '{}' blocked here".format(alias))

Za potpuniji primer, logger upita može izgledati ovako:

import time


class QueryLogger:
    def __init__(self):
        self.queries = []

    def __call__(self, execute, sql, params, many, context):
        current_query = {"sql": sql, "params": params, "many": many}
        start = time.monotonic()
        try:
            result = execute(sql, params, many, context)
        except Exception as e:
            current_query["status"] = "error"
            current_query["exception"] = e
            raise
        else:
            current_query["status"] = "ok"
            return result
        finally:
            duration = time.monotonic() - start
            current_query["duration"] = duration
            self.queries.append(current_query)

Da biste ovo koristili, kreirali biste objekat loggera i instalirali ga kao omotač:

from django.db import connection

ql = QueryLogger()
with connection.execute_wrapper(ql):
    do_queries()
# Now we can print the log.
print(ql.queries)

connection.execute_wrapper()¶

execute_wrapper ( omotač )

Vraća menadžer konteksta koji, kada se uđe u njega, instalira omotač oko izvršavanja upita baze podataka, a kada se izlazi iz njega, uklanja omotač. Omotač se instalira na objektu lokalne niti za povezivanje.

wrapperje pozivljiva funkcija koja prima pet argumenata. Poziva se za svako izvršavanje upita u opsegu menadžera konteksta, sa argumentima execute, sql, params, many, i contextkao što je gore opisano. Očekuje se da pozove i vrati povratnu vrednost tog poziva.execute(sql, params, many, context)

Raspored

Fikstura (Fixture) je kolekcija datoteka koje sadrže serijalizovan sadržaj baze podataka. Svaka fikstura ima jedinstveno ime, a datoteke koje čine fiksturu mogu biti distribuirane u više direktorijuma, u više aplikacija.

Vidi takođe

    Kako obezbediti početne podatke za modele

Kako napraviti pričvršćivač

Fiksture se mogu generisati pomoću . Takođe je moguće generisati prilagođene fiksture direktno korišćenjem alata za serijalizaciju ili čak njihovim pisanjem rukom.manage.py dumpdata
Kako se koristi fikster

Fiksture se mogu koristiti za prethodno popunjavanje baze podataka podacima za testove :

class MyTestCase(TestCase):
    fixtures = ["fixture-label"]

ili da biste obezbedili neke početne podatke pomoću loaddatakomande:

django-admin loaddata <fixture label>

Kako se otkrivaju uređaji

Django će pretraživati uređaje na ovim lokacijama:

    U fixturesdirektorijumu svake instalirane aplikacije

    U bilo kom direktorijumu navedenom u FIXTURE_DIRSpodešavanju

    U bukvalnoj putanji koju je imenovao uređaj

Django će učitati sve uređaje koje pronađe na ovim lokacijama, a koji odgovaraju navedenim imenima uređaja. Ako imenovani uređaj ima ekstenziju datoteke, biće učitani samo uređaji tog tipa. Na primer:

django-admin loaddata mydata.json

bi učitao samo JSON fiksture pod nazivom mydata. Ekstenzija fiksture mora odgovarati registrovanom imenu serijalizatora ( npr. jsonili xml.

Ako izostavite ekstenzije, Django će pretražiti sve dostupne tipove fikstera za odgovarajući fikster. Na primer:

django-admin loaddata mydata

bi tražio bilo koji uređaj bilo kog tipa pod nazivom mydata. Ako direktorijum uređaja sadrži mydata.json, taj uređaj bi bio učitan kao JSON uređaj.

Imenovani uređaji mogu da sadrže komponente direktorijuma. Ovi direktorijumi će biti uključeni u putanju pretrage. Na primer:

django-admin loaddata foo/bar/mydata.json

bi tražio <app_label>/fixtures/foo/bar/mydata.jsonsvaku instaliranu aplikaciju, <dirname>/foo/bar/mydata.jsonsvaki direktorijum u FIXTURE_DIRS, i doslovnu putanju foo/bar/mydata.json.
Redosled učitavanja rasporeda

Više fiksnih rešenja može biti navedeno u istom pozivu. Na primer:

django-admin loaddata mammals birds insects

ili u klasi testnih slučajeva:

class AnimalTestCase(TestCase):
    fixtures = ["mammals", "birds", "insects"]

Redosled kojim se uređaji učitavaju prati redosled kojim su navedeni, bilo da se radi o korišćenju komande za upravljanje ili o njihovom navođenju u klasi test slučaja kao što je prikazano gore.

U ovim primerima, svi uređaji imenovani mammalsiz svih aplikacija (redosledom kojim su aplikacije definisane u INSTALLED_APPS) biće prvo učitani. Nakon toga, svi birdsuređaji će biti učitani, a zatim i svi insectsuređaji.

Imajte na umu da ako bekend baze podataka podržava ograničenja na nivou redova, ova ograničenja će biti proverena na kraju transakcije. Bilo koji odnos između fiksnih stavki može dovesti do greške pri učitavanju ako konfiguracija baze podataka ne podržava odloženu proveru ograničenja (pogledajte MySQL dokumentaciju za primer).
Kako se uređaji čuvaju u bazi podataka

Kada se datoteke fikstura obrađuju, podaci se čuvaju u bazi podataka kakvi jesu. save()Metode definisane modelom se ne pozivaju, a bilo koji signali pre_saveili će biti pozvani sa , jer instanca sadrži samo atribute koji su lokalni za model. Na primer, možete želeti da onemogućite rukovaoce koji pristupaju povezanim poljima koja nisu prisutna tokom učitavanja fikstura i koja bi u suprotnom izazvala izuzetak:post_saveraw=True

from django.db.models.signals import post_save
from .models import MyModel


def my_handler(**kwargs):
    # disable the handler during fixture loading
    if kwargs["raw"]:
        return
    ...


post_save.connect(my_handler, sender=MyModel)

Takođe možete napisati dekorator da biste obuhvatili ovu logiku:

from functools import wraps


def disable_for_loaddata(signal_handler):
    """
    Decorator that turns off signal handlers when loading fixture data.
    """

    @wraps(signal_handler)
    def wrapper(*args, **kwargs):
        if kwargs["raw"]:
            return
        signal_handler(*args, **kwargs)

    return wrapper


@disable_for_loaddata
def my_handler(**kwargs): ...

Samo imajte na umu da će ova logika onemogućiti signale kad god se uređaji deserijalizuju, ne samo tokom loaddata.
Kompresovani fiksni elementi

Uređaji mogu biti kompresovani u formatu zip, gz, bz2, lzma, ili xz. Na primer:

django-admin loaddata mydata.json

tražio bi bilo šta od mydata.json, mydata.json.zip, mydata.json.gz, mydata.json.bz2, mydata.json.lzma, ili mydata.json.xz. Koristi se prva datoteka koja se nalazi u kompresovanoj arhivi.

Imajte na umu da ako se otkriju dva uređaja sa istim imenom, ali različitim tipom uređaja (na primer, ako su mydata.jsoni mydata.xml.gzpronađeni u istom direktorijumu uređaja), instalacija uređaja će biti prekinuta, a svi podaci instalirani u pozivu loaddatabiće uklonjeni iz baze podataka.

MySQL sa MyISAM-om i fiksnim elementima

MyISAM mehanizam za skladištenje podataka u MySQL-u ne podržava transakcije ili ograničenja, tako da ako koristite MyISAM, nećete dobiti validaciju podataka o fiksturi, niti vraćanje na prethodnu vrednost ako se pronađe više datoteka transakcija.
Prilagođavanja specifična za bazu podataka

Ako koristite više baza podataka, možda imate podatke o uređajima koje želite da učitate u jednu bazu podataka, ali ne i u drugu. U ovoj situaciji, možete dodati identifikator baze podataka u imena vaših uređaja.

Na primer, ako vaše DATABASESpodešavanje ima usersdefinisanu bazu podataka, nazovite fiksnu jedinicu mydata.users.jsonili mydata.users.json.gzi fiksna jedinica će biti učitana samo kada navedete da želite da učitate podatke u usersbazu podataka.

Relacije „više prema mnogo“

Da biste definisali relaciju „više-prema-više“, koristite ManyToManyField.

U ovom primeru, `an` Articlemože biti objavljen u više Publicationobjekata, a `a` Publicationima više Articleobjekata:

from django.db import models


class Publication(models.Model):
    title = models.CharField(max_length=30)

    class Meta:
        ordering = ["title"]

    def __str__(self):
        return self.title


class Article(models.Model):
    headline = models.CharField(max_length=100)
    publications = models.ManyToManyField(Publication)

    class Meta:
        ordering = ["headline"]

    def __str__(self):
        return self.headline

U nastavku su navedeni primeri operacija koje se mogu izvršiti korišćenjem mogućnosti Pajton API-ja.

Napravite nekoliko Publicationinstanci:

>>> p1 = Publication(title="The Python Journal")
>>> p1.save()
>>> p2 = Publication(title="Science News")
>>> p2.save()
>>> p3 = Publication(title="Science Weekly")
>>> p3.save()

Napravite Article:

>>> a1 = Article(headline="Django lets you build web apps easily")

Ne možete ga povezati sa Publicationdok se ne sačuva:

>>> a1.publications.add(p1)
Traceback (most recent call last):
...
ValueError: "<Article: Django lets you build web apps easily>" needs to have a value for field "id" before this many-to-many relationship can be used.

Sačuvaj to!

>>> a1.save()

Povežite Articlesa Publication:

>>> a1.publications.add(p1)

Napravite još jednu funkciju Articlei podesite je da se pojavljuje u njenim publikacijama:

>>> a2 = Article(headline="NASA uses Python")
>>> a2.save()
>>> a2.publications.add(p1, p2)
>>> a2.publications.add(p3)

Dodavanje drugog vremena je u redu, neće duplirati relaciju:

>>> a2.publications.add(p3)

Dodavanje objekta pogrešnog tipa izaziva TypeError:

>>> a2.publications.add(a1)
Traceback (most recent call last):
...
TypeError: 'Publication' instance expected

Kreirajte i dodajte Publicationu Articlejedan korak koristeći create():

>>> new_publication = a2.publications.create(title="Highlights for Children")

Articleobjekti imaju pristup svojim povezanim Publicationobjektima:

>>> a1.publications.all()
<QuerySet [<Publication: The Python Journal>]>
>>> a2.publications.all()
<QuerySet [<Publication: Highlights for Children>, <Publication: Science News>, <Publication: Science Weekly>, <Publication: The Python Journal>]>

Publicationobjekti imaju pristup svojim povezanim Articleobjektima:

>>> p2.article_set.all()
<QuerySet [<Article: NASA uses Python>]>
>>> p1.article_set.all()
<QuerySet [<Article: Django lets you build web apps easily>, <Article: NASA uses Python>]>
>>> Publication.objects.get(id=4).article_set.all()
<QuerySet [<Article: NASA uses Python>]>

Relacije tipa „više prema više“ mogu se ispitivati korišćenjem pretraga u relacijama :

>>> Article.objects.filter(publications__id=1)
<QuerySet [<Article: Django lets you build web apps easily>, <Article: NASA uses Python>]>
>>> Article.objects.filter(publications__pk=1)
<QuerySet [<Article: Django lets you build web apps easily>, <Article: NASA uses Python>]>
>>> Article.objects.filter(publications=1)
<QuerySet [<Article: Django lets you build web apps easily>, <Article: NASA uses Python>]>
>>> Article.objects.filter(publications=p1)
<QuerySet [<Article: Django lets you build web apps easily>, <Article: NASA uses Python>]>

>>> Article.objects.filter(publications__title__startswith="Science")
<QuerySet [<Article: NASA uses Python>, <Article: NASA uses Python>]>

>>> Article.objects.filter(publications__title__startswith="Science").distinct()
<QuerySet [<Article: NASA uses Python>]>

Funkcija takođe count()poštuje :distinct()

>>> Article.objects.filter(publications__title__startswith="Science").count()
2

>>> Article.objects.filter(publications__title__startswith="Science").distinct().count()
1

>>> Article.objects.filter(publications__in=[1, 2]).distinct()
<QuerySet [<Article: Django lets you build web apps easily>, <Article: NASA uses Python>]>
>>> Article.objects.filter(publications__in=[p1, p2]).distinct()
<QuerySet [<Article: Django lets you build web apps easily>, <Article: NASA uses Python>]>

Podržani su obrnuti m2m upiti (tj. počevši od tabele koja nema ManyToManyField):

>>> Publication.objects.filter(id=1)
<QuerySet [<Publication: The Python Journal>]>
>>> Publication.objects.filter(pk=1)
<QuerySet [<Publication: The Python Journal>]>

>>> Publication.objects.filter(article__headline__startswith="NASA")
<QuerySet [<Publication: Highlights for Children>, <Publication: Science News>, <Publication: Science Weekly>, <Publication: The Python Journal>]>

>>> Publication.objects.filter(article__id=1)
<QuerySet [<Publication: The Python Journal>]>
>>> Publication.objects.filter(article__pk=1)
<QuerySet [<Publication: The Python Journal>]>
>>> Publication.objects.filter(article=1)
<QuerySet [<Publication: The Python Journal>]>
>>> Publication.objects.filter(article=a1)
<QuerySet [<Publication: The Python Journal>]>

>>> Publication.objects.filter(article__in=[1, 2]).distinct()
<QuerySet [<Publication: Highlights for Children>, <Publication: Science News>, <Publication: Science Weekly>, <Publication: The Python Journal>]>
>>> Publication.objects.filter(article__in=[a1, a2]).distinct()
<QuerySet [<Publication: Highlights for Children>, <Publication: Science News>, <Publication: Science Weekly>, <Publication: The Python Journal>]>

Isključivanje povezane stavke takođe funkcioniše kako biste očekivali (iako je uključeni SQL malo složen):

>>> Article.objects.exclude(publications=p2)
<QuerySet [<Article: Django lets you build web apps easily>]>

Ako obrišemo Publication, njegove povezane Articleinstance neće moći da mu pristupe:

>>> p1.delete()
>>> Publication.objects.all()
<QuerySet [<Publication: Highlights for Children>, <Publication: Science News>, <Publication: Science Weekly>]>
>>> a1 = Article.objects.get(pk=1)
>>> a1.publications.all()
<QuerySet []>

Ako obrišemo Article, njegove povezane Publicationinstance neće moći da mu pristupe:

>>> a2.delete()
>>> Article.objects.all()
<QuerySet [<Article: Django lets you build web apps easily>]>
>>> p2.article_set.all()
<QuerySet []>

Dodavanje preko „drugog“ kraja m2m:

>>> a4 = Article(headline="NASA finds intelligent life on Earth")
>>> a4.save()
>>> p2.article_set.add(a4)
>>> p2.article_set.all()
<QuerySet [<Article: NASA finds intelligent life on Earth>]>
>>> a4.publications.all()
<QuerySet [<Publication: Science News>]>

Dodavanje preko drugog kraja pomoću ključnih reči:

>>> new_article = p2.article_set.create(headline="Oxygen-free diet works wonders")
>>> p2.article_set.all()
<QuerySet [<Article: NASA finds intelligent life on Earth>, <Article: Oxygen-free diet works wonders>]>
>>> a5 = p2.article_set.all()[1]
>>> a5.publications.all()
<QuerySet [<Publication: Science News>]>

Uklanjanje Publicationiz Article:

>>> a4.publications.remove(p2)
>>> p2.article_set.all()
<QuerySet [<Article: Oxygen-free diet works wonders>]>
>>> a4.publications.all()
<QuerySet []>

I sa drugog kraja:

>>> p2.article_set.remove(a5)
>>> p2.article_set.all()
<QuerySet []>
>>> a5.publications.all()
<QuerySet []>

Skupovi relacija mogu se podesiti:

>>> a4.publications.all()
<QuerySet [<Publication: Science News>]>
>>> a4.publications.set([p3])
>>> a4.publications.all()
<QuerySet [<Publication: Science Weekly>]>

Skupovi relacija mogu se obrisati:

>>> p2.article_set.clear()
>>> p2.article_set.all()
<QuerySet []>

I možete očistiti sa drugog kraja:

>>> p2.article_set.add(a4, a5)
>>> p2.article_set.all()
<QuerySet [<Article: NASA finds intelligent life on Earth>, <Article: Oxygen-free diet works wonders>]>
>>> a4.publications.all()
<QuerySet [<Publication: Science News>, <Publication: Science Weekly>]>
>>> a4.publications.clear()
>>> a4.publications.all()
<QuerySet []>
>>> p2.article_set.all()
<QuerySet [<Article: Oxygen-free diet works wonders>]>

Ponovo kreirajte Articlei Publicationobrisali smo:

>>> p1 = Publication(title="The Python Journal")
>>> p1.save()
>>> a2 = Article(headline="NASA uses Python")
>>> a2.save()
>>> a2.publications.add(p1, p2, p3)

Grupno obrišite neke Publicationinstance i reference na obrisane publikacije više neće biti uključene u povezane unose:

>>> Publication.objects.filter(title__startswith="Science").delete()
>>> Publication.objects.all()
<QuerySet [<Publication: Highlights for Children>, <Publication: The Python Journal>]>
>>> Article.objects.all()
<QuerySet [<Article: Django lets you build web apps easily>, <Article: NASA finds intelligent life on Earth>, <Article: NASA uses Python>, <Article: Oxygen-free diet works wonders>]>
>>> a2.publications.all()
<QuerySet [<Publication: The Python Journal>]>

Masovno brisanje nekih članaka - reference na obrisane objekte treba da idu:

>>> q = Article.objects.filter(headline__startswith="Django")
>>> print(q)
<QuerySet [<Article: Django lets you build web apps easily>]>
>>> q.delete()

Nakon toga delete(), QuerySetkeš memorija mora biti obrisana, a referencirani objekti bi trebalo da nestanu:

>>> print(q)
<QuerySet []>
>>> p1.article_set.all()
<QuerySet [<Article: NASA uses Python>]>

Релације „више према једном“

Да бисте дефинисали однос „више према један“, користите ForeignKey.

У овом примеру, a Reporterможе бити повезан са многим Articleобјектима, али an Articleможе имати само један Reporterобјекат:

from django.db import models


class Reporter(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
    email = models.EmailField()

    def __str__(self):
        return f"{self.first_name} {self.last_name}"


class Article(models.Model):
    headline = models.CharField(max_length=100)
    pub_date = models.DateField()
    reporter = models.ForeignKey(Reporter, on_delete=models.CASCADE)

    def __str__(self):
        return self.headline

    class Meta:
        ordering = ["headline"]

У наставку су наведени примери операција које се могу извршити коришћењем могућности Пајтон АПИ-ја.

Направите неколико репортера:

>>> r = Reporter(first_name="John", last_name="Smith", email="john@example.com")
>>> r.save()

>>> r2 = Reporter(first_name="Paul", last_name="Jones", email="paul@example.com")
>>> r2.save()

Направите чланак:

>>> from datetime import date
>>> a = Article(id=None, headline="This is a test", pub_date=date(2005, 7, 27), reporter=r)
>>> a.save()

>>> a.reporter.id
1

>>> a.reporter
<Reporter: John Smith>

Имајте на уму да морате сачувати објекат пре него што му се може доделити релација страног кључа. На пример, креирање Articleса несачуваним Reporterповећањима ValueError:

>>> r3 = Reporter(first_name="John", last_name="Smith", email="john@example.com")
>>> Article.objects.create(
...     headline="This is a test", pub_date=date(2005, 7, 27), reporter=r3
... )
Traceback (most recent call last):
...
ValueError: save() prohibited to prevent data loss due to unsaved related object 'reporter'.

Објекти чланка имају приступ својим повезаним објектима репортера:

>>> r = a.reporter

Направите чланак преко објекта Репортер:

>>> new_article = r.article_set.create(
...     headline="John's second story", pub_date=date(2005, 7, 29)
... )
>>> new_article
<Article: John's second story>
>>> new_article.reporter
<Reporter: John Smith>
>>> new_article.reporter.id
1

Направите нови чланак:

>>> new_article2 = Article.objects.create(
...     headline="Paul's story", pub_date=date(2006, 1, 17), reporter=r
... )
>>> new_article2.reporter
<Reporter: John Smith>
>>> new_article2.reporter.id
1
>>> r.article_set.all()
<QuerySet [<Article: John's second story>, <Article: Paul's story>, <Article: This is a test>]>

Додајте исти чланак у други скуп чланака - проверите да ли се помера:

>>> r2.article_set.add(new_article2)
>>> new_article2.reporter.id
2
>>> new_article2.reporter
<Reporter: Paul Jones>

Додавање објекта погрешног типа изазива грешку TypeError:

>>> r.article_set.add(r2)
Traceback (most recent call last):
...
TypeError: 'Article' instance expected, got <Reporter: Paul Jones>

>>> r.article_set.all()
<QuerySet [<Article: John's second story>, <Article: This is a test>]>
>>> r2.article_set.all()
<QuerySet [<Article: Paul's story>]>

>>> r.article_set.count()
2

>>> r2.article_set.count()
1

Имајте на уму да је у последњем примеру члан премештен са Јована на Павла.

Повезани менаџери такође подржавају претраге поља. API аутоматски прати односе колико год вам је потребно. Користите двоструке подвлаке за одвајање односа. Ово функционише онолико дубоко колико желите. Нема ограничења. На пример:

>>> r.article_set.filter(headline__startswith="This")
<QuerySet [<Article: This is a test>]>

# Find all Articles for any Reporter whose first name is "John".
>>> Article.objects.filter(reporter__first_name="John")
<QuerySet [<Article: John's second story>, <Article: This is a test>]>

Овде се подразумева тачно подударање:

>>> Article.objects.filter(reporter__first_name="John")
<QuerySet [<Article: John's second story>, <Article: This is a test>]>

Двапут упитајте повезано поље. Ово се преводи у услов AND у WHERE клаузули:

>>> Article.objects.filter(reporter__first_name="John", reporter__last_name="Smith")
<QuerySet [<Article: John's second story>, <Article: This is a test>]>

За повезану претрагу можете навести вредност примарног кључа или експлицитно проследити повезани објекат:

>>> Article.objects.filter(reporter__pk=1)
<QuerySet [<Article: John's second story>, <Article: This is a test>]>
>>> Article.objects.filter(reporter=1)
<QuerySet [<Article: John's second story>, <Article: This is a test>]>
>>> Article.objects.filter(reporter=r)
<QuerySet [<Article: John's second story>, <Article: This is a test>]>

>>> Article.objects.filter(reporter__in=[1, 2]).distinct()
<QuerySet [<Article: John's second story>, <Article: Paul's story>, <Article: This is a test>]>
>>> Article.objects.filter(reporter__in=[r, r2]).distinct()
<QuerySet [<Article: John's second story>, <Article: Paul's story>, <Article: This is a test>]>

Такође можете користити скуп упита уместо буквалне листе инстанци:

>>> Article.objects.filter(
...     reporter__in=Reporter.objects.filter(first_name="John")
... ).distinct()
<QuerySet [<Article: John's second story>, <Article: This is a test>]>

Упит у супротном смеру:

>>> Reporter.objects.filter(article__pk=1)
<QuerySet [<Reporter: John Smith>]>
>>> Reporter.objects.filter(article=1)
<QuerySet [<Reporter: John Smith>]>
>>> Reporter.objects.filter(article=a)
<QuerySet [<Reporter: John Smith>]>

>>> Reporter.objects.filter(article__headline__startswith="This")
<QuerySet [<Reporter: John Smith>, <Reporter: John Smith>, <Reporter: John Smith>]>
>>> Reporter.objects.filter(article__headline__startswith="This").distinct()
<QuerySet [<Reporter: John Smith>]>

Бројање у супротном смеру функционише заједно са distinct():

>>> Reporter.objects.filter(article__headline__startswith="This").count()
3
>>> Reporter.objects.filter(article__headline__startswith="This").distinct().count()
1

Упити се могу вртети у круг:

>>> Reporter.objects.filter(article__reporter__first_name__startswith="John")
<QuerySet [<Reporter: John Smith>, <Reporter: John Smith>, <Reporter: John Smith>, <Reporter: John Smith>]>
>>> Reporter.objects.filter(article__reporter__first_name__startswith="John").distinct()
<QuerySet [<Reporter: John Smith>]>
>>> Reporter.objects.filter(article__reporter=r).distinct()
<QuerySet [<Reporter: John Smith>]>

Ако обришете репортера, његови чланци ће бити обрисани (под претпоставком да је ForeignKey дефинисан са django.db.models.ForeignKey.on_deleteподешено на CASCADE, што је подразумевана вредност):

>>> Article.objects.all()
<QuerySet [<Article: John's second story>, <Article: Paul's story>, <Article: This is a test>]>
>>> Reporter.objects.order_by("first_name")
<QuerySet [<Reporter: John Smith>, <Reporter: Paul Jones>]>
>>> r2.delete()
>>> Article.objects.all()
<QuerySet [<Article: John's second story>, <Article: This is a test>]>
>>> Reporter.objects.order_by("first_name")
<QuerySet [<Reporter: John Smith>]>

Можете обрисати помоћу JOIN-а у упиту:

>>> Reporter.objects.filter(article__headline__startswith="This").delete()
>>> Reporter.objects.all()
<QuerySet []>
>>> Article.objects.all()
<QuerySet []>

Jedan-na-jedan odnosi

Da biste definisali odnos jedan-na-jedan, koristite OneToOneField.

U ovom primeru, Placeopciono može biti Restaurant:

from django.db import models


class Place(models.Model):
    name = models.CharField(max_length=50)
    address = models.CharField(max_length=80)

    def __str__(self):
        return f"{self.name} the place"


class Restaurant(models.Model):
    place = models.OneToOneField(
        Place,
        on_delete=models.CASCADE,
        primary_key=True,
    )
    serves_hot_dogs = models.BooleanField(default=False)
    serves_pizza = models.BooleanField(default=False)

    def __str__(self):
        return "%s the restaurant" % self.place.name


class Waiter(models.Model):
    restaurant = models.ForeignKey(Restaurant, on_delete=models.CASCADE)
    name = models.CharField(max_length=50)

    def __str__(self):
        return "%s the waiter at %s" % (self.name, self.restaurant)

U nastavku su navedeni primeri operacija koje se mogu izvršiti korišćenjem mogućnosti Pajton API-ja.

Napravite nekoliko mesta:

>>> p1 = Place(name="Demon Dogs", address="944 W. Fullerton")
>>> p1.save()
>>> p2 = Place(name="Ace Hardware", address="1013 N. Ashland")
>>> p2.save()

Napravite restoran. Prosledite „roditeljski“ objekat kao primarni ključ ovog objekta:

>>> r = Restaurant(place=p1, serves_hot_dogs=True, serves_pizza=False)
>>> r.save()

Restoran može da pristupi svom prostoru:

>>> r.place
<Place: Demon Dogs the place>

Mesto može pristupiti svom restoranu, ako je dostupan:

>>> p1.restaurant
<Restaurant: Demon Dogs the restaurant>

p2 nema povezani restoran:

>>> from django.core.exceptions import ObjectDoesNotExist
>>> try:
...     p2.restaurant
... except ObjectDoesNotExist:
...     print("There is no restaurant here.")
...
There is no restaurant here.

Takođe možete koristiti hasattrda biste izbegli potrebu za hvatanjem izuzetaka:

>>> hasattr(p2, "restaurant")
False

Podesite mesto koristeći notaciju dodele. Pošto je mesto primarni ključ za restoran, čuvanje će kreirati novi restoran:

>>> r.place = p2
>>> r.save()
>>> p2.restaurant
<Restaurant: Ace Hardware the restaurant>
>>> r.place
<Place: Ace Hardware the place>

Vratite mesto ponovo, koristeći dodelu u obrnutom smeru:

>>> p1.restaurant = r
>>> p1.restaurant
<Restaurant: Demon Dogs the restaurant>

Imajte na umu da morate sačuvati objekat pre nego što mu se može dodeliti relacija jedan-na-jedan. Na primer, kreiranje Restaurantsa nesačuvanim Placepovećanjima ValueError:

>>> p3 = Place(name="Demon Dogs", address="944 W. Fullerton")
>>> Restaurant.objects.create(place=p3, serves_hot_dogs=True, serves_pizza=False)
Traceback (most recent call last):
...
ValueError: save() prohibited to prevent data loss due to unsaved related object 'place'.

Restaurant.objects.all() vraća restorane, a ne mesta. Imajte na umu da postoje dva restorana - Ace Hardware je kreiran pozivom funkcije r.place = p2:

>>> Restaurant.objects.all()
<QuerySet [<Restaurant: Demon Dogs the restaurant>, <Restaurant: Ace Hardware the restaurant>]>

Place.objects.all() vraća sva mesta, bez obzira na to da li imaju restorane:

>>> Place.objects.order_by("name")
<QuerySet [<Place: Ace Hardware the place>, <Place: Demon Dogs the place>]>

Možete da upitate modele koristeći pretrage u različitim odnosima :

>>> Restaurant.objects.get(place=p1)
<Restaurant: Demon Dogs the restaurant>
>>> Restaurant.objects.get(place__pk=1)
<Restaurant: Demon Dogs the restaurant>
>>> Restaurant.objects.filter(place__name__startswith="Demon")
<QuerySet [<Restaurant: Demon Dogs the restaurant>]>
>>> Restaurant.objects.exclude(place__address__contains="Ashland")
<QuerySet [<Restaurant: Demon Dogs the restaurant>]>

Ovo takođe funkcioniše obrnuto:

>>> Place.objects.get(pk=1)
<Place: Demon Dogs the place>
>>> Place.objects.get(restaurant__place=p1)
<Place: Demon Dogs the place>
>>> Place.objects.get(restaurant=r)
<Place: Demon Dogs the place>
>>> Place.objects.get(restaurant__place__name__startswith="Demon")
<Place: Demon Dogs the place>

Ako obrišete mesto, njegov restoran će biti obrisan (pod pretpostavkom da OneToOneFieldje definisano sa on_deletepodešeno na CASCADE, što je podrazumevana vrednost):

>>> p2.delete()
(2, {'one_to_one.Restaurant': 1, 'one_to_one.Place': 1})
>>> Restaurant.objects.all()
<QuerySet [<Restaurant: Demon Dogs the restaurant>]>

Dodajte konobara u restoran:

>>> w = r.waiter_set.create(name="Joe")
>>> w
<Waiter: Joe the waiter at Demon Dogs the restaurant>

Pitajte konobare:

>>> Waiter.objects.filter(restaurant__place=p1)
<QuerySet [<Waiter: Joe the waiter at Demon Dogs the restaurant>]>
>>> Waiter.objects.filter(restaurant__place__name__startswith="Demon")
<QuerySet [<Waiter: Joe the waiter at Demon Dogs the restaurant>]>

