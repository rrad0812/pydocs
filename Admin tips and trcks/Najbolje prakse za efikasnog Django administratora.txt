Objavljeno 5. septembra 2023, 2000 UTC

10 minuta



class BaseAdmin(ModelAdmin):
sortable_by: tuple = ("created", "modified")

BaseAdmin



ordering

class BaseAdmin(ModelAdmin):
ordering: tuple = ("created", "modified")

Model

class User(Model):

class Meta:
ordering = ["created", "modified"] # Remove this

changelist

# https://docs.djangoproject.com/en/4.1/ref/contrib/admin/#django.contrib.admin.ModelAdm
LIST_PER_PAGE = 20

reltuples



class LargeTablePaginator(Paginator):
"""

    # https://gist.github.com/noviluni/d86adfa24843c7b8ed10c183a9df2afe
    Overrides the count method of QuerySet objects to avoid timeouts.
    - Get an estimate instead of actual count when not filtered (this estimate can be st
    situations where the count of objects actually matter).
    """

@cached_property
def count(self):

"""
        Returns an estimated number of objects, across all pages.
        """

if not self.object_list.query.where: # type: ignore
try:

with connection.cursor() as cursor:
# Obtain estimated values (only valid with PostgreSQL)
cursor.execute(

"SELECT reltuples FROM pg_class WHERE relname = %s
[self.object_list.query.model._meta.db_table], # type: ignore

)
estimate = int(cursor.fetchone()[0])
return estimate

except Exception: # pylint: disable=broad-except
# If any other exception occurred fall back to default behaviour
pass

return super().count

LargeTablePaginator get_paginator

class BaseAdmin(ModelAdmin):
large_table_paginator = False

def get_paginator( # pylint: disable=too-many-arguments
self,
request,
queryset,
per_page,
orphans=0,
allow_empty_first_page=True,

):
# Always show count locally
if self.large_table_paginator and not settings.DEBUG:

return LargeTablePaginator(
queryset, per_page, orphans, allow_empty_first_page

)
return self.paginator(queryset, per_page, orphans, allow_empty_first_page



large_table_paginator

class BaseAdmin(ModelAdmin):
large_table_paginator = True

0 results (1 total) 1 total

show_full_result_count False

0 results (Show all)

class BaseAdmin(ModelAdmin):
show_full_result_count = False

date_hierarchy



django-

admin-lightweight-date-hierarchy

poetry add django-admin-

lightweight-date-hierarchy

INSTALLED_APPS = (
...
'django_admin_lightweight_date_hierarchy',
...

)

date_hierarchy_drilldown False

class BaseAdmin(ModelAdmin):
date_hierarchy = "created"
date_hierarchy_drilldown = False # Disable drilldowns

class BaseAdmin(ModelAdmin):

def get_date_hierarchy_drilldown(self, year_lookup, month_lookup):
"""Drill-down only on past dates."""

today = timezone.now().date()

if year_lookup is None and month_lookup is None:
# Applications first year in production
apps_first_year = 2022
return (

datetime.date(y, 1, 1) for y in range(ums_first_year, today
)

if year_lookup is not None and month_lookup is None:
# Past months of selected year.
this_month = today.replace(day=1)
return (

month
for month in (



for month in (
datetime.date(int(year_lookup), month, 1) for month in

)
if month <= this_month

)

if year_lookup is not None and month_lookup is not None:
# Past days of selected month.
days_in_month = calendar.monthrange(year_lookup, month_lookup
return (

day
for day in (

datetime.date(year_lookup, month_lookup, i + 1)
for i in range(days_in_month)

)
if day <= today

)

@cached_property

class MyModel(Model):



class MyModel(Model):

@cached_property
def computational_heavy_query(self):

"""
        Run a heavy query
        """

return (
self.objects.filter(

tag__in=['a', 'b', 'c'],
name__icontains='test'

)
.order_by("-created", "-modified")
.distinct("id")
.all()

)

fields

class BaseAdmin(ModelAdmin):

fields = ("computational_heavy_query_field_1", "computational_heavy_query
readonly_fields = ("computational_heavy_query_field_1", "computational_heavy_query

def computational_heavy_query_field_1(self, obj):
computational_heavy_query = obj.computational_heavy_query
return mark_safe(

f"""
            <p>{computational_heavy_query} 1</p>
            """

)

def computational_heavy_query_field_2(self, obj):
computational_heavy_query = obj.computational_heavy_query
return mark_safe(

f"""
            <p>{computational_heavy_query} 2</p>
            """

)

cached_property

cached_property



search_fields icontains

search_fields icontains

search_fields

icontains

search_fields

exact

icontains

class BaseAdmin(ModelAdmin):

search_fields = ("id__exact", "company_id__exact", "name")

list_of_lookups = ['exact', 'iexact', 'gt', 'gte', 'lt', 'lte', 'in', 'contains'

@admin.register(Category)
class CategoryAdmin(admin.ModelAdmin):

list_display = ("id", "name", "emoji")
search_fields = ("name",)



search_fields = ("name",)

@admin.register(Repository)
class RepositoryAdmin(SearchAdmin):

autocomplete_fields = []

True

DjangoQL

new = True and date_published ~ "2023-09"

new True

poetry add djangoql

INSTALLED_APPS = [
...
'djangoql',
...

]

from djangoql.admin import DjangoQLSearchMixin

class BaseAdmin(DjangoQLSearchMixin, ModelAdmin):
...



company__name

select_related

prefetch_related

select_related

list_select_related

select_related list

class MyAdmin(BaseAdmin):
list_select_related = ('company',)

get_queryset

list

class MyAdmin(BaseAdmin):

def get_queryset(self, request):
return super().get_queryset(request).select_related("company")

select_related

Python SQL

M2M

Python



class MyAdmin(BaseAdmin):

def get_queryset(self, request):
return super().get_queryset(request).prefetch_related(

'friends'
)

show_facets Never

@admin.register(Repository)
class RepositoryAdmin(SearchAdmin):

show_facets = admin.ShowFacets.ALLOW # Default, facets will be toggleable
# show_facets = admin.ShowFacets.ALWAYS # Enable facets, always show result count for 
# show_facets = admin.ShowFacets.NEVER # Disable facets