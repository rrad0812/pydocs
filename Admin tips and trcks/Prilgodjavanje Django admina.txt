Customizing the Django Admin

Nik Tomazic

Django-ov automatski generisan administratorski sajt je jedna od najvećih prednosti ovog
frejmvorka. Centralizovani administratorski interfejs vam omogućava da lako pregledate i
manipulišete podacima vaših modela. Ovo vam može uštedeti mnogo vremena prilikom razvoja i
upravljanja sadržajem.

Iako je administratorski sajt veoma prilagodljiv, mnogi programeri nisu svesni njegovih punih
mogućnosti. To dovodi do toga da programeri kreiraju prikaze i funkcije za stvari koje bi se mogle
lako implementirati uz malo podešavanja administratorskog sajta.

U ovom članku ćemo pogledati kako da prilagodimo Django-ov administratorski sajt kroz
praktične primere. Obradićemo ugrađene opcije prilagođavanja, kao i prilagođavanje putem
paketa trećih strana kao što su DjangoQL , django-import-export i django-admin-interface .

Ciljevi

Podešavanje projekta

Osnovno prilagođavanje administratorskog sajta

Django model i administrator

Prilagodite administratorsku stranicu pomoću klase ModelAdmin

Zameni Django administratorske obrasce

Zameni Django administratorske šablone

Napredna pretraga pomoću DjangoQL-a

Uvoz i izvoz podataka pomoću Django Import Export-a

Stilizujte administrativni sajt pomoću Django administrativnog interfejsa

Zaključak

Ciljevi

Do kraja ovog članka, moći ćete da:

Izvršite osnovnu konfiguraciju Django administratorskog sajta

Objasnite kako atributi Django modela utiču na administratorski sajt

Koristite list_displayza kontrolu koja polja modela se prikazuju



Dodajte prilagođena polja list_displayi formatirajte postojeća

Dodajte veze do povezanih objekata modela ulist_display

Omogući pretragu i filtere putem search_fieldsilist_filter

Rukujte ugrađenim redovima modela za oba N:1i M:Mza odnose

Koristite Django administratorske akcije i kreirajte prilagođene

Zameni Django administratorske obrasce i šablone

Koristite DjangoQL za naprednu funkcionalnost pretraživanja

Uvozite podatke i izvozite podatke u različite formate koristećidjango-import-export

Izmenite izgled vašeg administratorskog sajta putemdjango-admin-interface

Podešavanje projekta

Da bih demonstrirao različite opcije prilagođavanja administratorskog sajta, pripremio sam
jednostavnu veb aplikaciju. Veb aplikacija služi kao sistem za prodaju karata za događaje.
Omogućava vam upravljanje mestima održavanja, koncertima, kategorijama koncerata i kartama.

Ima sledeći model entitet-relacija:

Toplo vam preporučujem da prvo pratite ovu veb aplikaciju. Nakon čitanja, možete primeniti
stečeno znanje na svoje Django projekte.

Prvo, preuzmite izvorni kod iz repozitorijuma na GitHub-u:

$ git clone https://github.com/duplxey/django-admin-customization.git --branch 
base
$ cd django-admin-customization

Napravite virtuelno okruženje i aktivirajte ga:

$ python3.11 -m venv env && source env/bin/activate

Instalirajte zahteve i migrirajte bazu podataka:



(venv)$ pip install -r requirements.txt
(venv)$ python manage.py migrate

Kreirajte superkorisnika i popunite bazu podataka:

(venv)$ python manage.py createsuperuser
(venv)$ python manage.py populate_db

Pokrenite razvojni server:

(venv)$ python manage.py runserver

Otvorite svoj omiljeni veb pregledač i idite na http://localhost:8000/admin . Pokušajte da koristite
svoje superkorisničke akreditive za pristup administratorskoj stranici Django-a. Nakon toga,
uverite se da je baza podataka popunjena sa nekoliko mesta održavanja, kategorija koncerata,
koncerata i karata.

Pre nego što nastavite, predlažem da proverite modele u tickets/models.py . Obratite pažnju na to
koja polja model ima i kako su modeli povezani.

Osnovno prilagođavanje administratorskog sajta

Administrativni sajt Django-a pruža neke osnovne opcije konfiguracije. Ove opcije vam
omogućavaju da promenite naslov, zaglavlje, URL adresu sajta i još mnogo toga. Ovo
site_headerpodešavanje može biti posebno korisno ako imate više okruženja i želite da ih lako
razlikujete.

Podešavanja se obično menjaju u glavnoj datoteci urls.pyadmin.site vašeg projekta .

Preimenujte Django administratora u „TicketPlus“ i označite trenutno okruženje kao dev:

# core/urls.py

admin.site.site_title = "TicketsPlus site admin (DEV)"
admin.site.site_header = "TicketsPlus administration"
admin.site.index_title = "Site administration"

Sva podešavanja se mogu videti proverom Django- ove datoteke contrib/admin/sites.py .

Još jedna stvar koju bi trebalo da uradite jeste da promenite podrazumevanu /adminURL adresu.
Ovo će otežati zlonamernim akterima da pronađu vaš administratorski panel.

Promenite datoteku core/urls.py ovako:

# core/urls.py

urlpatterns = [
path("secretadmin/", admin.site.urls),



]

Vaša administratorska stranica bi sada trebalo da bude dostupna na http://localhost:8000/
secretadmin .

Django model i administrator

Neki atributi Django modela direktno utiču na Django administratorski sajt. Najvažnije:

__str__()koristi se za definisanje prikazanog imena objekta

MetaKlasa se koristi za podešavanje različitih opcija metapodataka (npr. orderingi
verbose_name)

Evo primera kako se ovi atributi koriste u praksi:

# tickets/models.py

class ConcertCategory(models.Model):
name = models.CharField(max_length=64)
description = models.TextField(max_length=256, blank=True, null=True)

class Meta:
verbose_name = "concert category"
verbose_name_plural = "concert categories"
ordering = ["-name"]

def __str__(self):
return f"{self.name}"

Naveli smo oblik množine jer množina od „concert category“ nije „concert categories“.

Dostavljanjem orderingatributa, kategorije su sada sortirane po imenu.

Za sve Metaopcije klase, pogledajte opcije meta podataka modela .

Prilagodite administratorsku stranicu pomoću klase ModelAdmin

U ovom odeljku ćemo pogledati kako se koristi klasa ModelAdmin za prilagođavanje
administratorskog sajta.

Prikaz liste kontrola

Atribut list_display vam omogućava da kontrolišete koja polja modela se prikazuju na stranici sa
listom modela. Još jedna odlična stvar je to što može da prikaže povezana polja modela pomoću
__operatora .



Samo napred i ConcertAdminpodesite list_display:

# tickets/admin.py

class ConcertAdmin(admin.ModelAdmin):
list_display = ["name", "venue", "starts_at", "price", "tickets_left"]
readonly_fields = ["tickets_left"]

Sačekajte da se server osveži i pogledajte stranicu sa spiskom koncerata u administratorskom delu.

Nova lista izgleda odlično, ali postoji problem. Dodavanjem mesta održavanja u list_display,
uveli smo problem N + 1. Pošto Django treba da preuzme ime mesta održavanja za svaki koncert
posebno, izvršava se mnogo više upita.

Da bismo izbegli problem N + 1, možemo koristiti atribut list_select_related , koji funkcioniše
slično metodi select_related :

# tickets/admin.py

class ConcertAdmin(admin.ModelAdmin):
list_display = ["name", "venue", "starts_at", "price", "tickets_left"]
list_select_related = ["venue"]
readonly_fields = ["tickets_left"]

Da biste saznali više o performansama Django-a, kao i o N + 1, pogledajte Savete za optimizaciju
performansi Django-a i Automatizaciju testiranja performansi u Django-u .

Zatim, postavite ostale ModelAdmin„s list_display“ za mesta održavanja i karte:

# tickets/admin.py

class VenueAdmin(admin.ModelAdmin):
list_display = ["name", "address", "capacity"]

class TicketAdmin(admin.ModelAdmin):
list_display = [

"customer_full_name", "concert",
"payment_method", "paid_at", "is_active",

]
list_select_related = ["concert", "concert__venue"] # to avoid N + 1

Prilagođena polja za prikazivanje liste

Podešavanje list_displayse takođe može koristiti za dodavanje prilagođenih polja. Da biste



dodali prilagođeno polje, morate definisati novu metodu unutar ModelAdminklase.

Dodajte polje „Rasprodato“, koje važi Trueako nema dostupnih karata:

# tickets/admin.py

class ConcertAdmin(admin.ModelAdmin):
list_display = ["name", "venue", "starts_at", "tickets_left",

"display_sold_out"]
list_select_related = ["venue"]

def display_sold_out(self, obj):
return obj.tickets_left == 0

display_sold_out.short_description = "Sold out"
display_sold_out.boolean = True

Ranije smo short_descriptionpodešavali ime kolone i booleangovorili DŽangu da ta kolona
ima bulovsku vrednost. Na ovaj način, DŽango prikazuje ikonu krstića/kvačice umesto Truei
False. Takođe smo morali da dodamo našu display_sold_outmetodu u list_display.

Zatim, dodajmo prilagođeno polje pod nazivom display_price:

# tickets/admin.py

class ConcertAdmin(admin.ModelAdmin):
list_display = [

"name", "venue", "starts_at", "tickets_left", "display_sold_out",
"display_price"

]
# ...

def display_price(self, obj):
return f"${obj.price}"

display_price.short_description = "Price"
display_price.admin_order_field = "price"

Ranije smo admin_order_fieldgovorili DŽangu po kom polju je ova kolona uređena.

Ponekad može biti korisno dodati veze do povezanih objekata modela umesto samo prikazivanja
njihovog prikazanog imena. Da bismo demonstrirali kako se to radi, povezaćemo mesta održavanja
na stranici sa listom koncerata.



Pre nego što to uradimo, pogledajmo strukturu URL-a administratorskog sajta Django:

Stranica URL Opis
Lista admin:<app>_<model>_changelist Prikazuje listu objekata

Dodaj admin:<app>_<model>_add Obrazac za dodavanje objekta

Promena admin:<app>_<model>_change Obrazac za promenu objekta (potrebno objectId)

Obriši admin:<app>_<model>_delete Obrazac za brisanje objekta (potrebno objectId)

Istorija admin:<app>_<model>_history Prikazuje istoriju objekta (zahteva objectId)

Da bismo dodali vezu do stranice za promenu mesta održavanja, moraćemo da koristimo sledeći
URL:

Format: admin:<app>_<model>_change
Actual: admin:tickets_venue_change

Dodajte display_venuemetodu da ConcertAdminvam se sviđa:

# tickets/admin.py

class ConcertAdmin(DjangoQLSearchMixin, admin.ModelAdmin):
list_display = [

"name", "venue", "starts_at", "tickets_left",
"display_sold_out", "display_price", "display_venue",

]
list_select_related = ["venue"]

# ...

def display_venue(self, obj):
link = reverse("admin:tickets_venue_change", args=[obj.venue.id])
return format_html('<a href="{}">{}</a>', link, obj.venue)

display_venue.short_description = "Venue"

Koristili smo obrnuti metod da bismo obrnuli URL i prosledili obj.venue.idga kao objectId.

Ne zaboravite na uvoz:

from django.urls import reverse
from django.utils.html import format_html

Sačekajte da se razvojni server osveži i idite na stranicu sa spiskom koncerata. Mesta održavanja bi
sada trebalo da budu klikabilna.



Filtriraj objekte modela

Django admin olakšava filtriranje objekata. Da biste omogućili filtriranje, morate navesti koja polja
ili povezana polja modela treba da budu filtrirana. Najbolje od svega je što Django može da slaže
filtere -- npr. filtrira po dva ili više polja istovremeno.

Samo napred i dodajte atribut list_filterConcertAdmin ovako:

# tickets/admin.py

class ConcertAdmin(admin.ModelAdmin):
# ...
list_filter = ["venue"]

Da biste filtrirali po poljima povezanog objekta, koristite __operator .

Prilikom izbora filtera, vodite računa da ne uključite polja sa previše vrednosti. Na primer,
tickets_leftje loš izbor filtera jer za svaki koncert ima različit broj preostalih karata.

Za napredniju funkcionalnost filtriranja, možete definisati i prilagođene filtere. Da biste definisali
prilagođeni filter, morate navesti opcije ili tzv. lookupsi querysetza svaki lookup.

Na primer, da biste filtrirali po tome da li je koncert rasprodat ili ne, kreirajte SoldOutFilteri
uključite ga ConcertAdminu list_filters:

# tickets/admin.py

class SoldOutFilter(SimpleListFilter):
title = "Sold out"
parameter_name = "sold_out"

def lookups(self, request, model_admin):
return [

("yes", "Yes"),
("no", "No"),

]

def queryset(self, request, queryset):
if self.value() == "yes":

return queryset.filter(tickets_left=0)
else:

return queryset.exclude(tickets_left=0)



class ConcertAdmin(admin.ModelAdmin):
# ...
list_filter = ["venue", SoldOutFilter]

Ne zaboravite na uvoz:

from django.contrib.admin import SimpleListFilter

Posetite svoju administratorsku stranicu i uverite se da filteri rade kako je očekivano.

Pretraži objekte modela

Django admin pruža osnovnu funkcionalnost pretrage. Može se omogućiti navođenjem koja polja
modela treba da budu pretraživa putem search_fieldsatributa. Imajte na umu da Django ne
podržava fuzzy upite podrazumevano.

Hajde da omogućimo pretragu naših koncerata po njihovim imenima, mestima održavanja i
adresama mesta održavanja.

Dodajte atribut search_fieldsConcertAdmin ovako:

# tickets/admin.py

class ConcertAdmin(admin.ModelAdmin):
# ...
search_fields = ["name", "venue__name", "venue__address"]

Sačekajte da se server osveži i testirajte polje za pretragu.



Rukovati ugrađenim redovima modela

Administratorski interfejs vam omogućava da uređujete modele na istoj stranici kao i roditeljski
model putem ugrađenih linija. Django pruža dve vrste ugrađenih linija: StackedInline i
TabularInline . Glavna razlika između njih je u njihovom izgledu.

Koristimo inline element za prikazivanje koncerata na stranici sa detaljima o mestu održavanja.

Napravite ConcertInlinei dodajte ga u VenueAdminovako inlines:

# tickets/admin.py

class ConcertInline(admin.TabularInline):
model = Concert
fields = ["name", "starts_at", "price", "tickets_left"]

# optional: make the inline read-only
readonly_fields = ["name", "starts_at", "price", "tickets_left"]
can_delete = False
max_num = 0
extra = 0
show_change_link = True

class VenueAdmin(admin.ModelAdmin):
list_display = ["name", "address", "capacity"]
inlines = [ConcertInline]

Posetite administratorski sajt i idite na stranicu sa detaljima nekog mesta održavanja. Pomerite se
nadole i trebalo bi da se nalazi odeljak „Koncerti“.



Za više informacija o ugrađenim redovima i načinu rukovanja odnosima „više-prema-više“,
pogledajte dokumentaciju administratorske stranice Django-a .

Prilagođene administratorske akcije

Administrativne akcije Django-a vam omogućavaju da izvršite „ akciju “ na objektu ili grupi
objekata. Akcija se može koristiti za izmenu atributa objekta, brisanje objekta, njegovo kopiranje i
tako dalje. Akcije se prvenstveno koriste za često izvršavane „akcije“ ili grupne izmene.

Savršen primer je aktiviranje ili deaktiviranje tiketa. Pretpostavimo da imamo mnogo tiketa koje
želimo da aktiviramo. Bilo bi prilično zamorno kliknuti na svaki od njih, promeniti im
is_activesvojstvo i sačuvati model. Umesto toga, možemo definisati akciju koja će upravo to
uraditi.

Definišite activate_ticketsakcije deactivate_ticketsi dodajte ih na TicketAdminsledeći
način:

# tickets/admin.py

@admin.action(description="Activate selected tickets")
def activate_tickets(modeladmin, request, queryset):

queryset.update(is_active=True)

@admin.action(description="Deactivate selected tickets")
def deactivate_tickets(modeladmin, request, queryset):

queryset.update(is_active=False)

class TicketAdmin(admin.ModelAdmin):
# ...
actions = [activate_tickets, deactivate_tickets]

Ponovo otvorite administratorsku stranicu, idite na prikaz liste zahteva i trebalo bi da vidite
prilagođene akcije. Testirajte ih aktiviranjem i deaktiviranjem više zahteva odjednom.



Za više informacija o administratorskim akcijama u Django-u, pogledajte Administratorske akcije .

Zameni Django administratorske obrasce

Podrazumevano, Django automatski generiše ModelForm za vaš model. Taj obrazac se zatim
koristi na stranici za dodavanje i izmene. Ako želite da prilagodite obrazac ili implementirate
jedinstvenu validaciju podataka, moraćete da ga prepišete.

Da bismo ovo demonstrirali, podelićemo polje customer_full_namena dva unosna polja i
prikazati radio dugmad umesto padajućeg menija za načine plaćanja.

Napravite datoteku forms.py u aplikaciji za karte :

# tickets/forms.py

from django import forms
from django.forms import ModelForm, RadioSelect

from tickets.models import Ticket

class TicketAdminForm(ModelForm):
first_name = forms.CharField(label="First name", max_length=32)
last_name = forms.CharField(label="Last name", max_length=32)

class Meta:
model = Ticket
fields = [

"concert",
"first_name",
"last_name",
"payment_method",



"is_active"
]
widgets = {

"payment_method": RadioSelect(),
}

def __init__(self, *args, **kwargs):
instance = kwargs.get('instance')
initial = {}

if instance:
customer_full_name_split = instance.customer_full_name.split(" ",

maxsplit=1)
initial = {

"first_name": customer_full_name_split[0],
"last_name": customer_full_name_split[1],

}

super().__init__(*args, **kwargs, initial=initial)

def save(self, commit=True):
self.instance.customer_full_name = self.cleaned_data["first_name"] + " 

" \
+ self.cleaned_data["last_name"]

return super().save(commit)

Ovde:

Dodali smo polja obrasca first_namei last_name.

Koristili smo Metaklasu da odredimo na koji model se ovaj obrazac odnosi i koja polja treba
uključiti.

Na obrascu __init__(), popunili smo ga koristeći podatke instance modela.

Dana save(), spojili smo first_namei last_namei sačuvali ga kao customer_full_name.

Zatim, postavite TicketAdminovako form:

# tickets/admin.py

class TicketAdmin(admin.ModelAdmin):
# ...
form = TicketAdminForm



Ne zaboravite na uvoz:

from tickets.forms import TicketAdminForm

Ponovo pokrenite razvojni server i idite na stranicu sa detaljima karte. Ako je sve prošlo kako
treba, trebalo bi da vidite da su ime i prezime sada u odvojenim poljima i da načini plaćanja koriste
radio dugmad umesto padajućeg menija.

Zameni Django administratorske šablone

Administratorski sajt Django-a vam omogućava da prilagodite bilo koji njegov vizuelni aspekt
zamenom šablona. Sve što treba da uradite je:

Pogledajte izvorni kod Django- a i kopirajte originalni šablon.

Nalepite šablon u „templates/admin“ ili „templates/registration“, respektivno.

Izmenite šablon po svom ukusu.

Većinu vremena ćete moći da se izvučete samo promenom dela originalnog šablona.

Na primer, ako želimo da dodamo poruku iznad forme za prijavu, možemo naslediti iz login.html ,
a zatim promeniti content_titleblok:

<!-- templates/admin/login.html -->

{% extends "admin/login.html" %}

{% block content_title %}
<p style="background: #ffffcc; padding: 10px 8px">



        This is a really important message.
</p>

{% endblock %}

Idite na stranicu za prijavu i trebalo bi da vidite žutu poruku.

Napredna pretraga pomoću DjangoQL-a

DjangoQL je moćan paket treće strane koji vam omogućava da izvršavate napredne upite bez
oslanjanja na sirovi SQL. Ima sopstvenu sintaksu i automatsko dovršavanje, podržava logičke
operatore i radi za bilo koji Django model.

Počnite instaliranjem paketa:

(env)$ pip install djangoql==0.17.1

Dodaj INSTALLED_APPSu core/settings.py :

# core/settings.py

INSTALLED_APPS = [
# ...
"djangoql",

]

Zatim, dodajte DjangoQLSearchMixinkao roditeljsku klasu svim ModelAdminklasama gde želite
da omogućite napredne mogućnosti pretraživanja.

Dodajmo to, na TicketAdminprimer:



# tickets/admin.py

class TicketAdmin(DjangoQLSearchMixin, admin.ModelAdmin):
# ...

Ne zaboravite na uvoz:

from djangoql.admin import DjangoQLSearchMixin

Sada možete koristiti isto polje za pretragu kao i ranije da biste izvršili napredne upite. Primeri:

is_active = Truevraća aktivne karte

payment_method = "ET" or payment_method = "BC"vraća karte kupljene kriptovalutama

concert.venue.name ~ "Amphitheatre"vraćanje karata za koncerte u amfiteatrima

concert.tickets_left > 500vraćanje karata za koncerte sa više od 500 preostalih karata

Za više informacija o jeziku DjangoQL pogledajte referencu za jezik DjangoQL .

Uvoz i izvoz podataka pomoću Django Import Export-a

U ovom odeljku ćemo pogledati kako da uvezemo i izvezemo podatke o objektima putem django-
import-export , što je odličan paket za lak uvoz i izvoz podataka u različitim formatima, uključujući
JSON, CSV i YAML. Paket takođe dolazi sa ugrađenom administratorskom integracijom.

Prvo, instalirajte ga:

(env)$ pip install django-import-export==3.2.0

Zatim, dodajte ga INSTALLED_APPSu core/settings.py :

# core/settings.py

INSTALLED_APPS = [
# ...
"import_export",

]

Prikupite statičke datoteke:

(env)$ python manage.py collectstatic

Nakon toga, dodajte ImportExportActionModelAdminkao roditeljsku klasu svim
ModelAdminklasama koje želite da budu uvozne/izvozne.

Evo jednog primera za TicketAdmin:

# tickets/admin.py



class TicketAdmin(DjangoQLSearchMixin, ImportExportActionModelAdmin):
# ...

Morali smo da uklonimo admin.ModelAdminosnovnu klasu, jer
ImportExportActionModelAdminveć nasleđuje od nje. Uključivanje obe klase bi rezultiralo
greškom TypeError.

Ne zaboravite na uvoz:

from import_export.admin import ImportExportActionModelAdmin

Ako želite da model bude samo za izvoz, koristite ExportActionModelAdmin.

Ako sada odete na stranicu sa vašim tiketom, trebalo bi da vidite da je dodata radnja izvoza.
Testirajte je tako što ćete izabrati nekoliko tiketa i željeni format. Zatim kliknite na „Idi“.

Zatim možete testirati funkcionalnost uvoza uvozom upravo izvezene datoteke.

Stilizujte administrativni sajt pomoću Django administrativnog
interfejsa

Prilagođavanje izgleda administratorskog sajta putem zamene šablona može biti nezgodno. Možete
slučajno pokvariti stvari, Django administratorski šabloni se mogu promeniti u budućnosti, a
održavanje će biti muka.

Bolji pristup stilizaciji vašeg administratorskog sajta je putem paketa django-admin-interface .
Ovaj paket dolazi sa prelepim, unapred napravljenim temama administratorskog interfejsa i
omogućava vam da lako prilagodite različite aspekte vašeg administratorskog sajta, uključujući



promenu boja, naslova, favikona, logotipa i još mnogo toga.

Počnite tako što ćete ga instalirati putem pip-a:

(env)$ pip install django-admin-interface==0.26.0

Zatim, dodajte admin_interfacei colorfieldispred INSTALLED_APPS:django.contrib.admin

# core/settings.py

INSTALLED_APPS = [
#...
"admin_interface",
"colorfield",
#...
"django.contrib.admin",
#...

]

X_FRAME_OPTIONS = "SAMEORIGIN" # allows you to use modals insated 
of popups
SILENCED_SYSTEM_CHECKS = ["security.W019"] # ignores redundant warning 
messages

Migrirajte bazu podataka:

(env)$ python manage.py migrate

Prikupljajte statičke datoteke:

(env)$ python manage.py collectstatic --clear

Pokrenite razvojni server i idite na http://localhost:8000/secretadmin . Primetićete da vaš Django
administratorski sajt izgleda modernije i da će postojati odeljak „Administratorski interfejs“.



Kliknite na „Administratorski interfejs > Teme“ da biste videli sve trenutno instalirane teme.
Podrazumevano, trebalo bi da postoji samo jedna tema pod nazivom „Django“. Ako želite, možete
instalirati još tri teme putem fiksnih dodataka:

(env)$ python manage.py loaddata admin_interface_theme_bootstrap.json
(env)$ python manage.py loaddata admin_interface_theme_foundation.json
(env)$ python manage.py loaddata admin_interface_theme_uswds.json

Klik na postojeću temu vam omogućava da prilagodite sve prethodno pomenute aspekte.

Zaključak

U ovom članku smo obradili mnoge koncepte prilagođavanja Django administratorskog panela.
Sada bi trebalo da budete u mogućnosti da primenite ove koncepte u praksi i prilagodite Django
administratorski sajt potrebama vašeg projekta.

Predlažem vam da pogledate i naše ostale članke vezane za Django administratora:

Dodavanje grafikona u Django pomoću Chart.js

Podrška za više jezika u Django-u

Kreiranje prilagođenog korisničkog modela u Django-u

Preuzmite konačni izvorni kod iz django-admin-customization GitHub repozitorijuma.