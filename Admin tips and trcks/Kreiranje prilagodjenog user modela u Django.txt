Creating a Custom User Model in Django

Michael Herman

Kako da potpuno zamenim polje za korisničko ime poljem za e-poštu za Django autentifikaciju?

Ovaj članak objašnjava korak po korak kako da kreirate prilagođeni model korisnika u Django-u
tako da se imejl adresa može koristiti kao primarni identifikator korisnika umesto korisničkog
imena za autentifikaciju.

Imajte na umu da proces opisan u ovom članku zahteva značajne izmene šeme baze podataka.
Zbog toga se preporučuje samo za nove projekte. Ako radite na postojećem nasleđenom projektu,
moraćete da pratite drugačiji skup koraka. Za više informacija o ovome, pogledajte članak
Migracija na prilagođeni korisnički model usred projekta u Django-u .

Ciljevi

ApstraktniKorisnik vs ApstraktniBazniKorisnik

Podešavanje projekta

Testovi

Menadžer modela

Model korisnika

Podešavanja

Obrasci

Administrator

Zaključak

Ciljevi

Do kraja ovog članka, trebalo bi da budete u mogućnosti da:

Opišite razliku između AbstractUseriAbstractBaseUser

Objasnite zašto bi trebalo da podesite prilagođeni korisnički model kada pokrećete novi Django
projekat

Pokrenite novi Django projekat sa prilagođenim korisničkim modelom

Koristite imejl adresu kao primarni identifikator korisnika umesto korisničkog imena za
autentifikaciju



Vežbajte razvoj prvenstveno testiranjem dok implementirate prilagođeni korisnički model

ApstraktniKorisnik vs ApstraktniBazniKorisnik

Podrazumevani model korisnika u Django-u koristi korisničko ime za jedinstvenu identifikaciju
korisnika tokom autentifikacije. Ako biste radije koristili adresu e-pošte, moraćete da kreirate
prilagođeni model korisnika podklasiranjem AbstractUserili AbstractBaseUser.

Opcije:

AbstractUser: Koristite ovu opciju ako ste zadovoljni postojećim poljima na modelu korisnika i
samo želite da uklonite polje za korisničko ime.

AbstractBaseUser: Koristite ovu opciju ako želite da počnete od nule kreiranjem sopstvenog,
potpuno novog korisničkog modela.

U ovom članku ćemo razmotriti obe opcije, AbstractUseri AbstractBaseUser.

Koraci su isti za svaki:

Kreirajte prilagođeni korisnički model i menadžera

Ažuriraj settings.py

Prilagodite UserCreationFormobrasceUserChangeForm

Ažurirajte administratora

Toplo se preporučuje da podesite prilagođeni model korisnika kada pokrećete novi Django
projekat. Bez njega, moraćete da kreirate drugi model (kao što je UserProfile) i povežete ga sa
Django modelom korisnika pomoću OneToOneFieldako želite da dodate nova polja u model
korisnika.

Podešavanje projekta

Počnite kreiranjem novog Django projekta zajedno sa korisničkom aplikacijom:

$ mkdir django-custom-user-model && cd django-custom-user-model
$ python3 -m venv env
$ source env/bin/activate

(env)$ pip install Django==4.1.5
(env)$ django-admin startproject hello_django .
(env)$ python manage.py startapp users

Slobodno zamenite virtualenv i Pip za Poetry ili Pipenv . Za više informacija, pogledajte Modern
Python Environments .

NE primenjujte migracije. Zapamtite: Morate kreirati prilagođeni model korisnika pre nego što



primenite prvu migraciju.

Dodajte novu aplikaciju na INSTALLED_APPSlistu u settings.py :

INSTALLED_APPS = [
"django.contrib.admin",
"django.contrib.auth",
"django.contrib.contenttypes",
"django.contrib.sessions",
"django.contrib.messages",
"django.contrib.staticfiles",

"users", # new
]

Testovi

Hajde da prvo primenimo test:

from django.contrib.auth import get_user_model
from django.test import TestCase

class UsersManagersTests(TestCase):

def test_create_user(self):
User = get_user_model()
user = User.objects.create_user(email="normal@user.com",

password="foo")
self.assertEqual(user.email, "normal@user.com")
self.assertTrue(user.is_active)
self.assertFalse(user.is_staff)
self.assertFalse(user.is_superuser)
try:

# username is None for the AbstractUser option
# username does not exist for the AbstractBaseUser option
self.assertIsNone(user.username)

except AttributeError:
pass

with self.assertRaises(TypeError):
User.objects.create_user()

with self.assertRaises(TypeError):



User.objects.create_user(email="")
with self.assertRaises(ValueError):

User.objects.create_user(email="", password="foo")

def test_create_superuser(self):
User = get_user_model()
admin_user = User.objects.create_superuser(email="super@user.com",

password="foo")
self.assertEqual(admin_user.email, "super@user.com")
self.assertTrue(admin_user.is_active)
self.assertTrue(admin_user.is_staff)
self.assertTrue(admin_user.is_superuser)
try:

# username is None for the AbstractUser option
# username does not exist for the AbstractBaseUser option
self.assertIsNone(admin_user.username)

except AttributeError:
pass

with self.assertRaises(ValueError):
User.objects.create_superuser(

email="super@user.com", password="foo", is_superuser=False)

Dodajte specifikacije u users/tests.py , a zatim se uverite da testovi ne uspevaju.

Menadžer modela

Prvo, treba da dodamo prilagođeni Manager , podklasiranjem BaseUserManager, koji koristi imejl
adresu kao jedinstveni identifikator umesto korisničkog imena.

Napravite datoteku managers.py u direktorijumu „users“:

from django.contrib.auth.base_user import BaseUserManager
from django.utils.translation import gettext_lazy as _

class CustomUserManager(BaseUserManager):
"""

    Custom user model manager where email is the unique identifiers
    for authentication instead of usernames.
    """

def create_user(self, email, password, **extra_fields):
"""



        Create and save a user with the given email and password.
        """

if not email:
raise ValueError(_("The Email must be set"))

email = self.normalize_email(email)
user = self.model(email=email, **extra_fields)
user.set_password(password)
user.save()
return user

def create_superuser(self, email, password, **extra_fields):
"""

        Create and save a SuperUser with the given email and password.
        """

extra_fields.setdefault("is_staff", True)
extra_fields.setdefault("is_superuser", True)
extra_fields.setdefault("is_active", True)

if extra_fields.get("is_staff") is not True:
raise ValueError(_("Superuser must have is_staff=True."))

if extra_fields.get("is_superuser") is not True:
raise ValueError(_("Superuser must have is_superuser=True."))

return self.create_user(email, password, **extra_fields)

Model korisnika

Odlučite koju opciju želite da koristite: podklasiranje AbstractUserili AbstractBaseUser.

ApstraktKorisnik

Ažurirajte users/models.py :

from django.contrib.auth.models import AbstractUser
from django.db import models
from django.utils.translation import gettext_lazy as _

from .managers import CustomUserManager

class CustomUser(AbstractUser):
username = None



email = models.EmailField(_("email address"), unique=True)

USERNAME_FIELD = "email"
REQUIRED_FIELDS = []

objects = CustomUserManager()

def __str__(self):
return self.email

Ovde, mi:

Napravio sam novu klasu pod nazivom CustomUserpodklaseAbstractUser

Uklonili ste usernamepolje

Polje je učinjeno emailobaveznim i jedinstvenim

Postavite USERNAME_FIELD-- što definiše jedinstveni identifikator za Usermodel -- naemail

Navedeno je da svi objekti za klasu dolaze izCustomUserManager

ApstraktniBazniKorisnik

Ažurirajte users/models.py :

from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin
from django.db import models
from django.utils import timezone
from django.utils.translation import gettext_lazy as _

from .managers import CustomUserManager

class CustomUser(AbstractBaseUser, PermissionsMixin):
email = models.EmailField(_("email address"), unique=True)
is_staff = models.BooleanField(default=False)
is_active = models.BooleanField(default=True)
date_joined = models.DateTimeField(default=timezone.now)

USERNAME_FIELD = "email"
REQUIRED_FIELDS = []

objects = CustomUserManager()



def __str__(self):
return self.email

Ovde, mi:

Napravio sam novu klasu pod nazivom CustomUserpodklaseAbstractBaseUser

Dodata polja za email, is_staff, is_activeidate_joined

Postavite USERNAME_FIELD-- što definiše jedinstveni identifikator za Usermodel -- naemail

Navedeno je da svi objekti za klasu dolaze izCustomUserManager

Podešavanja

Dodajte sledeći red u datoteku settings.py kako bi Django znao da koristi novu prilagođenu klasu
korisnika:

AUTH_USER_MODEL = "users.CustomUser"

Sada možete da kreirate i primenite migracije, što će kreirati novu bazu podataka koja koristi
prilagođeni korisnički model. Pre nego što to uradimo, pogledajmo kako će migracija zapravo
izgledati bez kreiranja datoteke za migraciju, sa zastavicom --dry-run :

(env)$ python manage.py makemigrations --dry-run --verbosity 3

Trebalo bi da vidite nešto slično:

# Generated by Django 4.1.5 on 2023-01-21 20:36

from django.db import migrations, models
import django.utils.timezone

class Migration(migrations.Migration):

initial = True

dependencies = [
('auth', '0012_alter_user_first_name_max_length'),

]

operations = [
migrations.CreateModel(

name='CustomUser',



fields=[
('id', models.BigAutoField(auto_created=True, primary_key=True,

serialize=False, verbose_name='ID')),
('password', models.CharField(max_length=128,

verbose_name='password')),
('last_login', models.DateTimeField(blank=True, null=True,

verbose_name='last login')),
('is_superuser', models.BooleanField(default=False,

help_text='Designates that this user has all permissions without explicitly 
assigning them.', verbose_name='superuser status')),

('first_name', models.CharField(blank=True, max_length=150,
verbose_name='first name')),

('last_name', models.CharField(blank=True, max_length=150,
verbose_name='last name')),

('is_staff', models.BooleanField(default=False,
help_text='Designates whether the user can log into this admin site.',
verbose_name='staff status')),

('is_active', models.BooleanField(default=True,
help_text='Designates whether this user should be treated as active. Unselect 
this instead of deleting accounts.', verbose_name='active')),

('date_joined',
models.DateTimeField(default=django.utils.timezone.now, verbose_name='date 
joined')),

('email', models.EmailField(max_length=254, unique=True,
verbose_name='email address')),

('groups', models.ManyToManyField(blank=True, help_text='The 
groups this user belongs to. A user will get all permissions granted to each of 
their groups.', related_name='user_set', related_query_name='user',
to='auth.group', verbose_name='groups')),

('user_permissions', models.ManyToManyField(blank=True,
help_text='Specific permissions for this user.', related_name='user_set',
related_query_name='user', to='auth.permission', verbose_name='user 
permissions')),

],
options={

'verbose_name': 'user',
'verbose_name_plural': 'users',
'abstract': False,

},
),



]

Ako ste išli tim AbstractBaseUserputem, nećete imati polja za first_nameili last_name. Zašto?

Uverite se da migracija ne uključuje usernamepolje. Zatim kreirajte i primenite migraciju:

(env)$ python manage.py makemigrations
(env)$ python manage.py migrate

Pogledajte šemu:

$ sqlite3 db.sqlite3

SQLite version 3.28.0 2019-04-15 14:49:49
Enter ".help" for usage hints.

sqlite> .tables

auth_group                         django_migrations
auth_group_permissions             django_session
auth_permission                    users_customuser
django_admin_log                   users_customuser_groups
django_content_type                users_customuser_user_permissions

sqlite> .schema users_customuser

CREATE TABLE IF NOT EXISTS "users_customuser" (
"id" integer NOT NULL PRIMARY KEY AUTOINCREMENT,
"password" varchar(128) NOT NULL,
"last_login" datetime NULL,
"is_superuser" bool NOT NULL,
"first_name" varchar(150) NOT NULL,
"last_name" varchar(150) NOT NULL,
"is_staff" bool NOT NULL,
"is_active" bool NOT NULL,
"date_joined" datetime NOT NULL,
"email" varchar(254) NOT NULL UNIQUE

);

Ako ste išli tim AbstractBaseUserputem, zašto je to last_logindeo modela?

Sada možete da referencirate korisnički model sa get_user_model()ili
settings.AUTH_USER_MODEL. Za više informacija pogledajte Referenciranje korisničkog modela u
zvaničnoj dokumentaciji.



Takođe, kada kreirate superkorisnika, trebalo bi da vam se zatraži da unesete imejl adresu umesto
korisničkog imena:

(env)$ python manage.py createsuperuser

Email address: test@test.com
Password:
Password (again):
Superuser created successfully.

Uverite se da testovi prođu:

(env)$ python manage.py test

Creating test database for alias 'default'...
System check identified no issues (0 silenced).
..
----------------------------------------------------------------------
Ran 2 tests in 0.282s

OK
Destroying test database for alias 'default'...

Obrasci

Zatim, hajde da podklasiramo UserCreationFormforme UserChangeFormi tako da koriste novi
CustomUsermodel.

Napravite novu datoteku u „users“-u pod nazivom forms.py :

from django.contrib.auth.forms import UserCreationForm, UserChangeForm

from .models import CustomUser

class CustomUserCreationForm(UserCreationForm):

class Meta:
model = CustomUser
fields = ("email",)

class CustomUserChangeForm(UserChangeForm):



class Meta:
model = CustomUser
fields = ("email",)

Administrator

Recite administratoru da koristi ove forme tako što će napraviti podklase UserAdminu users/
admin.py :

from django.contrib import admin
from django.contrib.auth.admin import UserAdmin

from .forms import CustomUserCreationForm, CustomUserChangeForm
from .models import CustomUser

class CustomUserAdmin(UserAdmin):
add_form = CustomUserCreationForm
form = CustomUserChangeForm
model = CustomUser
list_display = ("email", "is_staff", "is_active",)
list_filter = ("email", "is_staff", "is_active",)
fieldsets = (

(None, {"fields": ("email", "password")}),
("Permissions", {"fields": ("is_staff", "is_active", "groups",

"user_permissions")}),
)
add_fieldsets = (

(None, {
"classes": ("wide",),
"fields": (

"email", "password1", "password2", "is_staff",
"is_active", "groups", "user_permissions"

)}
),

)
search_fields = ("email",)
ordering = ("email",)



admin.site.register(CustomUser, CustomUserAdmin)

To je to. Pokrenite server i prijavite se na administratorski sajt. Trebalo bi da možete da dodajete i
menjate korisnike kao i obično.

Zaključak

U ovom članku smo pogledali kako da kreiramo prilagođeni model korisnika tako da se imejl
adresa može koristiti kao primarni identifikator korisnika umesto korisničkog imena za
autentifikaciju.

AbstractUserKonačni kod za obe opcije, i , možete pronaći AbstractBaseUseru repozitorijumu
django-custom-user-model . Primeri konačnog koda takođe uključuju šablone, prikaze i URL-ove
potrebne za autentifikaciju korisnika.

Želite da saznate više o prilagođavanju korisničkog modela u Django-u? Pogledajte sledeće resurse:

Opcije i objekti: Prilagođavanje korisničkog modela Django-a

Kako proširiti Django korisnički model

Maksimalno iskorišćavanje korisničkog modela kompanije Django (video)



Prilagođavanje autentifikacije u Django-u