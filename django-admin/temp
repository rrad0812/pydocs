### DjangoQL šema

Šema defniniše ograničenja - šta možete uraditi sa `DjangoQL` upitom. Ako ne specificirate šemu, `DjangoQL` će vam pružiti default šemu. On će se kretati rekurzivno kroz polja modela i veze, i uključiti sve što nadje u šemi, tako da će korisnik moći da pretražuje preko svega.

Ponekad to nije ono što želite, bilo zbog db performansi bilo zbog bezbednosti. Ako bi želeli da ograničite search modela ili polja, trebalo bi da definišete šemu. Ovde je jedan primer:

```py
class UserQLSchema(DjangoQLSchema):
    exclude = (Book,)
    suggest_options = {
        Group: ['name'],
    }

    def get_fields(self, model):
        if model == Group:
            return ['name']
        return super(UserQLSchema, self).get_fields(model)

@admin.register(User)
class CustomUserAdmin(DjangoQLSearchMixin, UserAdmin):
    djangoql_schema = UserQLSchema
```

U primeru smo kreirali šemu koja radi tri stvari:

- isključuje model "Book" iz pretrage preko `exclude` opcije, takodje možete koristiti opciju `include`, koja ograničava pretragu samo po izlistanim modelima;

- ograničava raspoloživa polja za pretragu za Group model na polje `name`, u `get_fields()` metodi;

- omogućuje kompletirajuću opciju za Group names preko `suggest_options`.

  Primedba za `suggest_options`:
  - ona gleda za choices model polje parametre prvo,
  - ako nije spec., sinhrono uzima sve vrednosti za data model polja,
  - tako da bi trebali da sprečite velike querset-ove ovde.

    Ako želite da definišete prilagodjenu suggest_options, vidi ispod.

[Sadržaj](#sadržaj)

### Prilagodjena polja za pretragu

Dublje prilagodjenje pretrage može biti postignuto sa prilagodjenim `search` poljima. Prilagodjena `search` polja mogu biti korišćenja:

- za pretragu po annotacijama,
- za definisanje `suggest_options`, ili
- definisanju pune prilagodjene search logike.

U d`jangoql.schema`, DjangoQL definiše sledeća polja bazne klase koje mogu biti nasledjene za definisanje sopstvenog ponašanja:

- IntField
- FloatField
- StrFieldBoolField
- DateField
- DateTimeField
- RelationField

Ovde su primeri za česte slučajeve upotrebe:

[Sadržaj](#sadržaj)

#### Search po queryset annotacijama

```py
from djangoql.schema import DjangoQLSchema, IntField

class UserQLSchema(DjangoQLSchema):

    def get_fields(self, model):
        fields = super(UserQLSchema, self).get_fields(model)
        if model == User:
            fields += [IntField(name='groups_count')]
            return fields

@admin.register(User)
class CustomUserAdmin(DjangoQLSearchMixin, UserAdmin):
    djangoql_schema = UserQLSchema

    def get_queryset(self, request):
        qs = super(CustomUserAdmin, self).get_queryset(request)
        return qs.annotate(groups_count=Count('groups'))
```

Prvo smo dodali "groups_count" annotaciju na queryset koji koristi Django admin u
"CustomUserAdmin.get_queryset()" metodi. On bi trebao da sadrži broj grupa kojima jedan korisnik pripada.

Kada naš queryset sada podigne tu kolonu, možemo filtrirati po njoj. Samo treba da bude uključena u šemu.

U "UserQLSchema.get_fields()" definišemo prilagodjeno integer search polje za "User" model. Njegovo ime treba da je isto sa imenom kolone u queryset-u.

[Sadržaj](#sadržaj)

#### Prilagođene suggest_options

```py
from djangoql.schema import DjangoQLSchema, StrField

class GroupNameField(StrField):
    model = Groupname = 'name'
    suggest_options = True

    def get_options(self, search):
        return super(GroupNameField, self) \
    
    .get_options(search) \
        .annotate(users_count=Count('user'))\
            .order_by('-users_count')

class UserQLSchema(DjangoQLSchema):def get_fields(self, model):
    if model == Group:
        return ['id', GroupNameField()]
    return super(UserQLSchema, self).get_fields(model)

@admin.register(User)
class CustomUserAdmin(DjangoQLSearchMixin, UserAdmin):

djangoql_schema = UserQLSchema
```

U ovom primeru definisali smo prilagođeno GroupNameField koje sortira sugestije za grupu imena po popularnosti, (broj korisnika u grupi) umesto default alphabetical sortinga.

[Sadržaj](#sadržaj)

#### Prilagodjeni search lookup

DjangoQL bazna polja pružaju dva osnovna metoda koje možete prepisati radi zamene ili kolone za pretragu, vrednosti pretrage ili oba.

.get_lookup_name() i .get_lookup_value(value):

```py
class UserDateJoinedYear(IntField):name = 'date_joined_year'
def get_lookup_name(self): return 'date_joined year'

class UserQLSchema(DjangoQLSchema):def get_fields(self, model):
fields = super(UserQLSchema, self).get_fields(model)
if model == User:

fields += [UserDateJoinedYear()]return fields
@admin.register(User)
class CustomUserAdmin(DjangoQLSearchMixin, UserAdmin):djangoql_schema = UserQLSchema
```

U ovom primeru mi smo definisali prilagodjeno date_joined_year search polje za korisnike. I koristili smo ugradjeni Django year filter opciju u .get_lookup_name() za filtriranje po godini samo.

Slično možete koristiti .get_lookup_value(value) hook za promenu search vrednosti pre nego se koristi u filteru.

[Sadržaj](#sadržaj)

#### Puni prilagodjeni search lookup

.get_lookup_name() i .get_lookup_value(value) hooks pokrivaju više jednostavnih slučajeva korišćenja. Ali ponekad nisu dovoljni i vi želite punu prilagodjenu search logiku. U tim slučajevima možete nadjačati glavni .get_lookup() metod polja.

Primer ispod demonstrira pretragu po godinama korisnika:

```py
from djangoql.schema import DjangoQLSchema, IntFieldclass UserAgeField(IntField):
"""
Search by given number of full years
"""
model = Username = 'age'

def get_lookup_name(self):
    """
    We'll be doing comparisons vs. this model field
    """
    return 'date_joined'

def get_lookup(self, path, operator, value):
    """
    The lookup should support with all operators compatible with IntField
    """
    if operator == 'in':
        result = None
        for year in value:
            condition = self.get_lookup(path, '=', year)
            result = condition if result is None else result | condition
        return result

    elif operator == 'not in':result = None
        for year in value:
            condition = self.get_lookup(path, '!=', year)
            result = condition if result is None else result & condition
        return result
    
    value = self.get_lookup_value(value)
    search_field = ' '.join(path + [self.get_lookup_name()])
    year_start =  self.years_ago(value + 1)
    year_end = self.years_ago(value)
    
    if operator == '=':
        return ( Q(**{'%s gt' % search_field: year_start}) &Q(**{'%s lte' % search_field: year_end})
    )
    elif operator == '!=':
        return (Q(**{'%s lte' % search_field: year_start}) |Q(**{'%s gt' %
            search_field: year_end})
    )
    elif operator == '>':
        return Q(**{'%s lt' % search_field: year_start})
    elif operator == '>=':
        return Q(**{'%s lte' % search_field: year_end})
    elif operator == '<':
        return Q(**{'%s gt' % search_field: year_end})
    elif operator == '<=':
        return Q(**{'%s gte' % search_field: year_start})

def years_ago(self, n):
    timestamp = now() 
    
    try:
        return timestamp.replace(year=timestamp.year - n)
    except ValueError:
        February 29
    return timestamp.replace(month=2, day=28, year=timestamp.year - n)

class UserQLSchema(DjangoQLSchema):
    
    def get_fields(self, model):
        fields = super(UserQLSchema, self).get_fields(model)
        if model == User:
            fields += [UserAgeField()]return fields

@admin.register(User)
class CustomUserAdmin(DjangoQLSearchMixin, UserAdmin):
    djangoql_schema = UserQLSchema
```

[Sadržaj](#sadržaj)

### Mogu li koristiti Django QL van Django admina

Da. Možete dodati DjangoQL search funkcionalnost na bilo koji Django model korišćenjem
DjangoQLQuerySet:

```py
from django.db import models
from djangoql.queryset import DjangoQLQuerySet

class Book(models.Model):
    name = models.CharField(max_length=255)
    author = models.ForeignKey('auth.User')
    objects = DjangoQLQuerySet.as_manager()
```

Sa gornjim primerom možemo raditi pretraživanja kao:

```py
qs = Book.objects.djangoql(
    'name ~ "war" and author.last_name = "Tolstoy"'
)
```

Vraća normalni queryset, možete ga proširiti i ponovo koristiti ako je neophodno.

```py
print(qs.count())
```

Alternativno možete dodati DjangoQL search na svaki queryset, čak iako nije instanca `DjangoQLQuerySet`:

```py
from django.contrib.auth.models import User from djangoql.queryset import apply_search
qs = User.objects.all()
qs = apply_search(qs, 'groups = None') print(qs.exists())
```

Šema može bti spec. bilo kao `queryset` opcija, ili prosledjena `djangoql()` queryset metod direktno:

```py
class BookQuerySet(DjangoQLQuerySet):
    djangoql_schema = BookSchema

class Book(models.Model):
    ...
    objects = BookQuerySet.as_manager()
```

Sada, "Book.objects.djangoql()" će koristiti BookSchema po default-u:

```py
Book.objects.djangoql('name ~ "Peace") uses BookSchema
```

Prepisivanje default queryset šeme sa `AnotherSchema`:

```py
Book.objects.djangoql('name ~ "Peace", schema=AnotherSchema)
```

Možete obezbediti šemu kao opciju za `apply_search()`

```py
qs = User.objects.all()
Book.objects.djangoql('name ~ "Peace", schema=AnotherSchema)
```
